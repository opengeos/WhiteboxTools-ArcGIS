import arcpy
import os, sys
import webbrowser
from WBT.whitebox_tools import WhiteboxTools
if sys.version_info < (3, 0):
    from StringIO import StringIO
else:
    from io import StringIO

wbt = WhiteboxTools()
tool_labels = []

tool_labels.append("Absolute Value")
tool_labels.append("Accumulation Curvature")
tool_labels.append("Adaptive Filter")
tool_labels.append("Add")
tool_labels.append("Add Point Coordinates To Table")
tool_labels.append("Aggregate Raster")
tool_labels.append("And")
tool_labels.append("Anova")
tool_labels.append("Arc Cos")
tool_labels.append("Arc Sin")
tool_labels.append("Arc Tan")
tool_labels.append("Arcosh")
tool_labels.append("Arsinh")
tool_labels.append("Artanh")
tool_labels.append("Ascii To Las")
tool_labels.append("Aspect")
tool_labels.append("Assess Route")
tool_labels.append("Atan2")
tool_labels.append("Attribute Correlation")
tool_labels.append("Attribute Correlation Neighbourhood Analysis")
tool_labels.append("Attribute Histogram")
tool_labels.append("Attribute Scattergram")
tool_labels.append("Average Flowpath Slope")
tool_labels.append("Average Normal Vector Angular Deviation")
tool_labels.append("Average Overlay")
tool_labels.append("Average Upslope Flowpath Length")
tool_labels.append("Balance Contrast Enhancement")
tool_labels.append("Basins")
tool_labels.append("Bilateral Filter")
tool_labels.append("Block Maximum Gridding")
tool_labels.append("Block Minimum Gridding")
tool_labels.append("Boundary Shape Complexity")
tool_labels.append("Breach Depressions")
tool_labels.append("Breach Depressions Least Cost")
tool_labels.append("Breach Single Cell Pits")
tool_labels.append("Breakline Mapping")
tool_labels.append("Buffer Raster")
tool_labels.append("Burn Streams At Roads")
tool_labels.append("Canny Edge Detection")
tool_labels.append("Ceil")
tool_labels.append("Centroid")
tool_labels.append("Centroid Vector")
tool_labels.append("Change Vector Analysis")
tool_labels.append("Circular Variance Of Aspect")
tool_labels.append("Classify Buildings In Lidar")
tool_labels.append("Classify Lidar")
tool_labels.append("Classify Overlap Points")
tool_labels.append("Clean Vector")
tool_labels.append("Clip")
tool_labels.append("Clip Lidar To Polygon")
tool_labels.append("Clip Raster To Polygon")
tool_labels.append("Closing")
tool_labels.append("Clump")
tool_labels.append("Colourize Based On Class")
tool_labels.append("Colourize Based On Point Returns")
tool_labels.append("Compactness Ratio")
tool_labels.append("Conditional Evaluation")
tool_labels.append("Conditioned Latin Hypercube")
tool_labels.append("Conservative Smoothing Filter")
tool_labels.append("Construct Vector Tin")
tool_labels.append("Contours From Points")
tool_labels.append("Contours From Raster")
tool_labels.append("Convert Nodata To Zero")
tool_labels.append("Convert Raster Format")
tool_labels.append("Corner Detection")
tool_labels.append("Correct Vignetting")
tool_labels.append("Cos")
tool_labels.append("Cosh")
tool_labels.append("Cost Allocation")
tool_labels.append("Cost Distance")
tool_labels.append("Cost Pathway")
tool_labels.append("Count If")
tool_labels.append("Create Colour Composite")
tool_labels.append("Create Hexagonal Vector Grid")
tool_labels.append("Create Plane")
tool_labels.append("Create Rectangular Vector Grid")
tool_labels.append("Crispness Index")
tool_labels.append("Cross Tabulation")
tool_labels.append("Csv Points To Vector")
tool_labels.append("Cumulative Distribution")
tool_labels.append("Curvedness")
tool_labels.append("D Inf Flow Accumulation")
tool_labels.append("D Inf Mass Flux")
tool_labels.append("D Inf Pointer")
tool_labels.append("D8 Flow Accumulation")
tool_labels.append("D8 Mass Flux")
tool_labels.append("D8 Pointer")
tool_labels.append("Dbscan")
tool_labels.append("Decrement")
tool_labels.append("Dem Void Filling")
tool_labels.append("Depth In Sink")
tool_labels.append("Depth To Water")
tool_labels.append("Dev From Mean Elev")
tool_labels.append("Diff From Mean Elev")
tool_labels.append("Diff Of Gaussian Filter")
tool_labels.append("Difference")
tool_labels.append("Difference Curvature")
tool_labels.append("Direct Decorrelation Stretch")
tool_labels.append("Directional Relief")
tool_labels.append("Dissolve")
tool_labels.append("Distance To Outlet")
tool_labels.append("Diversity Filter")
tool_labels.append("Divide")
tool_labels.append("Downslope Distance To Stream")
tool_labels.append("Downslope Flowpath Length")
tool_labels.append("Downslope Index")
tool_labels.append("Edge Contamination")
tool_labels.append("Edge Density")
tool_labels.append("Edge Preserving Mean Filter")
tool_labels.append("Edge Proportion")
tool_labels.append("Elev Above Pit")
tool_labels.append("Elev Percentile")
tool_labels.append("Elev Relative To Min Max")
tool_labels.append("Elev Relative To Watershed Min Max")
tool_labels.append("Elevation Above Stream")
tool_labels.append("Elevation Above Stream Euclidean")
tool_labels.append("Eliminate Coincident Points")
tool_labels.append("Elongation Ratio")
tool_labels.append("Embankment Mapping")
tool_labels.append("Emboss Filter")
tool_labels.append("Equal To")
tool_labels.append("Erase")
tool_labels.append("Erase Polygon From Lidar")
tool_labels.append("Erase Polygon From Raster")
tool_labels.append("Euclidean Allocation")
tool_labels.append("Euclidean Distance")
tool_labels.append("Evaluate Training Sites")
tool_labels.append("Exp")
tool_labels.append("Exp2")
tool_labels.append("Export Table To Csv")
tool_labels.append("Exposure Towards Wind Flux")
tool_labels.append("Extend Vector Lines")
tool_labels.append("Extract Nodes")
tool_labels.append("Extract Raster Values At Points")
tool_labels.append("Extract Streams")
tool_labels.append("Extract Valleys")
tool_labels.append("Farthest Channel Head")
tool_labels.append("Fast Almost Gaussian Filter")
tool_labels.append("Fd8 Flow Accumulation")
tool_labels.append("Fd8 Pointer")
tool_labels.append("Feature Preserving Smoothing")
tool_labels.append("Fetch Analysis")
tool_labels.append("Fill Burn")
tool_labels.append("Fill Depressions")
tool_labels.append("Fill Depressions Planchon And Darboux")
tool_labels.append("Fill Depressions Wang And Liu")
tool_labels.append("Fill Missing Data")
tool_labels.append("Fill Single Cell Pits")
tool_labels.append("Filter Lidar")
tool_labels.append("Filter Lidar Classes")
tool_labels.append("Filter Lidar Scan Angles")
tool_labels.append("Filter Raster Features By Area")
tool_labels.append("Find Flightline Edge Points")
tool_labels.append("Find Lowest Or Highest Points")
tool_labels.append("Find Main Stem")
tool_labels.append("Find No Flow Cells")
tool_labels.append("Find Parallel Flow")
tool_labels.append("Find Patch Or Class Edge Cells")
tool_labels.append("Find Ridges")
tool_labels.append("Fix Dangling Arcs")
tool_labels.append("Flatten Lakes")
tool_labels.append("Flightline Overlap")
tool_labels.append("Flip Image")
tool_labels.append("Flood Order")
tool_labels.append("Floor")
tool_labels.append("Flow Accumulation Full Workflow")
tool_labels.append("Flow Length Diff")
tool_labels.append("Gamma Correction")
tool_labels.append("Gaussian Contrast Stretch")
tool_labels.append("Gaussian Curvature")
tool_labels.append("Gaussian Filter")
tool_labels.append("Gaussian Scale Space")
tool_labels.append("Generalize Classified Raster")
tool_labels.append("Generalize With Similarity")
tool_labels.append("Generating Function")
tool_labels.append("Geomorphons")
tool_labels.append("Greater Than")
tool_labels.append("Hack Stream Order")
tool_labels.append("Heat Map")
tool_labels.append("Height Above Ground")
tool_labels.append("High Pass Bilateral Filter")
tool_labels.append("High Pass Filter")
tool_labels.append("High Pass Median Filter")
tool_labels.append("Highest Position")
tool_labels.append("Hillshade")
tool_labels.append("Hillslopes")
tool_labels.append("Histogram Equalization")
tool_labels.append("Histogram Matching")
tool_labels.append("Histogram Matching Two Images")
tool_labels.append("Hole Proportion")
tool_labels.append("Horizon Angle")
tool_labels.append("Horizontal Excess Curvature")
tool_labels.append("Horton Stream Order")
tool_labels.append("Hydrologic Connectivity")
tool_labels.append("Hypsometric Analysis")
tool_labels.append("Hypsometrically Tinted Hillshade")
tool_labels.append("Idw Interpolation")
tool_labels.append("Ihs To Rgb")
tool_labels.append("Image Autocorrelation")
tool_labels.append("Image Correlation")
tool_labels.append("Image Correlation Neighbourhood Analysis")
tool_labels.append("Image Regression")
tool_labels.append("Image Segmentation")
tool_labels.append("Image Slider")
tool_labels.append("Image Stack Profile")
tool_labels.append("Impoundment Size Index")
tool_labels.append("In Place Add")
tool_labels.append("In Place Divide")
tool_labels.append("In Place Multiply")
tool_labels.append("In Place Subtract")
tool_labels.append("Increment")
tool_labels.append("Individual Tree Detection")
tool_labels.append("Insert Dams")
tool_labels.append("Install Wb Extension")
tool_labels.append("Integer Division")
tool_labels.append("Integral Image")
tool_labels.append("Intersect")
tool_labels.append("Inverse Pca")
tool_labels.append("Is No Data")
tool_labels.append("Isobasins")
tool_labels.append("Jenson Snap Pour Points")
tool_labels.append("Join Tables")
tool_labels.append("K Means Clustering")
tool_labels.append("K Nearest Mean Filter")
tool_labels.append("Kappa Index")
tool_labels.append("Knn Classification")
tool_labels.append("Knn Regression")
tool_labels.append("Ks Test For Normality")
tool_labels.append("Laplacian Filter")
tool_labels.append("Laplacian Of Gaussian Filter")
tool_labels.append("Las To Ascii")
tool_labels.append("Las To Laz")
tool_labels.append("Las To Multipoint Shapefile")
tool_labels.append("Las To Shapefile")
tool_labels.append("Las To Zlidar")
tool_labels.append("Launch Wb Runner")
tool_labels.append("Layer Footprint")
tool_labels.append("Laz To Las")
tool_labels.append("Lee Sigma Filter")
tool_labels.append("Length Of Upstream Channels")
tool_labels.append("Less Than")
tool_labels.append("Lidar Block Maximum")
tool_labels.append("Lidar Block Minimum")
tool_labels.append("Lidar Classify Subset")
tool_labels.append("Lidar Colourize")
tool_labels.append("Lidar Contour")
tool_labels.append("Lidar Digital Surface Model")
tool_labels.append("Lidar Eigenvalue Features")
tool_labels.append("Lidar Elevation Slice")
tool_labels.append("Lidar Ground Point Filter")
tool_labels.append("Lidar Hex Binning")
tool_labels.append("Lidar Hillshade")
tool_labels.append("Lidar Histogram")
tool_labels.append("Lidar Idw Interpolation")
tool_labels.append("Lidar Info")
tool_labels.append("Lidar Join")
tool_labels.append("Lidar Kappa Index")
tool_labels.append("Lidar Nearest Neighbour Gridding")
tool_labels.append("Lidar Point Density")
tool_labels.append("Lidar Point Return Analysis")
tool_labels.append("Lidar Point Stats")
tool_labels.append("Lidar Ransac Planes")
tool_labels.append("Lidar Rbf Interpolation")
tool_labels.append("Lidar Remove Duplicates")
tool_labels.append("Lidar Remove Outliers")
tool_labels.append("Lidar Rooftop Analysis")
tool_labels.append("Lidar Segmentation")
tool_labels.append("Lidar Segmentation Based Filter")
tool_labels.append("Lidar Shift")
tool_labels.append("Lidar Sibson Interpolation")
tool_labels.append("Lidar Thin")
tool_labels.append("Lidar Thin High Density")
tool_labels.append("Lidar Tile")
tool_labels.append("Lidar Tile Footprint")
tool_labels.append("Lidar Tin Gridding")
tool_labels.append("Lidar Tophat Transform")
tool_labels.append("Line Detection Filter")
tool_labels.append("Line Intersections")
tool_labels.append("Line Thinning")
tool_labels.append("Linearity Index")
tool_labels.append("Lines To Polygons")
tool_labels.append("List Unique Values")
tool_labels.append("List Unique Values Raster")
tool_labels.append("Ln")
tool_labels.append("Local Hypsometric Analysis")
tool_labels.append("Local Quadratic Regression")
tool_labels.append("Log10")
tool_labels.append("Log2")
tool_labels.append("Logistic Regression")
tool_labels.append("Long Profile")
tool_labels.append("Long Profile From Points")
tool_labels.append("Longest Flowpath")
tool_labels.append("Low Points On Headwater Divides")
tool_labels.append("Lowest Position")
tool_labels.append("Majority Filter")
tool_labels.append("Map Off Terrain Objects")
tool_labels.append("Max")
tool_labels.append("Max Absolute Overlay")
tool_labels.append("Max Anisotropy Dev")
tool_labels.append("Max Anisotropy Dev Signature")
tool_labels.append("Max Branch Length")
tool_labels.append("Max Difference From Mean")
tool_labels.append("Max Downslope Elev Change")
tool_labels.append("Max Elev Dev Signature")
tool_labels.append("Max Elevation Deviation")
tool_labels.append("Max Overlay")
tool_labels.append("Max Upslope Elev Change")
tool_labels.append("Max Upslope Flowpath Length")
tool_labels.append("Max Upslope Value")
tool_labels.append("Maximal Curvature")
tool_labels.append("Maximum Filter")
tool_labels.append("Md Inf Flow Accumulation")
tool_labels.append("Mean Curvature")
tool_labels.append("Mean Filter")
tool_labels.append("Median Filter")
tool_labels.append("Medoid")
tool_labels.append("Merge Line Segments")
tool_labels.append("Merge Table With Csv")
tool_labels.append("Merge Vectors")
tool_labels.append("Min")
tool_labels.append("Min Absolute Overlay")
tool_labels.append("Min Dist Classification")
tool_labels.append("Min Downslope Elev Change")
tool_labels.append("Min Max Contrast Stretch")
tool_labels.append("Min Overlay")
tool_labels.append("Minimal Curvature")
tool_labels.append("Minimum Bounding Box")
tool_labels.append("Minimum Bounding Circle")
tool_labels.append("Minimum Bounding Envelope")
tool_labels.append("Minimum Convex Hull")
tool_labels.append("Minimum Filter")
tool_labels.append("Modified K Means Clustering")
tool_labels.append("Modify Lidar")
tool_labels.append("Modify No Data Value")
tool_labels.append("Modulo")
tool_labels.append("Mosaic")
tool_labels.append("Mosaic With Feathering")
tool_labels.append("Multi Part To Single Part")
tool_labels.append("Multidirectional Hillshade")
tool_labels.append("Multiply")
tool_labels.append("Multiply Overlay")
tool_labels.append("Multiscale Curvatures")
tool_labels.append("Multiscale Elevation Percentile")
tool_labels.append("Multiscale Roughness")
tool_labels.append("Multiscale Roughness Signature")
tool_labels.append("Multiscale Std Dev Normals")
tool_labels.append("Multiscale Std Dev Normals Signature")
tool_labels.append("Multiscale Topographic Position Image")
tool_labels.append("Narrowness Index")
tool_labels.append("Natural Neighbour Interpolation")
tool_labels.append("Nearest Neighbour Gridding")
tool_labels.append("Negate")
tool_labels.append("New Raster From Base")
tool_labels.append("Normal Vectors")
tool_labels.append("Normalize Lidar")
tool_labels.append("Normalized Difference Index")
tool_labels.append("Not")
tool_labels.append("Not Equal To")
tool_labels.append("Num Downslope Neighbours")
tool_labels.append("Num Inflowing Neighbours")
tool_labels.append("Num Upslope Neighbours")
tool_labels.append("Olympic Filter")
tool_labels.append("Opening")
tool_labels.append("Openness")
tool_labels.append("Or")
tool_labels.append("Paired Sample T Test")
tool_labels.append("Panchromatic Sharpening")
tool_labels.append("Parallelepiped Classification")
tool_labels.append("Patch Orientation")
tool_labels.append("Pennock Landform Class")
tool_labels.append("Percent Elev Range")
tool_labels.append("Percent Equal To")
tool_labels.append("Percent Greater Than")
tool_labels.append("Percent Less Than")
tool_labels.append("Percentage Contrast Stretch")
tool_labels.append("Percentile Filter")
tool_labels.append("Perimeter Area Ratio")
tool_labels.append("Phi Coefficient")
tool_labels.append("Pick From List")
tool_labels.append("Piecewise Contrast Stretch")
tool_labels.append("Plan Curvature")
tool_labels.append("Polygon Area")
tool_labels.append("Polygon Long Axis")
tool_labels.append("Polygon Perimeter")
tool_labels.append("Polygon Short Axis")
tool_labels.append("Polygonize")
tool_labels.append("Polygons To Lines")
tool_labels.append("Power")
tool_labels.append("Prewitt Filter")
tool_labels.append("Principal Component Analysis")
tool_labels.append("Print Geo Tiff Tags")
tool_labels.append("Profile")
tool_labels.append("Profile Curvature")
tool_labels.append("Qin Flow Accumulation")
tool_labels.append("Quantiles")
tool_labels.append("Quinn Flow Accumulation")
tool_labels.append("Radial Basis Function Interpolation")
tool_labels.append("Radius Of Gyration")
tool_labels.append("Raise Walls")
tool_labels.append("Random Field")
tool_labels.append("Random Forest Classification")
tool_labels.append("Random Forest Regression")
tool_labels.append("Random Sample")
tool_labels.append("Range Filter")
tool_labels.append("Raster Area")
tool_labels.append("Raster Calculator")
tool_labels.append("Raster Cell Assignment")
tool_labels.append("Raster Histogram")
tool_labels.append("Raster Perimeter")
tool_labels.append("Raster Streams To Vector")
tool_labels.append("Raster Summary Stats")
tool_labels.append("Raster To Vector Lines")
tool_labels.append("Raster To Vector Points")
tool_labels.append("Raster To Vector Polygons")
tool_labels.append("Rasterize Streams")
tool_labels.append("Reciprocal")
tool_labels.append("Reclass")
tool_labels.append("Reclass Equal Interval")
tool_labels.append("Reclass From File")
tool_labels.append("Reconcile Multiple Headers")
tool_labels.append("Recover Flightline Info")
tool_labels.append("Recreate Pass Lines")
tool_labels.append("Reinitialize Attribute Table")
tool_labels.append("Related Circumscribing Circle")
tool_labels.append("Relative Aspect")
tool_labels.append("Relative Topographic Position")
tool_labels.append("Remove Field Edge Points")
tool_labels.append("Remove Off Terrain Objects")
tool_labels.append("Remove Polygon Holes")
tool_labels.append("Remove Raster Polygon Holes")
tool_labels.append("Remove Short Streams")
tool_labels.append("Remove Spurs")
tool_labels.append("Repair Stream Vector Topology")
tool_labels.append("Resample")
tool_labels.append("Rescale Value Range")
tool_labels.append("Rgb To Ihs")
tool_labels.append("Rho8 Flow Accumulation")
tool_labels.append("Rho8 Pointer")
tool_labels.append("Ring Curvature")
tool_labels.append("River Centerlines")
tool_labels.append("Roberts Cross Filter")
tool_labels.append("Root Mean Square Error")
tool_labels.append("Rotor")
tool_labels.append("Round")
tool_labels.append("Ruggedness Index")
tool_labels.append("Scharr Filter")
tool_labels.append("Sediment Transport Index")
tool_labels.append("Select Tiles By Polygon")
tool_labels.append("Set Nodata Value")
tool_labels.append("Shadow Animation")
tool_labels.append("Shadow Image")
tool_labels.append("Shape Complexity Index")
tool_labels.append("Shape Complexity Index Raster")
tool_labels.append("Shape Index")
tool_labels.append("Shreve Stream Magnitude")
tool_labels.append("Sigmoidal Contrast Stretch")
tool_labels.append("Sin")
tool_labels.append("Single Part To Multi Part")
tool_labels.append("Sinh")
tool_labels.append("Sink")
tool_labels.append("Slope")
tool_labels.append("Slope Vs Aspect Plot")
tool_labels.append("Slope Vs Elevation Plot")
tool_labels.append("Smooth Vectors")
tool_labels.append("Smooth Vegetation Residual")
tool_labels.append("Snap Pour Points")
tool_labels.append("Sobel Filter")
tool_labels.append("Sort Lidar")
tool_labels.append("Spherical Std Dev Of Normals")
tool_labels.append("Split Colour Composite")
tool_labels.append("Split Lidar")
tool_labels.append("Split Vector Lines")
tool_labels.append("Split With Lines")
tool_labels.append("Square")
tool_labels.append("Square Root")
tool_labels.append("Standard Deviation Contrast Stretch")
tool_labels.append("Standard Deviation Filter")
tool_labels.append("Standard Deviation Of Slope")
tool_labels.append("Stochastic Depression Analysis")
tool_labels.append("Strahler Order Basins")
tool_labels.append("Strahler Stream Order")
tool_labels.append("Stream Link Class")
tool_labels.append("Stream Link Identifier")
tool_labels.append("Stream Link Length")
tool_labels.append("Stream Link Slope")
tool_labels.append("Stream Power Index")
tool_labels.append("Stream Slope Continuous")
tool_labels.append("Subbasins")
tool_labels.append("Subtract")
tool_labels.append("Sum Overlay")
tool_labels.append("Surface Area Ratio")
tool_labels.append("Svm Classification")
tool_labels.append("Svm Regression")
tool_labels.append("Symmetrical Difference")
tool_labels.append("Tan")
tool_labels.append("Tangential Curvature")
tool_labels.append("Tanh")
tool_labels.append("Thicken Raster Line")
tool_labels.append("Time In Daylight")
tool_labels.append("Tin Gridding")
tool_labels.append("To Degrees")
tool_labels.append("To Radians")
tool_labels.append("Tophat Transform")
tool_labels.append("Topo Render")
tool_labels.append("Topographic Position Animation")
tool_labels.append("Topological Stream Order")
tool_labels.append("Total Curvature")
tool_labels.append("Total Filter")
tool_labels.append("Trace Downslope Flowpaths")
tool_labels.append("Travelling Salesman Problem")
tool_labels.append("Trend Surface")
tool_labels.append("Trend Surface Vector Points")
tool_labels.append("Tributary Identifier")
tool_labels.append("Truncate")
tool_labels.append("Turning Bands Simulation")
tool_labels.append("Two Sample Ks Test")
tool_labels.append("Union")
tool_labels.append("Unnest Basins")
tool_labels.append("Unsharp Masking")
tool_labels.append("Unsphericity")
tool_labels.append("Update Nodata Cells")
tool_labels.append("Upslope Depression Storage")
tool_labels.append("User Defined Weights Filter")
tool_labels.append("Vector Hex Binning")
tool_labels.append("Vector Lines To Raster")
tool_labels.append("Vector Points To Raster")
tool_labels.append("Vector Polygons To Raster")
tool_labels.append("Vector Stream Network Analysis")
tool_labels.append("Vertical Excess Curvature")
tool_labels.append("Viewshed")
tool_labels.append("Visibility Index")
tool_labels.append("Voronoi Diagram")
tool_labels.append("Watershed")
tool_labels.append("Weighted Overlay")
tool_labels.append("Weighted Sum")
tool_labels.append("Wetness Index")
tool_labels.append("Wilcoxon Signed Rank Test")
tool_labels.append("Write Function Memory Insertion")
tool_labels.append("Xor")
tool_labels.append("Yield Filter")
tool_labels.append("Yield Map")
tool_labels.append("Yield Normalization")
tool_labels.append("Z Scores")
tool_labels.append("Zlidar To Las")
tool_labels.append("Zonal Statistics")


class Toolbox(object):
    def __init__(self):
        """Define the toolbox (the name of the toolbox is the name of the .pyt file)."""
        self.label = "WhiteboxTools Toolbox"
        self.alias = "WBT"

        # List of tool classes associated with this toolbox
        tools = []        
        tools.append(Help)
        tools.append(License)
        tools.append(Version)
        tools.append(ListTools)
        tools.append(ToolHelp)
        tools.append(ToolParameters)
        tools.append(ViewCode)
        tools.append(RunTool)

        tools.append(AbsoluteValue)
        tools.append(AccumulationCurvature)
        tools.append(AdaptiveFilter)
        tools.append(Add)
        tools.append(AddPointCoordinatesToTable)
        tools.append(AggregateRaster)
        tools.append(And)
        tools.append(Anova)
        tools.append(ArcCos)
        tools.append(ArcSin)
        tools.append(ArcTan)
        tools.append(Arcosh)
        tools.append(Arsinh)
        tools.append(Artanh)
        tools.append(AsciiToLas)
        tools.append(Aspect)
        tools.append(AssessRoute)
        tools.append(Atan2)
        tools.append(AttributeCorrelation)
        tools.append(AttributeCorrelationNeighbourhoodAnalysis)
        tools.append(AttributeHistogram)
        tools.append(AttributeScattergram)
        tools.append(AverageFlowpathSlope)
        tools.append(AverageNormalVectorAngularDeviation)
        tools.append(AverageOverlay)
        tools.append(AverageUpslopeFlowpathLength)
        tools.append(BalanceContrastEnhancement)
        tools.append(Basins)
        tools.append(BilateralFilter)
        tools.append(BlockMaximumGridding)
        tools.append(BlockMinimumGridding)
        tools.append(BoundaryShapeComplexity)
        tools.append(BreachDepressions)
        tools.append(BreachDepressionsLeastCost)
        tools.append(BreachSingleCellPits)
        tools.append(BreaklineMapping)
        tools.append(BufferRaster)
        tools.append(BurnStreamsAtRoads)
        tools.append(CannyEdgeDetection)
        tools.append(Ceil)
        tools.append(Centroid)
        tools.append(CentroidVector)
        tools.append(ChangeVectorAnalysis)
        tools.append(CircularVarianceOfAspect)
        tools.append(ClassifyBuildingsInLidar)
        tools.append(ClassifyLidar)
        tools.append(ClassifyOverlapPoints)
        tools.append(CleanVector)
        tools.append(Clip)
        tools.append(ClipLidarToPolygon)
        tools.append(ClipRasterToPolygon)
        tools.append(Closing)
        tools.append(Clump)
        tools.append(ColourizeBasedOnClass)
        tools.append(ColourizeBasedOnPointReturns)
        tools.append(CompactnessRatio)
        tools.append(ConditionalEvaluation)
        tools.append(ConditionedLatinHypercube)
        tools.append(ConservativeSmoothingFilter)
        tools.append(ConstructVectorTin)
        tools.append(ContoursFromPoints)
        tools.append(ContoursFromRaster)
        tools.append(ConvertNodataToZero)
        tools.append(ConvertRasterFormat)
        tools.append(CornerDetection)
        tools.append(CorrectVignetting)
        tools.append(Cos)
        tools.append(Cosh)
        tools.append(CostAllocation)
        tools.append(CostDistance)
        tools.append(CostPathway)
        tools.append(CountIf)
        tools.append(CreateColourComposite)
        tools.append(CreateHexagonalVectorGrid)
        tools.append(CreatePlane)
        tools.append(CreateRectangularVectorGrid)
        tools.append(CrispnessIndex)
        tools.append(CrossTabulation)
        tools.append(CsvPointsToVector)
        tools.append(CumulativeDistribution)
        tools.append(Curvedness)
        tools.append(D8FlowAccumulation)
        tools.append(D8MassFlux)
        tools.append(D8Pointer)
        tools.append(DInfFlowAccumulation)
        tools.append(DInfMassFlux)
        tools.append(DInfPointer)
        tools.append(Dbscan)
        tools.append(Decrement)
        tools.append(DemVoidFilling)
        tools.append(DepthInSink)
        tools.append(DepthToWater)
        tools.append(DevFromMeanElev)
        tools.append(DiffFromMeanElev)
        tools.append(DiffOfGaussianFilter)
        tools.append(Difference)
        tools.append(DifferenceCurvature)
        tools.append(DirectDecorrelationStretch)
        tools.append(DirectionalRelief)
        tools.append(Dissolve)
        tools.append(DistanceToOutlet)
        tools.append(DiversityFilter)
        tools.append(Divide)
        tools.append(DownslopeDistanceToStream)
        tools.append(DownslopeFlowpathLength)
        tools.append(DownslopeIndex)
        tools.append(EdgeContamination)
        tools.append(EdgeDensity)
        tools.append(EdgePreservingMeanFilter)
        tools.append(EdgeProportion)
        tools.append(ElevAbovePit)
        tools.append(ElevPercentile)
        tools.append(ElevRelativeToMinMax)
        tools.append(ElevRelativeToWatershedMinMax)
        tools.append(ElevationAboveStream)
        tools.append(ElevationAboveStreamEuclidean)
        tools.append(EliminateCoincidentPoints)
        tools.append(ElongationRatio)
        tools.append(EmbankmentMapping)
        tools.append(EmbossFilter)
        tools.append(EqualTo)
        tools.append(Erase)
        tools.append(ErasePolygonFromLidar)
        tools.append(ErasePolygonFromRaster)
        tools.append(EuclideanAllocation)
        tools.append(EuclideanDistance)
        tools.append(EvaluateTrainingSites)
        tools.append(Exp)
        tools.append(Exp2)
        tools.append(ExportTableToCsv)
        tools.append(ExposureTowardsWindFlux)
        tools.append(ExtendVectorLines)
        tools.append(ExtractNodes)
        tools.append(ExtractRasterValuesAtPoints)
        tools.append(ExtractStreams)
        tools.append(ExtractValleys)
        tools.append(Fd8FlowAccumulation)
        tools.append(Fd8Pointer)
        tools.append(FarthestChannelHead)
        tools.append(FastAlmostGaussianFilter)
        tools.append(FeaturePreservingSmoothing)
        tools.append(FetchAnalysis)
        tools.append(FillBurn)
        tools.append(FillDepressions)
        tools.append(FillDepressionsPlanchonAndDarboux)
        tools.append(FillDepressionsWangAndLiu)
        tools.append(FillMissingData)
        tools.append(FillSingleCellPits)
        tools.append(FilterLidar)
        tools.append(FilterLidarClasses)
        tools.append(FilterLidarScanAngles)
        tools.append(FilterRasterFeaturesByArea)
        tools.append(FindFlightlineEdgePoints)
        tools.append(FindLowestOrHighestPoints)
        tools.append(FindMainStem)
        tools.append(FindNoFlowCells)
        tools.append(FindParallelFlow)
        tools.append(FindPatchOrClassEdgeCells)
        tools.append(FindRidges)
        tools.append(FixDanglingArcs)
        tools.append(FlattenLakes)
        tools.append(FlightlineOverlap)
        tools.append(FlipImage)
        tools.append(FloodOrder)
        tools.append(Floor)
        tools.append(FlowAccumulationFullWorkflow)
        tools.append(FlowLengthDiff)
        tools.append(GammaCorrection)
        tools.append(GaussianContrastStretch)
        tools.append(GaussianCurvature)
        tools.append(GaussianFilter)
        tools.append(GaussianScaleSpace)
        tools.append(GeneralizeClassifiedRaster)
        tools.append(GeneralizeWithSimilarity)
        tools.append(GeneratingFunction)
        tools.append(Geomorphons)
        tools.append(GreaterThan)
        tools.append(HackStreamOrder)
        tools.append(HeatMap)
        tools.append(HeightAboveGround)
        tools.append(HighPassBilateralFilter)
        tools.append(HighPassFilter)
        tools.append(HighPassMedianFilter)
        tools.append(HighestPosition)
        tools.append(Hillshade)
        tools.append(Hillslopes)
        tools.append(HistogramEqualization)
        tools.append(HistogramMatching)
        tools.append(HistogramMatchingTwoImages)
        tools.append(HoleProportion)
        tools.append(HorizonAngle)
        tools.append(HorizontalExcessCurvature)
        tools.append(HortonStreamOrder)
        tools.append(HydrologicConnectivity)
        tools.append(HypsometricAnalysis)
        tools.append(HypsometricallyTintedHillshade)
        tools.append(IdwInterpolation)
        tools.append(IhsToRgb)
        tools.append(ImageAutocorrelation)
        tools.append(ImageCorrelation)
        tools.append(ImageCorrelationNeighbourhoodAnalysis)
        tools.append(ImageRegression)
        tools.append(ImageSegmentation)
        tools.append(ImageSlider)
        tools.append(ImageStackProfile)
        tools.append(ImpoundmentSizeIndex)
        tools.append(InPlaceAdd)
        tools.append(InPlaceDivide)
        tools.append(InPlaceMultiply)
        tools.append(InPlaceSubtract)
        tools.append(Increment)
        tools.append(IndividualTreeDetection)
        tools.append(InsertDams)
        tools.append(InstallWbExtension)
        tools.append(IntegerDivision)
        tools.append(IntegralImage)
        tools.append(Intersect)
        tools.append(InversePrincipalComponentAnalysis)
        tools.append(IsNoData)
        tools.append(Isobasins)
        tools.append(JensonSnapPourPoints)
        tools.append(JoinTables)
        tools.append(KMeansClustering)
        tools.append(KNearestMeanFilter)
        tools.append(KappaIndex)
        tools.append(KnnClassification)
        tools.append(KnnRegression)
        tools.append(KsTestForNormality)
        tools.append(LaplacianFilter)
        tools.append(LaplacianOfGaussianFilter)
        tools.append(LasToAscii)
        tools.append(LasToLaz)
        tools.append(LasToMultipointShapefile)
        tools.append(LasToShapefile)
        tools.append(LasToZlidar)
        tools.append(LaunchWbRunner)
        tools.append(LayerFootprint)
        tools.append(LazToLas)
        tools.append(LeeSigmaFilter)
        tools.append(LengthOfUpstreamChannels)
        tools.append(LessThan)
        tools.append(LidarBlockMaximum)
        tools.append(LidarBlockMinimum)
        tools.append(LidarClassifySubset)
        tools.append(LidarColourize)
        tools.append(LidarContour)
        tools.append(LidarDigitalSurfaceModel)
        tools.append(LidarEigenvalueFeatures)
        tools.append(LidarElevationSlice)
        tools.append(LidarGroundPointFilter)
        tools.append(LidarHexBinning)
        tools.append(LidarHillshade)
        tools.append(LidarHistogram)
        tools.append(LidarIdwInterpolation)
        tools.append(LidarInfo)
        tools.append(LidarJoin)
        tools.append(LidarKappaIndex)
        tools.append(LidarNearestNeighbourGridding)
        tools.append(LidarPointDensity)
        tools.append(LidarPointReturnAnalysis)
        tools.append(LidarPointStats)
        tools.append(LidarRansacPlanes)
        tools.append(LidarRbfInterpolation)
        tools.append(LidarRemoveDuplicates)
        tools.append(LidarRemoveOutliers)
        tools.append(LidarRooftopAnalysis)
        tools.append(LidarSegmentation)
        tools.append(LidarSegmentationBasedFilter)
        tools.append(LidarShift)
        tools.append(LidarSibsonInterpolation)
        tools.append(LidarTinGridding)
        tools.append(LidarThin)
        tools.append(LidarThinHighDensity)
        tools.append(LidarTile)
        tools.append(LidarTileFootprint)
        tools.append(LidarTophatTransform)
        tools.append(LineDetectionFilter)
        tools.append(LineIntersections)
        tools.append(LineThinning)
        tools.append(LinearityIndex)
        tools.append(LinesToPolygons)
        tools.append(ListUniqueValues)
        tools.append(ListUniqueValuesRaster)
        tools.append(Ln)
        tools.append(LocalHypsometricAnalysis)
        tools.append(LocalQuadraticRegression)
        tools.append(Log10)
        tools.append(Log2)
        tools.append(LogisticRegression)
        tools.append(LongProfile)
        tools.append(LongProfileFromPoints)
        tools.append(LongestFlowpath)
        tools.append(LowPointsOnHeadwaterDivides)
        tools.append(LowestPosition)
        tools.append(MdInfFlowAccumulation)
        tools.append(MajorityFilter)
        tools.append(MapOffTerrainObjects)
        tools.append(Max)
        tools.append(MaxAbsoluteOverlay)
        tools.append(MaxAnisotropyDev)
        tools.append(MaxAnisotropyDevSignature)
        tools.append(MaxBranchLength)
        tools.append(MaxDifferenceFromMean)
        tools.append(MaxDownslopeElevChange)
        tools.append(MaxElevDevSignature)
        tools.append(MaxElevationDeviation)
        tools.append(MaxOverlay)
        tools.append(MaxUpslopeElevChange)
        tools.append(MaxUpslopeFlowpathLength)
        tools.append(MaxUpslopeValue)
        tools.append(MaximalCurvature)
        tools.append(MaximumFilter)
        tools.append(MeanCurvature)
        tools.append(MeanFilter)
        tools.append(MedianFilter)
        tools.append(Medoid)
        tools.append(MergeLineSegments)
        tools.append(MergeTableWithCsv)
        tools.append(MergeVectors)
        tools.append(Min)
        tools.append(MinAbsoluteOverlay)
        tools.append(MinDistClassification)
        tools.append(MinDownslopeElevChange)
        tools.append(MinMaxContrastStretch)
        tools.append(MinOverlay)
        tools.append(MinimalCurvature)
        tools.append(MinimumBoundingBox)
        tools.append(MinimumBoundingCircle)
        tools.append(MinimumBoundingEnvelope)
        tools.append(MinimumConvexHull)
        tools.append(MinimumFilter)
        tools.append(ModifiedKMeansClustering)
        tools.append(ModifyLidar)
        tools.append(ModifyNoDataValue)
        tools.append(Modulo)
        tools.append(Mosaic)
        tools.append(MosaicWithFeathering)
        tools.append(MultiPartToSinglePart)
        tools.append(MultidirectionalHillshade)
        tools.append(Multiply)
        tools.append(MultiplyOverlay)
        tools.append(MultiscaleCurvatures)
        tools.append(MultiscaleElevationPercentile)
        tools.append(MultiscaleRoughness)
        tools.append(MultiscaleRoughnessSignature)
        tools.append(MultiscaleStdDevNormals)
        tools.append(MultiscaleStdDevNormalsSignature)
        tools.append(MultiscaleTopographicPositionImage)
        tools.append(NarrownessIndex)
        tools.append(NaturalNeighbourInterpolation)
        tools.append(NearestNeighbourGridding)
        tools.append(Negate)
        tools.append(NewRasterFromBase)
        tools.append(NormalVectors)
        tools.append(NormalizeLidar)
        tools.append(NormalizedDifferenceIndex)
        tools.append(Not)
        tools.append(NotEqualTo)
        tools.append(NumDownslopeNeighbours)
        tools.append(NumInflowingNeighbours)
        tools.append(NumUpslopeNeighbours)
        tools.append(OlympicFilter)
        tools.append(Opening)
        tools.append(Openness)
        tools.append(Or)
        tools.append(PairedSampleTTest)
        tools.append(PanchromaticSharpening)
        tools.append(ParallelepipedClassification)
        tools.append(PatchOrientation)
        tools.append(PennockLandformClass)
        tools.append(PercentElevRange)
        tools.append(PercentEqualTo)
        tools.append(PercentGreaterThan)
        tools.append(PercentLessThan)
        tools.append(PercentageContrastStretch)
        tools.append(PercentileFilter)
        tools.append(PerimeterAreaRatio)
        tools.append(PhiCoefficient)
        tools.append(PickFromList)
        tools.append(PiecewiseContrastStretch)
        tools.append(PlanCurvature)
        tools.append(PolygonArea)
        tools.append(PolygonLongAxis)
        tools.append(PolygonPerimeter)
        tools.append(PolygonShortAxis)
        tools.append(Polygonize)
        tools.append(PolygonsToLines)
        tools.append(Power)
        tools.append(PrewittFilter)
        tools.append(PrincipalComponentAnalysis)
        tools.append(PrintGeoTiffTags)
        tools.append(Profile)
        tools.append(ProfileCurvature)
        tools.append(QinFlowAccumulation)
        tools.append(Quantiles)
        tools.append(QuinnFlowAccumulation)
        tools.append(RadialBasisFunctionInterpolation)
        tools.append(RadiusOfGyration)
        tools.append(RaiseWalls)
        tools.append(RandomField)
        tools.append(RandomForestClassification)
        tools.append(RandomForestRegression)
        tools.append(RandomSample)
        tools.append(RangeFilter)
        tools.append(RasterArea)
        tools.append(RasterCalculator)
        tools.append(RasterCellAssignment)
        tools.append(RasterHistogram)
        tools.append(RasterPerimeter)
        tools.append(RasterStreamsToVector)
        tools.append(RasterSummaryStats)
        tools.append(RasterToVectorLines)
        tools.append(RasterToVectorPoints)
        tools.append(RasterToVectorPolygons)
        tools.append(RasterizeStreams)
        tools.append(Reciprocal)
        tools.append(Reclass)
        tools.append(ReclassEqualInterval)
        tools.append(ReclassFromFile)
        tools.append(ReconcileMultipleHeaders)
        tools.append(RecoverFlightlineInfo)
        tools.append(RecreatePassLines)
        tools.append(ReinitializeAttributeTable)
        tools.append(RelatedCircumscribingCircle)
        tools.append(RelativeAspect)
        tools.append(RelativeTopographicPosition)
        tools.append(RemoveFieldEdgePoints)
        tools.append(RemoveOffTerrainObjects)
        tools.append(RemovePolygonHoles)
        tools.append(RemoveRasterPolygonHoles)
        tools.append(RemoveShortStreams)
        tools.append(RemoveSpurs)
        tools.append(RepairStreamVectorTopology)
        tools.append(Resample)
        tools.append(RescaleValueRange)
        tools.append(RgbToIhs)
        tools.append(Rho8FlowAccumulation)
        tools.append(Rho8Pointer)
        tools.append(RingCurvature)
        tools.append(RiverCenterlines)
        tools.append(RobertsCrossFilter)
        tools.append(RootMeanSquareError)
        tools.append(Rotor)
        tools.append(Round)
        tools.append(RuggednessIndex)
        tools.append(ScharrFilter)
        tools.append(SedimentTransportIndex)
        tools.append(SelectTilesByPolygon)
        tools.append(SetNodataValue)
        tools.append(ShadowAnimation)
        tools.append(ShadowImage)
        tools.append(ShapeComplexityIndex)
        tools.append(ShapeComplexityIndexRaster)
        tools.append(ShapeIndex)
        tools.append(ShreveStreamMagnitude)
        tools.append(SigmoidalContrastStretch)
        tools.append(Sin)
        tools.append(SinglePartToMultiPart)
        tools.append(Sinh)
        tools.append(Sink)
        tools.append(Slope)
        tools.append(SlopeVsAspectPlot)
        tools.append(SlopeVsElevationPlot)
        tools.append(SmoothVectors)
        tools.append(SmoothVegetationResidual)
        tools.append(SnapPourPoints)
        tools.append(SobelFilter)
        tools.append(SortLidar)
        tools.append(SphericalStdDevOfNormals)
        tools.append(SplitColourComposite)
        tools.append(SplitLidar)
        tools.append(SplitVectorLines)
        tools.append(SplitWithLines)
        tools.append(Square)
        tools.append(SquareRoot)
        tools.append(StandardDeviationContrastStretch)
        tools.append(StandardDeviationFilter)
        tools.append(StandardDeviationOfSlope)
        tools.append(StochasticDepressionAnalysis)
        tools.append(StrahlerOrderBasins)
        tools.append(StrahlerStreamOrder)
        tools.append(StreamLinkClass)
        tools.append(StreamLinkIdentifier)
        tools.append(StreamLinkLength)
        tools.append(StreamLinkSlope)
        tools.append(StreamPowerIndex)
        tools.append(StreamSlopeContinuous)
        tools.append(Subbasins)
        tools.append(Subtract)
        tools.append(SumOverlay)
        tools.append(SurfaceAreaRatio)
        tools.append(SvmClassification)
        tools.append(SvmRegression)
        tools.append(SymmetricalDifference)
        tools.append(TinGridding)
        tools.append(Tan)
        tools.append(TangentialCurvature)
        tools.append(Tanh)
        tools.append(ThickenRasterLine)
        tools.append(TimeInDaylight)
        tools.append(ToDegrees)
        tools.append(ToRadians)
        tools.append(TophatTransform)
        tools.append(TopoRender)
        tools.append(TopographicPositionAnimation)
        tools.append(TopologicalStreamOrder)
        tools.append(TotalCurvature)
        tools.append(TotalFilter)
        tools.append(TraceDownslopeFlowpaths)
        tools.append(TravellingSalesmanProblem)
        tools.append(TrendSurface)
        tools.append(TrendSurfaceVectorPoints)
        tools.append(TributaryIdentifier)
        tools.append(Truncate)
        tools.append(TurningBandsSimulation)
        tools.append(TwoSampleKsTest)
        tools.append(Union)
        tools.append(UnnestBasins)
        tools.append(UnsharpMasking)
        tools.append(Unsphericity)
        tools.append(UpdateNodataCells)
        tools.append(UpslopeDepressionStorage)
        tools.append(UserDefinedWeightsFilter)
        tools.append(VectorHexBinning)
        tools.append(VectorLinesToRaster)
        tools.append(VectorPointsToRaster)
        tools.append(VectorPolygonsToRaster)
        tools.append(VectorStreamNetworkAnalysis)
        tools.append(VerticalExcessCurvature)
        tools.append(Viewshed)
        tools.append(VisibilityIndex)
        tools.append(VoronoiDiagram)
        tools.append(Watershed)
        tools.append(WeightedOverlay)
        tools.append(WeightedSum)
        tools.append(WetnessIndex)
        tools.append(WilcoxonSignedRankTest)
        tools.append(WriteFunctionMemoryInsertion)
        tools.append(Xor)
        tools.append(YieldFilter)
        tools.append(YieldMap)
        tools.append(YieldNormalization)
        tools.append(ZScores)
        tools.append(ZlidarToLas)
        tools.append(ZonalStatistics)

        self.tools = tools


class Help(object):
    def __init__(self):
        """Define the tool (tool name is the name of the class)."""
        self.label = "Help"
        self.description = "Help description for WhiteboxTools"
        self.category = "About WhiteboxTools"
        self.canRunInBackground = False

    def getParameterInfo(self):
        """Define parameter definitions"""
        params = None
        return params

    def isLicensed(self):
        """Set whether tool is licensed to execute."""
        return True

    def updateParameters(self, parameters):
        """Modify the values and properties of parameters before internal
        validation is performed.  This method is called whenever a parameter
        has been changed."""
        return

    def updateMessages(self, parameters):
        """Modify the messages created by internal validation for each tool
        parameter.  This method is called after internal validation."""
        return

    def execute(self, parameters, messages):
        """The source code of the tool."""
        messages.addMessage(wbt.help())
        return


class License(object):
    def __init__(self):
        """Define the tool (tool name is the name of the class)."""
        self.label = "License"
        self.description = "License information for WhiteboxTools."
        self.category = "About WhiteboxTools"
        self.canRunInBackground = False

    def getParameterInfo(self):
        """Define parameter definitions"""
        params = None
        return params

    def isLicensed(self):
        """Set whether tool is licensed to execute."""
        return True

    def updateParameters(self, parameters):
        """Modify the values and properties of parameters before internal
        validation is performed.  This method is called whenever a parameter
        has been changed."""
        return

    def updateMessages(self, parameters):
        """Modify the messages created by internal validation for each tool
        parameter.  This method is called after internal validation."""
        return

    def execute(self, parameters, messages):
        """The source code of the tool."""
        messages.addMessage(wbt.license())
        return


class Version(object):
    def __init__(self):
        """Define the tool (tool name is the name of the class)."""
        self.label = "Version"
        self.description = "Version information for WhiteboxTools."
        self.category = "About WhiteboxTools"
        self.canRunInBackground = False

    def getParameterInfo(self):
        """Define parameter definitions"""
        params = None
        return params

    def isLicensed(self):
        """Set whether tool is licensed to execute."""
        return True

    def updateParameters(self, parameters):
        """Modify the values and properties of parameters before internal
        validation is performed.  This method is called whenever a parameter
        has been changed."""
        return

    def updateMessages(self, parameters):
        """Modify the messages created by internal validation for each tool
        parameter.  This method is called after internal validation."""
        return

    def execute(self, parameters, messages):
        """The source code of the tool."""
        messages.addMessage(wbt.version())
        return


class ListTools(object):
    def __init__(self):
        """Define the tool (tool name is the name of the class)."""
        self.label = "List Tools"
        self.description = "All available tools in WhiteboxTools."
        self.category = "About WhiteboxTools"
        self.canRunInBackground = False

    def getParameterInfo(self):
        """Define parameter definitions"""

        # First parameter
        param0 = arcpy.Parameter(
            displayName="Keywords",
            name="keywords",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        # param0.multiValue = True
        param0.value = "lidar"
        params = [param0]
        return params

    def isLicensed(self):
        """Set whether tool is licensed to execute."""
        return True

    def updateParameters(self, parameters):
        """Modify the values and properties of parameters before internal
        validation is performed.  This method is called whenever a parameter
        has been changed."""
        return

    def updateMessages(self, parameters):
        """Modify the messages created by internal validation for each tool
        parameter.  This method is called after internal validation."""
        return

    def execute(self, parameters, messages):
        """The source code of the tool."""
        param0 = parameters[0].valueAsText

        if param0 is None:
            tools = wbt.list_tools()
        else:
            tools = wbt.list_tools([param0])
            
        for index, tool in enumerate(sorted(tools)):
            messages.addMessage("{}. {}: {}".format(index + 1, tool, tools[tool]))
        return


class ToolHelp(object):
    def __init__(self):
        """Define the tool (tool name is the name of the class)."""
        self.label = "Tool Help"
        self.description = "Help description for a specific tool."
        self.category = "About WhiteboxTools"
        self.canRunInBackground = False

    def getParameterInfo(self):
        """Define parameter definitions"""
        tool_name = arcpy.Parameter(
            displayName="Select a tool",
            name="tool_name",
            datatype="GPString",
            parameterType="Required",
            direction="Input")

        tool_name.value = "Lidar Info"
        tool_name.filter.type = "ValueList"
        tool_name.filter.list = tool_labels

        params = [tool_name]
        return params

    def isLicensed(self):
        """Set whether tool is licensed to execute."""
        return True

    def updateParameters(self, parameters):
        """Modify the values and properties of parameters before internal
        validation is performed.  This method is called whenever a parameter
        has been changed."""
        return

    def updateMessages(self, parameters):
        """Modify the messages created by internal validation for each tool
        parameter.  This method is called after internal validation."""
        return

    def execute(self, parameters, messages):
        """The source code of the tool."""
        param0 = parameters[0].valueAsText
        tool_name = param0.replace(" ", "").strip()
        messages.addMessage(wbt.tool_help(tool_name))
        return


class ToolParameters(object):
    def __init__(self):
        """Define the tool (tool name is the name of the class)."""
        self.label = "Tool Parameters"
        self.description = "Tool parameter descriptions for a specific tool."
        self.category = "About WhiteboxTools"
        self.canRunInBackground = False

    def getParameterInfo(self):
        """Define parameter definitions"""
        tool_name = arcpy.Parameter(
            displayName="Select a tool",
            name="tool_name",
            datatype="GPString",
            parameterType="Required",
            direction="Input")

        tool_name.value = "Lidar Info"
        tool_name.filter.type = "ValueList"
        tool_name.filter.list = tool_labels

        params = [tool_name]
        return params

    def isLicensed(self):
        """Set whether tool is licensed to execute."""
        return True

    def updateParameters(self, parameters):
        """Modify the values and properties of parameters before internal
        validation is performed.  This method is called whenever a parameter
        has been changed."""
        return

    def updateMessages(self, parameters):
        """Modify the messages created by internal validation for each tool
        parameter.  This method is called after internal validation."""
        return

    def execute(self, parameters, messages):
        """The source code of the tool."""
        param0 = parameters[0].valueAsText
        tool_name = param0.replace(" ", "").strip()
        messages.addMessage(wbt.tool_parameters(tool_name))
        return


class ViewCode(object):
    def __init__(self):
        """Define the tool (tool name is the name of the class)."""
        self.label = "View Code"
        self.description = "Source code for a specific tool."
        self.category = "About WhiteboxTools"
        self.canRunInBackground = False

    def getParameterInfo(self):
        """Define parameter definitions"""
        tool_name = arcpy.Parameter(
            displayName="Select a tool",
            name="tool_name",
            datatype="GPString",
            parameterType="Required",
            direction="Input")

        tool_name.value = "Lidar Info"
        tool_name.filter.type = "ValueList"
        tool_name.filter.list = tool_labels

        params = [tool_name]
        return params

    def isLicensed(self):
        """Set whether tool is licensed to execute."""
        return True

    def updateParameters(self, parameters):
        """Modify the values and properties of parameters before internal
        validation is performed.  This method is called whenever a parameter
        has been changed."""
        return

    def updateMessages(self, parameters):
        """Modify the messages created by internal validation for each tool
        parameter.  This method is called after internal validation."""
        return

    def execute(self, parameters, messages):
        """The source code of the tool."""
        param0 = parameters[0].valueAsText
        tool_name = param0.replace(" ", "").strip()        
        messages.addMessage("Opening default browser...")
        webbrowser.get('windows-default').open(wbt.view_code(tool_name))
        messages.addMessage(wbt.view_code(tool_name))
        return


class RunTool(object):
    def __init__(self):
        """Define the tool (tool name is the name of the class)."""
        self.label = "Run Tool"
        self.description = "Runs a tool and specifies tool arguments."
        self.category = "About WhiteboxTools"
        self.canRunInBackground = False

    def getParameterInfo(self):
        """Define parameter definitions"""
        tool_name = arcpy.Parameter(
            displayName="Select a tool",
            name="tool_name",
            datatype="GPString",
            parameterType="Required",
            direction="Input")

        tool_name.value = "Breach Depressions"
        tool_name.filter.type = "ValueList"
        tool_name.filter.list = tool_labels

        args = arcpy.Parameter(
            displayName="Arguments",
            name="agrs",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        args.value = '--dem="/path/to/DEM.tif"  --output="/path/to/output.tif"'

        params = [tool_name, args]
        return params

    def isLicensed(self):
        """Set whether tool is licensed to execute."""
        return True

    def updateParameters(self, parameters):
        """Modify the values and properties of parameters before internal
        validation is performed.  This method is called whenever a parameter
        has been changed."""
        return

    def updateMessages(self, parameters):
        """Modify the messages created by internal validation for each tool
        parameter.  This method is called after internal validation."""
        return

    def execute(self, parameters, messages):
        param0 = parameters[0].valueAsText
        args = parameters[1].valueAsText
        tool_name = param0.replace(" ", "").strip()
        dir_path = os.path.dirname(os.path.realpath(__file__))    
        exe_path = os.path.join(dir_path, "WBT/whitebox_tools.exe")
        cmd = '{} --run={} {}'.format(exe_path, tool_name, args)
        if "-v" not in cmd:
            cmd = cmd + ' -v'  
        messages.addMessage(cmd)  
        messages.addMessage(os.popen(cmd).read().rstrip())
        return


class AbsoluteValue(object):
    def __init__(self):
        self.label = "Absolute Value"
        self.description = "Calculates the absolute value of every cell in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.absolute_value(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class AccumulationCurvature(object):
    def __init__(self):
        self.label = "Accumulation Curvature"
        self.description = "This tool calculates accumulation curvature from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input Raster DEM",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster Image",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z-factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        zfactor.value = '1.0'

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.accumulation_curvature(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class AdaptiveFilter(object):
    def __init__(self):
        self.label = "Adaptive Filter"
        self.description = "Performs an adaptive filter on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        threshold = arcpy.Parameter(
            displayName="Difference From Mean Threshold (# Std. Dev.)",
            name="threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        threshold.value = '2.0'

        params = [i, output, filterx, filtery, threshold]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        threshold = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.adaptive_filter(i=i, output=output, filterx=filterx, filtery=filtery, threshold=threshold)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Add(object):
    def __init__(self):
        self.label = "Add"
        self.description = "Performs an addition operation on two rasters or a raster and a constant value."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input1",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            try:
                input1 = str(float(input1))
            except:
                desc = arcpy.Describe(input1)
                input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.add(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class AddPointCoordinatesToTable(object):
    def __init__(self):
        self.label = "Add Point Coordinates To Table"
        self.description = "Modifies the attribute table of a point vector by adding fields containing each point's X and Y coordinates."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.add_point_coordinates_to_table(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class AggregateRaster(object):
    def __init__(self):
        self.label = "Aggregate Raster"
        self.description = "Aggregates a raster to a lower resolution."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        agg_factor = arcpy.Parameter(
            displayName="Aggregation Factor (pixels)",
            name="agg_factor",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        agg_factor.value = '2'

        type = arcpy.Parameter(
            displayName="Aggregation Type",
            name="type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        type.filter.type = "ValueList"
        type.filter.list = ['mean', 'sum', 'maximum', 'minimum', 'range']
        type.value = 'mean'

        params = [i, output, agg_factor, type]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        agg_factor = parameters[2].valueAsText
        type = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.aggregate_raster(i=i, output=output, agg_factor=agg_factor, type=type)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class And(object):
    def __init__(self):
        self.label = "And"
        self.description = "Performs a logical AND operator on two Boolean raster images."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.And(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Anova(object):
    def __init__(self):
        self.label = "Anova"
        self.description = "Performs an analysis of variance (ANOVA) test on a raster dataset."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        features = arcpy.Parameter(
            displayName="Feature Definition (Class) File",
            name="features",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [i, features, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        features = parameters[1].valueAsText
        if features is not None:
            desc = arcpy.Describe(features)
            features = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.anova(i=i, features=features, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ArcCos(object):
    def __init__(self):
        self.label = "Arc Cos"
        self.description = "Returns the inverse cosine (arccos) of each values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.arc_cos(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ArcSin(object):
    def __init__(self):
        self.label = "Arc Sin"
        self.description = "Returns the inverse sine (arcsin) of each values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.arc_sin(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ArcTan(object):
    def __init__(self):
        self.label = "Arc Tan"
        self.description = "Returns the inverse tangent (arctan) of each values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.arc_tan(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Arcosh(object):
    def __init__(self):
        self.label = "Arcosh"
        self.description = "Returns the inverse hyperbolic cosine (arcosh) of each values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.arcosh(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Arsinh(object):
    def __init__(self):
        self.label = "Arsinh"
        self.description = "Returns the inverse hyperbolic sine (arsinh) of each values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.arsinh(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Artanh(object):
    def __init__(self):
        self.label = "Artanh"
        self.description = "Returns the inverse hyperbolic tangent (arctanh) of each values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.artanh(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class AsciiToLas(object):
    def __init__(self):
        self.label = "Ascii To Las"
        self.description = "Converts one or more ASCII files containing LiDAR points into LAS files."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input LiDAR point ASCII Files (.csv)",
            name="inputs",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True
        inputs.filter.list = ["csv"]

        pattern = arcpy.Parameter(
            displayName="Pattern",
            name="pattern",
            datatype="GPString",
            parameterType="Required",
            direction="Input")

        proj = arcpy.Parameter(
            displayName="Well-known-text (WKT) string or EPSG code",
            name="proj",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")

        params = [inputs, pattern, proj]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        pattern = parameters[1].valueAsText
        proj = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.ascii_to_las(inputs=inputs, pattern=pattern, proj=proj)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Aspect(object):
    def __init__(self):
        self.label = "Aspect"
        self.description = "Calculates an aspect raster from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        zfactor = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.aspect(dem=dem, output=output, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class AssessRoute(object):
    def __init__(self):
        self.label = "Assess Route"
        self.description = "This tool assesses a route for slope, elevation, and visibility variation."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        routes = arcpy.Parameter(
            displayName="Input Routes Vector",
            name="routes",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        routes.filter.list = ["Polyline"]

        dem = arcpy.Parameter(
            displayName="Input DEM Raster",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Lines",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        length = arcpy.Parameter(
            displayName="Max Segment Length",
            name="length",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        dist = arcpy.Parameter(
            displayName="Search Distance (grid cells)",
            name="dist",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        dist.value = '20'

        params = [routes, dem, output, length, dist]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        routes = parameters[0].valueAsText
        if routes is not None:
            desc = arcpy.Describe(routes)
            routes = desc.catalogPath
        dem = parameters[1].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[2].valueAsText
        length = parameters[3].valueAsText
        dist = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.assess_route(routes=routes, dem=dem, output=output, length=length, dist=dist)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Atan2(object):
    def __init__(self):
        self.label = "Atan2"
        self.description = "Returns the 2-argument inverse tangent (atan2)."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input_y = arcpy.Parameter(
            displayName="Input Y File Or Constant Value",
            name="input_y",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        input_x = arcpy.Parameter(
            displayName="Input X File Or Constant Value",
            name="input_x",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input_y, input_x, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input_y = parameters[0].valueAsText
        if input_y is not None:
            try:
                input_y = str(float(input_y))
            except:
                desc = arcpy.Describe(input_y)
                input_y = desc.catalogPath
        input_x = parameters[1].valueAsText
        if input_x is not None:
            try:
                input_x = str(float(input_x))
            except:
                desc = arcpy.Describe(input_x)
                input_x = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.atan2(input_y=input_y, input_x=input_x, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class AttributeCorrelation(object):
    def __init__(self):
        self.label = "Attribute Correlation"
        self.description = "Performs a correlation analysis on attribute fields from a vector database."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.attribute_correlation(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class AttributeCorrelationNeighbourhoodAnalysis(object):
    def __init__(self):
        self.label = "Attribute Correlation Neighbourhood Analysis"
        self.description = "Performs a correlation on two input vector attributes within a neighbourhood search windows."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        field1 = arcpy.Parameter(
            displayName="Field Name 1",
            name="field1",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field1.parameterDependencies = [i.name]

        field2 = arcpy.Parameter(
            displayName="Field Name 2",
            name="field2",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field2.parameterDependencies = [i.name]

        radius = arcpy.Parameter(
            displayName="Search Radius (map units)",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        min_points = arcpy.Parameter(
            displayName="Min. Number of Points",
            name="min_points",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")

        stat = arcpy.Parameter(
            displayName="Correlation Statistic Type",
            name="stat",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        stat.filter.type = "ValueList"
        stat.filter.list = ['pearson', 'kendall', 'spearman']
        stat.value = 'pearson'

        params = [i, field1, field2, radius, min_points, stat]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field1 = parameters[1].valueAsText
        field2 = parameters[2].valueAsText
        radius = parameters[3].valueAsText
        min_points = parameters[4].valueAsText
        stat = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.attribute_correlation_neighbourhood_analysis(i=i, field1=field1, field2=field2, radius=radius, min_points=min_points, stat=stat)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class AttributeHistogram(object):
    def __init__(self):
        self.label = "Attribute Histogram"
        self.description = "Creates a histogram for the field values of a vector's attribute table."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        field = arcpy.Parameter(
            displayName="Field Name",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [i.name]

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [i, field, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.attribute_histogram(i=i, field=field, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class AttributeScattergram(object):
    def __init__(self):
        self.label = "Attribute Scattergram"
        self.description = "Creates a scattergram for two field values of a vector's attribute table."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        fieldx = arcpy.Parameter(
            displayName="Field Name X",
            name="fieldx",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        fieldx.parameterDependencies = [i.name]

        fieldy = arcpy.Parameter(
            displayName="Field Name Y",
            name="fieldy",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        fieldy.parameterDependencies = [i.name]

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        trendline = arcpy.Parameter(
            displayName="Draw the trendline?",
            name="trendline",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        trendline.value = 'False'

        params = [i, fieldx, fieldy, output, trendline]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        fieldx = parameters[1].valueAsText
        fieldy = parameters[2].valueAsText
        output = parameters[3].valueAsText
        trendline = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.attribute_scattergram(i=i, fieldx=fieldx, fieldy=fieldy, output=output, trendline=trendline)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class AverageFlowpathSlope(object):
    def __init__(self):
        self.label = "Average Flowpath Slope"
        self.description = "Measures the average slope gradient from each grid cell to all upslope divide cells."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.average_flowpath_slope(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class AverageNormalVectorAngularDeviation(object):
    def __init__(self):
        self.label = "Average Normal Vector Angular Deviation"
        self.description = "Calculates the circular variance of aspect at a scale for a DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filter = arcpy.Parameter(
            displayName="Filter Dimension",
            name="filter",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filter.value = '11'

        params = [dem, output, filter]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        filter = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.average_normal_vector_angular_deviation(dem=dem, output=output, filter=filter)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class AverageOverlay(object):
    def __init__(self):
        self.label = "Average Overlay"
        self.description = "Calculates the average for each grid cell from a group of raster images."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [inputs, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.average_overlay(inputs=inputs, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class AverageUpslopeFlowpathLength(object):
    def __init__(self):
        self.label = "Average Upslope Flowpath Length"
        self.description = "Measures the average length of all upslope flowpaths draining each grid cell."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.average_upslope_flowpath_length(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class BalanceContrastEnhancement(object):
    def __init__(self):
        self.label = "Balance Contrast Enhancement"
        self.description = "Performs a balance contrast enhancement on a colour-composite image of multispectral data."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Colour Composite Image File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        band_mean = arcpy.Parameter(
            displayName="Band Mean Value",
            name="band_mean",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        band_mean.value = '100.0'

        params = [i, output, band_mean]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        band_mean = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.balance_contrast_enhancement(i=i, output=output, band_mean=band_mean)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Basins(object):
    def __init__(self):
        self.label = "Basins"
        self.description = "Identifies drainage basins that drain to the DEM edge."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [d8_pntr, output, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        output = parameters[1].valueAsText
        esri_pntr = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.basins(d8_pntr=d8_pntr, output=output, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class BilateralFilter(object):
    def __init__(self):
        self.label = "Bilateral Filter"
        self.description = "A bilateral filter is an edge-preserving smoothing filter introduced by Tomasi and Manduchi (1998)."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        sigma_dist = arcpy.Parameter(
            displayName="Distance Standard Deviation (pixels)",
            name="sigma_dist",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        sigma_dist.value = '0.75'

        sigma_int = arcpy.Parameter(
            displayName="Intensity Standard Deviation (intensity units)",
            name="sigma_int",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        sigma_int.value = '1.0'

        params = [i, output, sigma_dist, sigma_int]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        sigma_dist = parameters[2].valueAsText
        sigma_int = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.bilateral_filter(i=i, output=output, sigma_dist=sigma_dist, sigma_int=sigma_int)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class BlockMaximumGridding(object):
    def __init__(self):
        self.label = "Block Maximum Gridding"
        self.description = "Creates a raster grid based on a set of vector points and assigns grid values using a block maximum scheme."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        field = arcpy.Parameter(
            displayName="Field Name",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [i.name]

        use_z = arcpy.Parameter(
            displayName="Use z-coordinate instead of field?",
            name="use_z",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        use_z.value = 'False'

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        cell_size = arcpy.Parameter(
            displayName="Cell Size (optional)",
            name="cell_size",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        base = arcpy.Parameter(
            displayName="Base Raster File (optional)",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        params = [i, field, use_z, output, cell_size, base]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        use_z = parameters[2].valueAsText
        output = parameters[3].valueAsText
        cell_size = parameters[4].valueAsText
        base = parameters[5].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.block_maximum_gridding(i=i, field=field, use_z=use_z, output=output, cell_size=cell_size, base=base)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class BlockMinimumGridding(object):
    def __init__(self):
        self.label = "Block Minimum Gridding"
        self.description = "Creates a raster grid based on a set of vector points and assigns grid values using a block minimum scheme."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        field = arcpy.Parameter(
            displayName="Field Name",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [i.name]

        use_z = arcpy.Parameter(
            displayName="Use z-coordinate instead of field?",
            name="use_z",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        use_z.value = 'False'

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        cell_size = arcpy.Parameter(
            displayName="Cell Size (optional)",
            name="cell_size",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        base = arcpy.Parameter(
            displayName="Base Raster File (optional)",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        params = [i, field, use_z, output, cell_size, base]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        use_z = parameters[2].valueAsText
        output = parameters[3].valueAsText
        cell_size = parameters[4].valueAsText
        base = parameters[5].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.block_minimum_gridding(i=i, field=field, use_z=use_z, output=output, cell_size=cell_size, base=base)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class BoundaryShapeComplexity(object):
    def __init__(self):
        self.label = "Boundary Shape Complexity"
        self.description = "Calculates the complexity of the boundaries of raster polygons."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.boundary_shape_complexity(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class BreachDepressions(object):
    def __init__(self):
        self.label = "Breach Depressions"
        self.description = "Breaches all of the depressions in a DEM using Lindsay's (2016) algorithm. This should be preferred over depression filling in most cases."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        max_depth = arcpy.Parameter(
            displayName="Maximum Breach Depth (z units)",
            name="max_depth",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        max_length = arcpy.Parameter(
            displayName="Maximum Breach Channel Length (grid cells)",
            name="max_length",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        flat_increment = arcpy.Parameter(
            displayName="Flat increment value (z units)",
            name="flat_increment",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        fill_pits = arcpy.Parameter(
            displayName="Fill single-cell pits?",
            name="fill_pits",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        fill_pits.value = 'False'

        params = [dem, output, max_depth, max_length, flat_increment, fill_pits]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        max_depth = parameters[2].valueAsText
        max_length = parameters[3].valueAsText
        flat_increment = parameters[4].valueAsText
        fill_pits = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.breach_depressions(dem=dem, output=output, max_depth=max_depth, max_length=max_length, flat_increment=flat_increment, fill_pits=fill_pits)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class BreachDepressionsLeastCost(object):
    def __init__(self):
        self.label = "Breach Depressions Least Cost"
        self.description = "Breaches the depressions in a DEM using a least-cost pathway method."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        dist = arcpy.Parameter(
            displayName="Maximum Search Distance (cells)",
            name="dist",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")

        max_cost = arcpy.Parameter(
            displayName="Maximum Breach Cost (z units)",
            name="max_cost",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        min_dist = arcpy.Parameter(
            displayName="Minimize breach distances?",
            name="min_dist",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        min_dist.value = 'True'

        flat_increment = arcpy.Parameter(
            displayName="Flat increment value (z units)",
            name="flat_increment",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        fill = arcpy.Parameter(
            displayName="Fill unbreached depressions?",
            name="fill",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        fill.value = 'True'

        params = [dem, output, dist, max_cost, min_dist, flat_increment, fill]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        dist = parameters[2].valueAsText
        max_cost = parameters[3].valueAsText
        min_dist = parameters[4].valueAsText
        flat_increment = parameters[5].valueAsText
        fill = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.breach_depressions_least_cost(dem=dem, output=output, dist=dist, max_cost=max_cost, min_dist=min_dist, flat_increment=flat_increment, fill=fill)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class BreachSingleCellPits(object):
    def __init__(self):
        self.label = "Breach Single Cell Pits"
        self.description = "Removes single-cell pits from an input DEM by breaching."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.breach_single_cell_pits(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class BreaklineMapping(object):
    def __init__(self):
        self.label = "Breakline Mapping"
        self.description = "This tool maps breaklines from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input Raster DEM",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Vector Lines File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        threshold = arcpy.Parameter(
            displayName="Threshold Value",
            name="threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        threshold.value = '2.0'

        min_length = arcpy.Parameter(
            displayName="Min. Line Length (In Grid Cells)",
            name="min_length",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_length.value = '3'

        params = [dem, output, threshold, min_length]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        threshold = parameters[2].valueAsText
        min_length = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.breakline_mapping(dem=dem, output=output, threshold=threshold, min_length=min_length)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class BufferRaster(object):
    def __init__(self):
        self.label = "Buffer Raster"
        self.description = "Maps a distance-based buffer around each non-background (non-zero/non-nodata) grid cell in an input image."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        size = arcpy.Parameter(
            displayName="Buffer Size",
            name="size",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        gridcells = arcpy.Parameter(
            displayName="Buffer size measured in grid cells?",
            name="gridcells",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [i, output, size, gridcells]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        size = parameters[2].valueAsText
        gridcells = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.buffer_raster(i=i, output=output, size=size, gridcells=gridcells)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class BurnStreamsAtRoads(object):
    def __init__(self):
        self.label = "Burn Streams At Roads"
        self.description = "Burns-in streams at the sites of road embankments."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Vector Streams File",
            name="streams",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        streams.filter.list = ["Polyline"]

        roads = arcpy.Parameter(
            displayName="Input Vector Roads File",
            name="roads",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        roads.filter.list = ["Polyline"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        width = arcpy.Parameter(
            displayName="Road Embankment Width",
            name="width",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, streams, roads, output, width]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        roads = parameters[2].valueAsText
        if roads is not None:
            desc = arcpy.Describe(roads)
            roads = desc.catalogPath
        output = parameters[3].valueAsText
        width = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.burn_streams_at_roads(dem=dem, streams=streams, roads=roads, output=output, width=width)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CannyEdgeDetection(object):
    def __init__(self):
        self.label = "Canny Edge Detection"
        self.description = "This tool performs a Canny edge-detection filter on an input image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster Image",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster Image",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        sigma = arcpy.Parameter(
            displayName="Sigma Value",
            name="sigma",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        sigma.value = '0.5'

        low = arcpy.Parameter(
            displayName="Low Threshold",
            name="low",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        low.value = '0.05'

        high = arcpy.Parameter(
            displayName="High Threshold",
            name="high",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        high.value = '0.15'

        add_back = arcpy.Parameter(
            displayName="Add edge back to the image?",
            name="add_back",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        add_back.value = 'False'

        params = [i, output, sigma, low, high, add_back]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        sigma = parameters[2].valueAsText
        low = parameters[3].valueAsText
        high = parameters[4].valueAsText
        add_back = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.canny_edge_detection(i=i, output=output, sigma=sigma, low=low, high=high, add_back=add_back)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Ceil(object):
    def __init__(self):
        self.label = "Ceil"
        self.description = "Returns the smallest (closest to negative infinity) value that is greater than or equal to the values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.ceil(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Centroid(object):
    def __init__(self):
        self.label = "Centroid"
        self.description = "Calculates the centroid, or average location, of raster polygon objects."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        text_output = arcpy.Parameter(
            displayName="Output text?",
            name="text_output",
            datatype="GPBoolean",
            parameterType="Required",
            direction="Input")

        params = [i, output, text_output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        text_output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.centroid(i=i, output=output, text_output=text_output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CentroidVector(object):
    def __init__(self):
        self.label = "Centroid Vector"
        self.description = "Identifies the centroid point of a vector polyline or polygon feature or a group of vector points."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.centroid_vector(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ChangeVectorAnalysis(object):
    def __init__(self):
        self.label = "Change Vector Analysis"
        self.description = "Performs a change vector analysis on a two-date multi-spectral dataset."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        date1 = arcpy.Parameter(
            displayName="Earlier Date Input Files",
            name="date1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        date1.multiValue = True

        date2 = arcpy.Parameter(
            displayName="Later Date Input Files",
            name="date2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        date2.multiValue = True

        magnitude = arcpy.Parameter(
            displayName="Output Vector Magnitude File",
            name="magnitude",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        magnitude.filter.list = ["tif"]

        direction = arcpy.Parameter(
            displayName="Output Vector Direction File",
            name="direction",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        direction.filter.list = ["tif"]

        params = [date1, date2, magnitude, direction]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        date1 = parameters[0].valueAsText
        if date1 is not None:
            items = date1.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            date1 = ";".join(items_path)
        date2 = parameters[1].valueAsText
        if date2 is not None:
            items = date2.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            date2 = ";".join(items_path)
        magnitude = parameters[2].valueAsText
        direction = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.change_vector_analysis(date1=date1, date2=date2, magnitude=magnitude, direction=direction)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CircularVarianceOfAspect(object):
    def __init__(self):
        self.label = "Circular Variance Of Aspect"
        self.description = "Calculates the circular variance of aspect at a scale for a DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filter = arcpy.Parameter(
            displayName="Filter Dimension",
            name="filter",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filter.value = '11'

        params = [dem, output, filter]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        filter = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.circular_variance_of_aspect(dem=dem, output=output, filter=filter)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ClassifyBuildingsInLidar(object):
    def __init__(self):
        self.label = "Classify Buildings In Lidar"
        self.description = "Reclassifies a LiDAR points that lie within vector building footprints."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        buildings = arcpy.Parameter(
            displayName="Input Building Polygon File",
            name="buildings",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        buildings.filter.list = ["Polygon"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        params = [i, buildings, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        buildings = parameters[1].valueAsText
        if buildings is not None:
            desc = arcpy.Describe(buildings)
            buildings = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.classify_buildings_in_lidar(i=i, buildings=buildings, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ClassifyLidar(object):
    def __init__(self):
        self.label = "Classify Lidar"
        self.description = "Classify points within a LiDAR point cloud based on point properties."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR Points",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output LiDAR Points",
            name="output",
            datatype="DEFile",
            parameterType="Optional",
            direction="Output")

        radius = arcpy.Parameter(
            displayName="Search Distance:",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        radius.value = '1.5'

        grd_threshold = arcpy.Parameter(
            displayName="Ground Threshold:",
            name="grd_threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        grd_threshold.value = '0.1'

        oto_threshold = arcpy.Parameter(
            displayName="Off-Terrain Object Threshold:",
            name="oto_threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        oto_threshold.value = '2.0'

        planarity_threshold = arcpy.Parameter(
            displayName="Planarity Threshold:",
            name="planarity_threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        planarity_threshold.value = '0.85'

        linearity_threshold = arcpy.Parameter(
            displayName="Linearity Threshold:",
            name="linearity_threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        linearity_threshold.value = '0.70'

        iterations = arcpy.Parameter(
            displayName="Number of Iterations:",
            name="iterations",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        iterations.value = '30'

        facade_threshold = arcpy.Parameter(
            displayName="Facade Threshold:",
            name="facade_threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        facade_threshold.value = '0.5'

        params = [i, output, radius, grd_threshold, oto_threshold, planarity_threshold, linearity_threshold, iterations, facade_threshold]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        radius = parameters[2].valueAsText
        grd_threshold = parameters[3].valueAsText
        oto_threshold = parameters[4].valueAsText
        planarity_threshold = parameters[5].valueAsText
        linearity_threshold = parameters[6].valueAsText
        iterations = parameters[7].valueAsText
        facade_threshold = parameters[8].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.classify_lidar(i=i, output=output, radius=radius, grd_threshold=grd_threshold, oto_threshold=oto_threshold, planarity_threshold=planarity_threshold, linearity_threshold=linearity_threshold, iterations=iterations, facade_threshold=facade_threshold)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ClassifyOverlapPoints(object):
    def __init__(self):
        self.label = "Classify Overlap Points"
        self.description = "Classifies or filters LAS points in regions of overlapping flight lines."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        resolution = arcpy.Parameter(
            displayName="Sample Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        resolution.value = '2.0'

        criterion = arcpy.Parameter(
            displayName="Overlap Criterion",
            name="criterion",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        criterion.filter.type = "ValueList"
        criterion.filter.list = ['max scan angle', 'not min point source ID', 'not min time', 'multiple point source IDs']
        criterion.value = 'max scan angle'

        filter = arcpy.Parameter(
            displayName="Filter out points from overlapping flightlines?",
            name="filter",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        filter.value = 'False'

        params = [i, output, resolution, criterion, filter]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        resolution = parameters[2].valueAsText
        criterion = parameters[3].valueAsText
        filter = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.classify_overlap_points(i=i, output=output, resolution=resolution, criterion=criterion, filter=filter)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CleanVector(object):
    def __init__(self):
        self.label = "Clean Vector"
        self.description = "Removes null features and lines/polygons with fewer than the required number of vertices."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.clean_vector(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Clip(object):
    def __init__(self):
        self.label = "Clip"
        self.description = "Extract all the features, or parts of features, that overlap with the features of the clip vector."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        clip = arcpy.Parameter(
            displayName="Input Clip Polygon Vector File",
            name="clip",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        clip.filter.list = ["Polygon"]

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, clip, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        clip = parameters[1].valueAsText
        if clip is not None:
            desc = arcpy.Describe(clip)
            clip = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.clip(i=i, clip=clip, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ClipLidarToPolygon(object):
    def __init__(self):
        self.label = "Clip Lidar To Polygon"
        self.description = "Clips a LiDAR point cloud to a vector polygon or polygons."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        polygons = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="polygons",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        polygons.filter.list = ["Polygon"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        params = [i, polygons, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        polygons = parameters[1].valueAsText
        if polygons is not None:
            desc = arcpy.Describe(polygons)
            polygons = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.clip_lidar_to_polygon(i=i, polygons=polygons, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ClipRasterToPolygon(object):
    def __init__(self):
        self.label = "Clip Raster To Polygon"
        self.description = "Clips a raster to a vector polygon."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        polygons = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="polygons",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        polygons.filter.list = ["Polygon"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        maintain_dimensions = arcpy.Parameter(
            displayName="Maintain input raster dimensions?",
            name="maintain_dimensions",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        maintain_dimensions.value = 'False'

        params = [i, polygons, output, maintain_dimensions]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        polygons = parameters[1].valueAsText
        if polygons is not None:
            desc = arcpy.Describe(polygons)
            polygons = desc.catalogPath
        output = parameters[2].valueAsText
        maintain_dimensions = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.clip_raster_to_polygon(i=i, polygons=polygons, output=output, maintain_dimensions=maintain_dimensions)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Closing(object):
    def __init__(self):
        self.label = "Closing"
        self.description = "A closing is a mathematical morphology operation involving an erosion (min filter) of a dilation (max filter) set."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        params = [i, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.closing(i=i, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Clump(object):
    def __init__(self):
        self.label = "Clump"
        self.description = "Groups cells that form discrete areas, assigning them unique identifiers."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        diag = arcpy.Parameter(
            displayName="Include diagonal connections?",
            name="diag",
            datatype="GPBoolean",
            parameterType="Required",
            direction="Input")
        diag.value = 'True'

        zero_back = arcpy.Parameter(
            displayName="Treat zero values as background?",
            name="zero_back",
            datatype="GPBoolean",
            parameterType="Required",
            direction="Input")

        params = [i, output, diag, zero_back]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        diag = parameters[2].valueAsText
        zero_back = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.clump(i=i, output=output, diag=diag, zero_back=zero_back)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ColourizeBasedOnClass(object):
    def __init__(self):
        self.label = "Colourize Based On Class"
        self.description = "Sets the RGB values of a LiDAR point cloud based on the point classification values."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR Points",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output LiDAR Points",
            name="output",
            datatype="DEFile",
            parameterType="Optional",
            direction="Output")

        intensity_blending = arcpy.Parameter(
            displayName="Intensity Blending Amount (0-100%):",
            name="intensity_blending",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        intensity_blending.value = '50.0'

        clr_str = arcpy.Parameter(
            displayName="Colour values:",
            name="clr_str",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        use_unique_clrs_for_buildings = arcpy.Parameter(
            displayName="Use unique colours for each building?",
            name="use_unique_clrs_for_buildings",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        use_unique_clrs_for_buildings.value = 'False'

        radius = arcpy.Parameter(
            displayName="Search Distance:",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        params = [i, output, intensity_blending, clr_str, use_unique_clrs_for_buildings, radius]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        intensity_blending = parameters[2].valueAsText
        clr_str = parameters[3].valueAsText
        use_unique_clrs_for_buildings = parameters[4].valueAsText
        radius = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.colourize_based_on_class(i=i, output=output, intensity_blending=intensity_blending, clr_str=clr_str, use_unique_clrs_for_buildings=use_unique_clrs_for_buildings, radius=radius)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ColourizeBasedOnPointReturns(object):
    def __init__(self):
        self.label = "Colourize Based On Point Returns"
        self.description = "Sets the RGB values of a LiDAR point cloud based on the point returns."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR Points",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output LiDAR Points",
            name="output",
            datatype="DEFile",
            parameterType="Optional",
            direction="Output")

        intensity_blending = arcpy.Parameter(
            displayName="Intensity Blending Amount (0-100%):",
            name="intensity_blending",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        intensity_blending.value = '50.0'

        only = arcpy.Parameter(
            displayName="Only Return Colour",
            name="only",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        only.value = '(230,214,170)'

        first = arcpy.Parameter(
            displayName="First Return Colour",
            name="first",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        first.value = '(0,140,0)'

        intermediate = arcpy.Parameter(
            displayName="Intermediate Return Colour",
            name="intermediate",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        intermediate.value = '(255,0,255)'

        last = arcpy.Parameter(
            displayName="Last Return Colour",
            name="last",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        last.value = '(0,0,255)'

        params = [i, output, intensity_blending, only, first, intermediate, last]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        intensity_blending = parameters[2].valueAsText
        only = parameters[3].valueAsText
        first = parameters[4].valueAsText
        intermediate = parameters[5].valueAsText
        last = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.colourize_based_on_point_returns(i=i, output=output, intensity_blending=intensity_blending, only=only, first=first, intermediate=intermediate, last=last)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CompactnessRatio(object):
    def __init__(self):
        self.label = "Compactness Ratio"
        self.description = "Calculates the compactness ratio (A/P), a measure of shape complexity, for vector polygons."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.compactness_ratio(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ConditionalEvaluation(object):
    def __init__(self):
        self.label = "Conditional Evaluation"
        self.description = "Performs a conditional evaluation (if-then-else) operation on a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        statement = arcpy.Parameter(
            displayName="Conditional Statement e.g. value > 35.0:",
            name="statement",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        true = arcpy.Parameter(
            displayName="Value Where TRUE (Raster File Or Constant Value)",
            name="true",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Optional",
            direction="Input")

        false = arcpy.Parameter(
            displayName="Value Where FALSE (Raster File Or Constant Value)",
            name="false",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Optional",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, statement, true, false, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        statement = parameters[1].valueAsText
        true = parameters[2].valueAsText
        if true is not None:
            try:
                true = str(float(true))
            except:
                desc = arcpy.Describe(true)
                true = desc.catalogPath
        false = parameters[3].valueAsText
        if false is not None:
            try:
                false = str(float(false))
            except:
                desc = arcpy.Describe(false)
                false = desc.catalogPath
        output = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.conditional_evaluation(i=i, statement=statement, true=true, false=false, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ConditionedLatinHypercube(object):
    def __init__(self):
        self.label = "Conditioned Latin Hypercube"
        self.description = "Implements conditioned Latin Hypercube sampling."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Raster",
            name="inputs",
            datatype=["DERasterDataset"],
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output shapefile",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        samples = arcpy.Parameter(
            displayName="Number of sample sites",
            name="samples",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        samples.value = '500'

        iterations = arcpy.Parameter(
            displayName="Number of resampling iterations",
            name="iterations",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        iterations.value = '25000'

        seed = arcpy.Parameter(
            displayName="RNG seed",
            name="seed",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")

        prob = arcpy.Parameter(
            displayName="Random resample probability",
            name="prob",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        prob.value = '0.5'

        threshold = arcpy.Parameter(
            displayName="Objective function threshold.",
            name="threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        temp = arcpy.Parameter(
            displayName="Initial annealing temperature",
            name="temp",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        temp.value = '1.0'

        temp_decay = arcpy.Parameter(
            displayName="Temperature decay factor",
            name="temp_decay",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        temp_decay.value = '0.05'

        cycle = arcpy.Parameter(
            displayName="Annealing cycle duration",
            name="cycle",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        cycle.value = '10'

        average = arcpy.Parameter(
            displayName="Average the continuous Obj. Func.",
            name="average",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        average.value = 'False'

        params = [inputs, output, samples, iterations, seed, prob, threshold, temp, temp_decay, cycle, average]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        samples = parameters[2].valueAsText
        iterations = parameters[3].valueAsText
        seed = parameters[4].valueAsText
        prob = parameters[5].valueAsText
        threshold = parameters[6].valueAsText
        temp = parameters[7].valueAsText
        temp_decay = parameters[8].valueAsText
        cycle = parameters[9].valueAsText
        average = parameters[10].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.conditioned_latin_hypercube(inputs=inputs, output=output, samples=samples, iterations=iterations, seed=seed, prob=prob, threshold=threshold, temp=temp, temp_decay=temp_decay, cycle=cycle, average=average)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ConservativeSmoothingFilter(object):
    def __init__(self):
        self.label = "Conservative Smoothing Filter"
        self.description = "Performs a conservative-smoothing filter on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '3'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '3'

        params = [i, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.conservative_smoothing_filter(i=i, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ConstructVectorTin(object):
    def __init__(self):
        self.label = "Construct Vector Tin"
        self.description = "Creates a vector triangular irregular network (TIN) for a set of vector points."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        field = arcpy.Parameter(
            displayName="Field Name",
            name="field",
            datatype="Field",
            parameterType="Optional",
            direction="Input")
        field.parameterDependencies = [i.name]

        use_z = arcpy.Parameter(
            displayName="Use Shapefile 'z' values?",
            name="use_z",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        use_z.value = 'False'

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        max_triangle_edge_length = arcpy.Parameter(
            displayName="Maximum Triangle Edge Length (optional)",
            name="max_triangle_edge_length",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [i, field, use_z, output, max_triangle_edge_length]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        use_z = parameters[2].valueAsText
        output = parameters[3].valueAsText
        max_triangle_edge_length = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.construct_vector_tin(i=i, field=field, use_z=use_z, output=output, max_triangle_edge_length=max_triangle_edge_length)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ContoursFromPoints(object):
    def __init__(self):
        self.label = "Contours From Points"
        self.description = "Creates a contour coverage from a set of input points."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        field = arcpy.Parameter(
            displayName="Field Name",
            name="field",
            datatype="Field",
            parameterType="Optional",
            direction="Input")
        field.parameterDependencies = [i.name]

        use_z = arcpy.Parameter(
            displayName="Use Shapefile 'z' values?",
            name="use_z",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        use_z.value = 'False'

        output = arcpy.Parameter(
            displayName="Output Vector Lines File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        max_triangle_edge_length = arcpy.Parameter(
            displayName="Maximum Triangle Edge Length (optional)",
            name="max_triangle_edge_length",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        interval = arcpy.Parameter(
            displayName="Contour Interval",
            name="interval",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        interval.value = '10.0'

        base = arcpy.Parameter(
            displayName="Base Contour",
            name="base",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        base.value = '0.0'

        smooth = arcpy.Parameter(
            displayName="Smoothing Filter Size",
            name="smooth",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        smooth.value = '5'

        params = [i, field, use_z, output, max_triangle_edge_length, interval, base, smooth]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        use_z = parameters[2].valueAsText
        output = parameters[3].valueAsText
        max_triangle_edge_length = parameters[4].valueAsText
        interval = parameters[5].valueAsText
        base = parameters[6].valueAsText
        smooth = parameters[7].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.contours_from_points(i=i, field=field, use_z=use_z, output=output, max_triangle_edge_length=max_triangle_edge_length, interval=interval, base=base, smooth=smooth)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ContoursFromRaster(object):
    def __init__(self):
        self.label = "Contours From Raster"
        self.description = "Derives a vector contour coverage from a raster surface."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster Surface File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Contour File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        interval = arcpy.Parameter(
            displayName="Contour Interval",
            name="interval",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        interval.value = '10.0'

        base = arcpy.Parameter(
            displayName="Base Contour",
            name="base",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        base.value = '0.0'

        smooth = arcpy.Parameter(
            displayName="Smoothing Filter Size",
            name="smooth",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        smooth.value = '9'

        tolerance = arcpy.Parameter(
            displayName="Tolerance",
            name="tolerance",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        tolerance.value = '10.0'

        params = [i, output, interval, base, smooth, tolerance]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        interval = parameters[2].valueAsText
        base = parameters[3].valueAsText
        smooth = parameters[4].valueAsText
        tolerance = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.contours_from_raster(i=i, output=output, interval=interval, base=base, smooth=smooth, tolerance=tolerance)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ConvertNodataToZero(object):
    def __init__(self):
        self.label = "Convert Nodata To Zero"
        self.description = "Converts nodata values in a raster to zero."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.convert_nodata_to_zero(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ConvertRasterFormat(object):
    def __init__(self):
        self.label = "Convert Raster Format"
        self.description = "Converts raster data from one format to another."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.convert_raster_format(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CornerDetection(object):
    def __init__(self):
        self.label = "Corner Detection"
        self.description = "Identifies corner patterns in boolean images using hit-and-miss pattern matching."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.corner_detection(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CorrectVignetting(object):
    def __init__(self):
        self.label = "Correct Vignetting"
        self.description = "Corrects the darkening of images towards corners."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        pp = arcpy.Parameter(
            displayName="Input Principal Point File",
            name="pp",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        pp.filter.list = ["Point"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        focal_length = arcpy.Parameter(
            displayName="Camera Focal Length (mm)",
            name="focal_length",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        focal_length.value = '304.8'

        image_width = arcpy.Parameter(
            displayName="Distance Between Left-Right Edges (mm)",
            name="image_width",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        image_width.value = '228.6'

        n = arcpy.Parameter(
            displayName="n Parameter",
            name="n",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        n.value = '4.0'

        params = [i, pp, output, focal_length, image_width, n]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        pp = parameters[1].valueAsText
        if pp is not None:
            desc = arcpy.Describe(pp)
            pp = desc.catalogPath
        output = parameters[2].valueAsText
        focal_length = parameters[3].valueAsText
        image_width = parameters[4].valueAsText
        n = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.correct_vignetting(i=i, pp=pp, output=output, focal_length=focal_length, image_width=image_width, n=n)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Cos(object):
    def __init__(self):
        self.label = "Cos"
        self.description = "Returns the cosine (cos) of each values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.cos(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Cosh(object):
    def __init__(self):
        self.label = "Cosh"
        self.description = "Returns the hyperbolic cosine (cosh) of each values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.cosh(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CostAllocation(object):
    def __init__(self):
        self.label = "Cost Allocation"
        self.description = "Identifies the source cell to which each grid cell is connected by a least-cost pathway in a cost-distance analysis."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        source = arcpy.Parameter(
            displayName="Input Source File",
            name="source",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        backlink = arcpy.Parameter(
            displayName="Input Backlink File",
            name="backlink",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [source, backlink, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        source = parameters[0].valueAsText
        if source is not None:
            desc = arcpy.Describe(source)
            source = desc.catalogPath
        backlink = parameters[1].valueAsText
        if backlink is not None:
            desc = arcpy.Describe(backlink)
            backlink = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.cost_allocation(source=source, backlink=backlink, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CostDistance(object):
    def __init__(self):
        self.label = "Cost Distance"
        self.description = "Performs cost-distance accumulation on a cost surface and a group of source cells."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        source = arcpy.Parameter(
            displayName="Input Source File",
            name="source",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        cost = arcpy.Parameter(
            displayName="Input Cost (Friction) File",
            name="cost",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        out_accum = arcpy.Parameter(
            displayName="Output Cost Accumulation File",
            name="out_accum",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_accum.filter.list = ["tif"]

        out_backlink = arcpy.Parameter(
            displayName="Output Backlink File",
            name="out_backlink",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_backlink.filter.list = ["tif"]

        params = [source, cost, out_accum, out_backlink]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        source = parameters[0].valueAsText
        if source is not None:
            desc = arcpy.Describe(source)
            source = desc.catalogPath
        cost = parameters[1].valueAsText
        if cost is not None:
            desc = arcpy.Describe(cost)
            cost = desc.catalogPath
        out_accum = parameters[2].valueAsText
        out_backlink = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.cost_distance(source=source, cost=cost, out_accum=out_accum, out_backlink=out_backlink)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CostPathway(object):
    def __init__(self):
        self.label = "Cost Pathway"
        self.description = "Performs cost-distance pathway analysis using a series of destination grid cells."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        destination = arcpy.Parameter(
            displayName="Input Destination File",
            name="destination",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        backlink = arcpy.Parameter(
            displayName="Input Backlink File",
            name="backlink",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        zero_background = arcpy.Parameter(
            displayName="Treat zero values as background?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Required",
            direction="Input")

        params = [destination, backlink, output, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        destination = parameters[0].valueAsText
        if destination is not None:
            desc = arcpy.Describe(destination)
            destination = desc.catalogPath
        backlink = parameters[1].valueAsText
        if backlink is not None:
            desc = arcpy.Describe(backlink)
            backlink = desc.catalogPath
        output = parameters[2].valueAsText
        zero_background = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.cost_pathway(destination=destination, backlink=backlink, output=output, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CountIf(object):
    def __init__(self):
        self.label = "Count If"
        self.description = "Counts the number of occurrences of a specified value in a cell-stack of rasters."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        value = arcpy.Parameter(
            displayName="Value",
            name="value",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        params = [inputs, output, value]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        value = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.count_if(inputs=inputs, output=output, value=value)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CreateColourComposite(object):
    def __init__(self):
        self.label = "Create Colour Composite"
        self.description = "Creates a colour-composite image from three bands of multispectral imagery."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        red = arcpy.Parameter(
            displayName="Input Red Band Image File",
            name="red",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        green = arcpy.Parameter(
            displayName="Input Green Band Image File",
            name="green",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        blue = arcpy.Parameter(
            displayName="Input Blue Band Image File",
            name="blue",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        opacity = arcpy.Parameter(
            displayName="Input Opacity Band Image File (Optional)",
            name="opacity",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Colour Composite File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        enhance = arcpy.Parameter(
            displayName="Perform balance contrast enhancement?",
            name="enhance",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        enhance.value = 'True'

        zeros = arcpy.Parameter(
            displayName="Treat zeros as nodata?",
            name="zeros",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        zeros.value = 'False'

        params = [red, green, blue, opacity, output, enhance, zeros]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        red = parameters[0].valueAsText
        if red is not None:
            desc = arcpy.Describe(red)
            red = desc.catalogPath
        green = parameters[1].valueAsText
        if green is not None:
            desc = arcpy.Describe(green)
            green = desc.catalogPath
        blue = parameters[2].valueAsText
        if blue is not None:
            desc = arcpy.Describe(blue)
            blue = desc.catalogPath
        opacity = parameters[3].valueAsText
        if opacity is not None:
            desc = arcpy.Describe(opacity)
            opacity = desc.catalogPath
        output = parameters[4].valueAsText
        enhance = parameters[5].valueAsText
        zeros = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.create_colour_composite(red=red, green=green, blue=blue, opacity=opacity, output=output, enhance=enhance, zeros=zeros)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CreateHexagonalVectorGrid(object):
    def __init__(self):
        self.label = "Create Hexagonal Vector Grid"
        self.description = "Creates a hexagonal vector grid."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        input = arcpy.Parameter(
            displayName="Input Base File",
            name="input",
            datatype=["DERasterDataset", "DEShapefile"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        width = arcpy.Parameter(
            displayName="Hexagon Width",
            name="width",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        orientation = arcpy.Parameter(
            displayName="Grid Orientation",
            name="orientation",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        orientation.filter.type = "ValueList"
        orientation.filter.list = ['horizontal', 'vertical']
        orientation.value = 'horizontal'

        params = [input, output, width, orientation]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        width = parameters[2].valueAsText
        orientation = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.create_hexagonal_vector_grid(i=i, output=output, width=width, orientation=orientation)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CreatePlane(object):
    def __init__(self):
        self.label = "Create Plane"
        self.description = "Creates a raster image based on the equation for a simple plane."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        base = arcpy.Parameter(
            displayName="Input Base File",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        gradient = arcpy.Parameter(
            displayName="Gradient",
            name="gradient",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        gradient.value = '15.0'

        aspect = arcpy.Parameter(
            displayName="Aspect",
            name="aspect",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        aspect.value = '90.0'

        constant = arcpy.Parameter(
            displayName="Constant",
            name="constant",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        constant.value = '0.0'

        params = [base, output, gradient, aspect, constant]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        base = parameters[0].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        output = parameters[1].valueAsText
        gradient = parameters[2].valueAsText
        aspect = parameters[3].valueAsText
        constant = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.create_plane(base=base, output=output, gradient=gradient, aspect=aspect, constant=constant)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CreateRectangularVectorGrid(object):
    def __init__(self):
        self.label = "Create Rectangular Vector Grid"
        self.description = "Creates a rectangular vector grid."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        input = arcpy.Parameter(
            displayName="Input Base File",
            name="input",
            datatype=["DERasterDataset", "DEShapefile"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        width = arcpy.Parameter(
            displayName="Grid Cell Width",
            name="width",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        height = arcpy.Parameter(
            displayName="Grid Cell Height",
            name="height",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        xorig = arcpy.Parameter(
            displayName="Grid origin x-coordinate",
            name="xorig",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        xorig.value = '0'

        yorig = arcpy.Parameter(
            displayName="Grid origin y-coordinate",
            name="yorig",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        yorig.value = '0'

        params = [input, output, width, height, xorig, yorig]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        width = parameters[2].valueAsText
        height = parameters[3].valueAsText
        xorig = parameters[4].valueAsText
        yorig = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.create_rectangular_vector_grid(i=i, output=output, width=width, height=height, xorig=xorig, yorig=yorig)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CrispnessIndex(object):
    def __init__(self):
        self.label = "Crispness Index"
        self.description = "Calculates the Crispness Index, which is used to quantify how crisp (or conversely how fuzzy) a probability image is."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.crispness_index(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CrossTabulation(object):
    def __init__(self):
        self.label = "Cross Tabulation"
        self.description = "Performs a cross-tabulation on two categorical images."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File 1",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File 2",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.cross_tabulation(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CsvPointsToVector(object):
    def __init__(self):
        self.label = "Csv Points To Vector"
        self.description = "Converts a CSV text file to vector points."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input CSV File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["csv"]

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        xfield = arcpy.Parameter(
            displayName="X Field Number (zero-based)",
            name="xfield",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        xfield.value = '0'

        yfield = arcpy.Parameter(
            displayName="Y Field Number (zero-based)",
            name="yfield",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        yfield.value = '1'

        epsg = arcpy.Parameter(
            displayName="EPSG Projection",
            name="epsg",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")

        params = [i, output, xfield, yfield, epsg]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        xfield = parameters[2].valueAsText
        yfield = parameters[3].valueAsText
        epsg = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.csv_points_to_vector(i=i, output=output, xfield=xfield, yfield=yfield, epsg=epsg)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class CumulativeDistribution(object):
    def __init__(self):
        self.label = "Cumulative Distribution"
        self.description = "Converts a raster image to its cumulative distribution function."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.cumulative_distribution(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Curvedness(object):
    def __init__(self):
        self.label = "Curvedness"
        self.description = "This tool calculates curvedness from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input Raster DEM",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster Image",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z-factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        zfactor.value = '1.0'

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.curvedness(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class D8FlowAccumulation(object):
    def __init__(self):
        self.label = "D8 Flow Accumulation"
        self.description = "Calculates a D8 flow accumulation raster from an input DEM or flow pointer."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input DEM or D8 Pointer File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        out_type = arcpy.Parameter(
            displayName="Output Type",
            name="out_type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        out_type.filter.type = "ValueList"
        out_type.filter.list = ['cells', 'catchment area', 'specific contributing area']
        out_type.value = 'cells'

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        clip = arcpy.Parameter(
            displayName="Clip the upper tail by 1%?",
            name="clip",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        pntr = arcpy.Parameter(
            displayName="Is the input raster a D8 flow pointer?",
            name="pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        esri_pntr = arcpy.Parameter(
            displayName="If a pointer is input, does it use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [i, output, out_type, log, clip, pntr, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        out_type = parameters[2].valueAsText
        log = parameters[3].valueAsText
        clip = parameters[4].valueAsText
        pntr = parameters[5].valueAsText
        esri_pntr = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.d8_flow_accumulation(i=i, output=output, out_type=out_type, log=log, clip=clip, pntr=pntr, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class D8MassFlux(object):
    def __init__(self):
        self.label = "D8 Mass Flux"
        self.description = "Performs a D8 mass flux calculation."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        loading = arcpy.Parameter(
            displayName="Input Loading File",
            name="loading",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        efficiency = arcpy.Parameter(
            displayName="Input Efficiency File",
            name="efficiency",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        absorption = arcpy.Parameter(
            displayName="Input Absorption File",
            name="absorption",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, loading, efficiency, absorption, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        loading = parameters[1].valueAsText
        if loading is not None:
            desc = arcpy.Describe(loading)
            loading = desc.catalogPath
        efficiency = parameters[2].valueAsText
        if efficiency is not None:
            desc = arcpy.Describe(efficiency)
            efficiency = desc.catalogPath
        absorption = parameters[3].valueAsText
        if absorption is not None:
            desc = arcpy.Describe(absorption)
            absorption = desc.catalogPath
        output = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.d8_mass_flux(dem=dem, loading=loading, efficiency=efficiency, absorption=absorption, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class D8Pointer(object):
    def __init__(self):
        self.label = "D8 Pointer"
        self.description = "Calculates a D8 flow pointer raster from an input DEM."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Should the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [dem, output, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        esri_pntr = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.d8_pointer(dem=dem, output=output, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DInfFlowAccumulation(object):
    def __init__(self):
        self.label = "D Inf Flow Accumulation"
        self.description = "Calculates a D-infinity flow accumulation raster from an input DEM."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input DEM or D-inf Pointer File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        out_type = arcpy.Parameter(
            displayName="Output Type",
            name="out_type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        out_type.filter.type = "ValueList"
        out_type.filter.list = ['Cells', 'Specific Contributing Area', 'Catchment Area']
        out_type.value = 'Specific Contributing Area'

        threshold = arcpy.Parameter(
            displayName="Convergence Threshold (grid cells; blank for none)",
            name="threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        clip = arcpy.Parameter(
            displayName="Clip the upper tail by 1%?",
            name="clip",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        pntr = arcpy.Parameter(
            displayName="Is the input raster a D-inf flow pointer?",
            name="pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [i, output, out_type, threshold, log, clip, pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        out_type = parameters[2].valueAsText
        threshold = parameters[3].valueAsText
        log = parameters[4].valueAsText
        clip = parameters[5].valueAsText
        pntr = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.d_inf_flow_accumulation(i=i, output=output, out_type=out_type, threshold=threshold, log=log, clip=clip, pntr=pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DInfMassFlux(object):
    def __init__(self):
        self.label = "D Inf Mass Flux"
        self.description = "Performs a D-infinity mass flux calculation."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        loading = arcpy.Parameter(
            displayName="Input Loading File",
            name="loading",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        efficiency = arcpy.Parameter(
            displayName="Input Efficiency File",
            name="efficiency",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        absorption = arcpy.Parameter(
            displayName="Input Absorption File",
            name="absorption",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, loading, efficiency, absorption, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        loading = parameters[1].valueAsText
        if loading is not None:
            desc = arcpy.Describe(loading)
            loading = desc.catalogPath
        efficiency = parameters[2].valueAsText
        if efficiency is not None:
            desc = arcpy.Describe(efficiency)
            efficiency = desc.catalogPath
        absorption = parameters[3].valueAsText
        if absorption is not None:
            desc = arcpy.Describe(absorption)
            absorption = desc.catalogPath
        output = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.d_inf_mass_flux(dem=dem, loading=loading, efficiency=efficiency, absorption=absorption, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DInfPointer(object):
    def __init__(self):
        self.label = "D Inf Pointer"
        self.description = "Calculates a D-infinity flow pointer (flow direction) raster from an input DEM."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.d_inf_pointer(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Dbscan(object):
    def __init__(self):
        self.label = "Dbscan"
        self.description = "Performs a DBSCAN-based unsupervised clustering operation."
        self.category = "Machine Learning"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Rasters",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        scaling = arcpy.Parameter(
            displayName="Scaling Method",
            name="scaling",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        scaling.filter.type = "ValueList"
        scaling.filter.list = ['None', 'Normalize', 'Standardize']
        scaling.value = 'Normalize'

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        search_dist = arcpy.Parameter(
            displayName="Search distance",
            name="search_dist",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        search_dist.value = '0.01'

        min_points = arcpy.Parameter(
            displayName="Minimum Points",
            name="min_points",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_points.value = '5'

        params = [inputs, scaling, output, search_dist, min_points]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        scaling = parameters[1].valueAsText
        output = parameters[2].valueAsText
        search_dist = parameters[3].valueAsText
        min_points = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.dbscan(inputs=inputs, scaling=scaling, output=output, search_dist=search_dist, min_points=min_points)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Decrement(object):
    def __init__(self):
        self.label = "Decrement"
        self.description = "Decreases the values of each grid cell in an input raster by 1.0 (see also InPlaceSubtract)."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.decrement(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DemVoidFilling(object):
    def __init__(self):
        self.label = "Dem Void Filling"
        self.description = "This tool can be used to fill the void areas of a DEM using another fill DEM data set."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        fill = arcpy.Parameter(
            displayName="Input Fill DEM",
            name="fill",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output DEM",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        mean_plane_dist = arcpy.Parameter(
            displayName="Mean-Plane Distance (in grid cells)",
            name="mean_plane_dist",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        mean_plane_dist.value = '20'

        edge_treatment = arcpy.Parameter(
            displayName="Void-Edge Treatment",
            name="edge_treatment",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        edge_treatment.filter.type = "ValueList"
        edge_treatment.filter.list = ['use DEM', 'use fill', 'average']
        edge_treatment.value = 'use DEM'

        weight_value = arcpy.Parameter(
            displayName="Interpolation Weight",
            name="weight_value",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        weight_value.value = '2.0'

        params = [dem, fill, output, mean_plane_dist, edge_treatment, weight_value]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        fill = parameters[1].valueAsText
        if fill is not None:
            desc = arcpy.Describe(fill)
            fill = desc.catalogPath
        output = parameters[2].valueAsText
        mean_plane_dist = parameters[3].valueAsText
        edge_treatment = parameters[4].valueAsText
        weight_value = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.dem_void_filling(dem=dem, fill=fill, output=output, mean_plane_dist=mean_plane_dist, edge_treatment=edge_treatment, weight_value=weight_value)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DepthInSink(object):
    def __init__(self):
        self.label = "Depth In Sink"
        self.description = "Measures the depth of sinks (depressions) in a DEM."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        zero_background = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.depth_in_sink(dem=dem, output=output, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DepthToWater(object):
    def __init__(self):
        self.label = "Depth To Water"
        self.description = "This tool calculates cartographic depth-to-water (DTW) index."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input Raster DEM",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams Vector",
            name="streams",
            datatype="GPFeatureLayer",
            parameterType="Optional",
            direction="Input")
        streams.filter.list = ["Polyline"]

        lakes = arcpy.Parameter(
            displayName="Input Lakes Vector",
            name="lakes",
            datatype="GPFeatureLayer",
            parameterType="Optional",
            direction="Input")
        lakes.filter.list = ["Polygon"]

        output = arcpy.Parameter(
            displayName="Output Raster Image",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, streams, lakes, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        lakes = parameters[2].valueAsText
        if lakes is not None:
            desc = arcpy.Describe(lakes)
            lakes = desc.catalogPath
        output = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.depth_to_water(dem=dem, streams=streams, lakes=lakes, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DevFromMeanElev(object):
    def __init__(self):
        self.label = "Dev From Mean Elev"
        self.description = "Calculates deviation from mean elevation."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        params = [dem, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.dev_from_mean_elev(dem=dem, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DiffFromMeanElev(object):
    def __init__(self):
        self.label = "Diff From Mean Elev"
        self.description = "Calculates difference from mean elevation (equivalent to a high-pass filter)."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        params = [dem, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.diff_from_mean_elev(dem=dem, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DiffOfGaussianFilter(object):
    def __init__(self):
        self.label = "Diff Of Gaussian Filter"
        self.description = "Performs a Difference of Gaussian (DoG) filter on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        sigma1 = arcpy.Parameter(
            displayName="Sigma 1 (pixels)",
            name="sigma1",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        sigma1.value = '2.0'

        sigma2 = arcpy.Parameter(
            displayName="Sigma 2 (pixels)",
            name="sigma2",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        sigma2.value = '4.0'

        params = [i, output, sigma1, sigma2]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        sigma1 = parameters[2].valueAsText
        sigma2 = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.diff_of_gaussian_filter(i=i, output=output, sigma1=sigma1, sigma2=sigma2)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Difference(object):
    def __init__(self):
        self.label = "Difference"
        self.description = "Outputs the features that occur in one of the two vector inputs but not both, i.e. no overlapping features."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        overlay = arcpy.Parameter(
            displayName="Input Overlay Vector File",
            name="overlay",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, overlay, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        overlay = parameters[1].valueAsText
        if overlay is not None:
            desc = arcpy.Describe(overlay)
            overlay = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.difference(i=i, overlay=overlay, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DifferenceCurvature(object):
    def __init__(self):
        self.label = "Difference Curvature"
        self.description = "This tool calculates difference curvature from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input Raster DEM",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster Image",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z-factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        zfactor.value = '1.0'

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.difference_curvature(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DirectDecorrelationStretch(object):
    def __init__(self):
        self.label = "Direct Decorrelation Stretch"
        self.description = "Performs a direct decorrelation stretch enhancement on a colour-composite image of multispectral data."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Colour Composite Image File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        k = arcpy.Parameter(
            displayName="Achromatic Factor (0-1)",
            name="k",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        k.value = '0.5'

        clip = arcpy.Parameter(
            displayName="Percent to clip the upper tail",
            name="clip",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        clip.value = '1.0'

        params = [i, output, k, clip]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        k = parameters[2].valueAsText
        clip = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.direct_decorrelation_stretch(i=i, output=output, k=k, clip=clip)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DirectionalRelief(object):
    def __init__(self):
        self.label = "Directional Relief"
        self.description = "Calculates relief for cells in an input DEM for a specified direction."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        azimuth = arcpy.Parameter(
            displayName="Azimuth",
            name="azimuth",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        azimuth.value = '0.0'

        max_dist = arcpy.Parameter(
            displayName="Maximum Search Distance",
            name="max_dist",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, azimuth, max_dist]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        azimuth = parameters[2].valueAsText
        max_dist = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.directional_relief(dem=dem, output=output, azimuth=azimuth, max_dist=max_dist)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Dissolve(object):
    def __init__(self):
        self.label = "Dissolve"
        self.description = "Removes the interior, or shared, boundaries within a vector polygon coverage."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        field = arcpy.Parameter(
            displayName="Dissolve Field Attribute",
            name="field",
            datatype="Field",
            parameterType="Optional",
            direction="Input")
        field.parameterDependencies = [i.name]

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        snap = arcpy.Parameter(
            displayName="Snap Tolerance",
            name="snap",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        snap.value = '0.0'

        params = [i, field, output, snap]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        output = parameters[2].valueAsText
        snap = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.dissolve(i=i, field=field, output=output, snap=snap)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DistanceToOutlet(object):
    def __init__(self):
        self.label = "Distance To Outlet"
        self.description = "Calculates the distance of stream grid cells to the channel network outlet cell."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [d8_pntr, streams, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        zero_background = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.distance_to_outlet(d8_pntr=d8_pntr, streams=streams, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DiversityFilter(object):
    def __init__(self):
        self.label = "Diversity Filter"
        self.description = "Assigns each cell in the output grid the number of different values in a moving window centred on each grid cell in the input raster."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        params = [i, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.diversity_filter(i=i, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Divide(object):
    def __init__(self):
        self.label = "Divide"
        self.description = "Performs a division operation on two rasters or a raster and a constant value."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input1",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            try:
                input1 = str(float(input1))
            except:
                desc = arcpy.Describe(input1)
                input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.divide(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DownslopeDistanceToStream(object):
    def __init__(self):
        self.label = "Downslope Distance To Stream"
        self.description = "Measures distance to the nearest downslope stream cell."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        dinf = arcpy.Parameter(
            displayName="Use the D-infinity flow algorithm instead of D8?",
            name="dinf",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        dinf.value = 'False'

        params = [dem, streams, output, dinf]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        dinf = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.downslope_distance_to_stream(dem=dem, streams=streams, output=output, dinf=dinf)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DownslopeFlowpathLength(object):
    def __init__(self):
        self.label = "Downslope Flowpath Length"
        self.description = "Calculates the downslope flowpath length from each cell to basin outlet."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        watersheds = arcpy.Parameter(
            displayName="Input Watersheds File (optional)",
            name="watersheds",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        weights = arcpy.Parameter(
            displayName="Input Weights File (optional)",
            name="weights",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [d8_pntr, watersheds, weights, output, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        watersheds = parameters[1].valueAsText
        if watersheds is not None:
            desc = arcpy.Describe(watersheds)
            watersheds = desc.catalogPath
        weights = parameters[2].valueAsText
        if weights is not None:
            desc = arcpy.Describe(weights)
            weights = desc.catalogPath
        output = parameters[3].valueAsText
        esri_pntr = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.downslope_flowpath_length(d8_pntr=d8_pntr, watersheds=watersheds, weights=weights, output=output, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class DownslopeIndex(object):
    def __init__(self):
        self.label = "Downslope Index"
        self.description = "Calculates the Hjerdt et al. (2004) downslope index."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        drop = arcpy.Parameter(
            displayName="Verical Drop",
            name="drop",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        drop.value = '2.0'

        out_type = arcpy.Parameter(
            displayName="Output Type",
            name="out_type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        out_type.filter.type = "ValueList"
        out_type.filter.list = ['tangent', 'degrees', 'radians', 'distance']
        out_type.value = 'tangent'

        params = [dem, output, drop, out_type]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        drop = parameters[2].valueAsText
        out_type = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.downslope_index(dem=dem, output=output, drop=drop, out_type=out_type)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class EdgeContamination(object):
    def __init__(self):
        self.label = "Edge Contamination"
        self.description = "Identifies grid cells within an input DEM that may be impacted by edge contamination for hydrological applications."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM Raster",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        flow_type = arcpy.Parameter(
            displayName="Flow Type",
            name="flow_type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        flow_type.filter.type = "ValueList"
        flow_type.filter.list = ['d8', 'mfd', 'dinf']
        flow_type.value = 'mfd'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        params = [dem, output, flow_type, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        flow_type = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.edge_contamination(dem=dem, output=output, flow_type=flow_type, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class EdgeDensity(object):
    def __init__(self):
        self.label = "Edge Density"
        self.description = "Calculates the density of edges, or breaks-in-slope within DEMs."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filter = arcpy.Parameter(
            displayName="Filter Size",
            name="filter",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filter.value = '11'

        norm_diff = arcpy.Parameter(
            displayName="Normal Difference Threshold",
            name="norm_diff",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        norm_diff.value = '5.0'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, filter, norm_diff, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        filter = parameters[2].valueAsText
        norm_diff = parameters[3].valueAsText
        zfactor = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.edge_density(dem=dem, output=output, filter=filter, norm_diff=norm_diff, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class EdgePreservingMeanFilter(object):
    def __init__(self):
        self.label = "Edge Preserving Mean Filter"
        self.description = "Performs a simple edge-preserving mean filter on an input image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filter = arcpy.Parameter(
            displayName="Filter Size",
            name="filter",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filter.value = '11'

        threshold = arcpy.Parameter(
            displayName="Value Difference Threshold",
            name="threshold",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        params = [i, output, filter, threshold]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filter = parameters[2].valueAsText
        threshold = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.edge_preserving_mean_filter(i=i, output=output, filter=filter, threshold=threshold)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class EdgeProportion(object):
    def __init__(self):
        self.label = "Edge Proportion"
        self.description = "Calculate the proportion of cells in a raster polygon that are edge cells."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        output_text = arcpy.Parameter(
            displayName="Output a text report?",
            name="output_text",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [i, output, output_text]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        output_text = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.edge_proportion(i=i, output=output, output_text=output_text)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ElevAbovePit(object):
    def __init__(self):
        self.label = "Elev Above Pit"
        self.description = "Calculate the elevation of each grid cell above the nearest downstream pit cell or grid edge cell."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.elev_above_pit(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ElevPercentile(object):
    def __init__(self):
        self.label = "Elev Percentile"
        self.description = "Calculates the elevation percentile raster from a DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        sig_digits = arcpy.Parameter(
            displayName="Number of Significant Digits",
            name="sig_digits",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        sig_digits.value = '2'

        params = [dem, output, filterx, filtery, sig_digits]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        sig_digits = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.elev_percentile(dem=dem, output=output, filterx=filterx, filtery=filtery, sig_digits=sig_digits)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ElevRelativeToMinMax(object):
    def __init__(self):
        self.label = "Elev Relative To Min Max"
        self.description = "Calculates the elevation of a location relative to the minimum and maximum elevations in a DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.elev_relative_to_min_max(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ElevRelativeToWatershedMinMax(object):
    def __init__(self):
        self.label = "Elev Relative To Watershed Min Max"
        self.description = "Calculates the elevation of a location relative to the minimum and maximum elevations in a watershed."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        watersheds = arcpy.Parameter(
            displayName="Input Watersheds File",
            name="watersheds",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, watersheds, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        watersheds = parameters[1].valueAsText
        if watersheds is not None:
            desc = arcpy.Describe(watersheds)
            watersheds = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.elev_relative_to_watershed_min_max(dem=dem, watersheds=watersheds, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ElevationAboveStream(object):
    def __init__(self):
        self.label = "Elevation Above Stream"
        self.description = "Calculates the elevation of cells above the nearest downslope stream cell."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, streams, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.elevation_above_stream(dem=dem, streams=streams, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ElevationAboveStreamEuclidean(object):
    def __init__(self):
        self.label = "Elevation Above Stream Euclidean"
        self.description = "Calculates the elevation of cells above the nearest (Euclidean distance) stream cell."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, streams, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.elevation_above_stream_euclidean(dem=dem, streams=streams, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class EliminateCoincidentPoints(object):
    def __init__(self):
        self.label = "Eliminate Coincident Points"
        self.description = "Removes any coincident, or nearly coincident, points from a vector points file."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        output = arcpy.Parameter(
            displayName="Output Points File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        tolerance = arcpy.Parameter(
            displayName="Distance Tolerance",
            name="tolerance",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        params = [i, output, tolerance]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        tolerance = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.eliminate_coincident_points(i=i, output=output, tolerance=tolerance)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ElongationRatio(object):
    def __init__(self):
        self.label = "Elongation Ratio"
        self.description = "Calculates the elongation ratio for vector polygons."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.elongation_ratio(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class EmbankmentMapping(object):
    def __init__(self):
        self.label = "Embankment Mapping"
        self.description = "Maps and/or removes road embankments from an input fine-resolution DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        road_vec = arcpy.Parameter(
            displayName="Input Vector Transportation Line File",
            name="road_vec",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        road_vec.filter.list = ["Polyline"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        search_dist = arcpy.Parameter(
            displayName="Search Distance (in map units)",
            name="search_dist",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        search_dist.value = '2.5'

        min_road_width = arcpy.Parameter(
            displayName="Minimum Road Width (in map units)",
            name="min_road_width",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        min_road_width.value = '6.0'

        typical_width = arcpy.Parameter(
            displayName="Typical Embankment Width (in map units)",
            name="typical_width",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        typical_width.value = '30.0'

        max_height = arcpy.Parameter(
            displayName="Typical Embankment Max Height (in map units)",
            name="max_height",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        max_height.value = '2.0'

        max_width = arcpy.Parameter(
            displayName="Embankment Max Width (in map units)",
            name="max_width",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        max_width.value = '60.0'

        max_increment = arcpy.Parameter(
            displayName="Max Upwards Increment (in elevation units)",
            name="max_increment",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        max_increment.value = '0.05'

        spillout_slope = arcpy.Parameter(
            displayName="Spillout Slope (in map units)",
            name="spillout_slope",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        spillout_slope.value = '4.0'

        remove_embankments = arcpy.Parameter(
            displayName="Remove mapped embankments?",
            name="remove_embankments",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        remove_embankments.value = 'False'

        params = [dem, road_vec, output, search_dist, min_road_width, typical_width, max_height, max_width, max_increment, spillout_slope, remove_embankments]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        road_vec = parameters[1].valueAsText
        if road_vec is not None:
            desc = arcpy.Describe(road_vec)
            road_vec = desc.catalogPath
        output = parameters[2].valueAsText
        search_dist = parameters[3].valueAsText
        min_road_width = parameters[4].valueAsText
        typical_width = parameters[5].valueAsText
        max_height = parameters[6].valueAsText
        max_width = parameters[7].valueAsText
        max_increment = parameters[8].valueAsText
        spillout_slope = parameters[9].valueAsText
        remove_embankments = parameters[10].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.embankment_mapping(dem=dem, road_vec=road_vec, output=output, search_dist=search_dist, min_road_width=min_road_width, typical_width=typical_width, max_height=max_height, max_width=max_width, max_increment=max_increment, spillout_slope=spillout_slope, remove_embankments=remove_embankments)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class EmbossFilter(object):
    def __init__(self):
        self.label = "Emboss Filter"
        self.description = "Performs an emboss filter on an image, similar to a hillshade operation."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        direction = arcpy.Parameter(
            displayName="Direction",
            name="direction",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        direction.filter.type = "ValueList"
        direction.filter.list = ['n', 's', 'e', 'w', 'ne', 'se', 'nw', 'sw']
        direction.value = 'n'

        clip = arcpy.Parameter(
            displayName="Percent to clip the distribution tails",
            name="clip",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        clip.value = '0.0'

        params = [i, output, direction, clip]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        direction = parameters[2].valueAsText
        clip = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.emboss_filter(i=i, output=output, direction=direction, clip=clip)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class EqualTo(object):
    def __init__(self):
        self.label = "Equal To"
        self.description = "Performs a equal-to comparison operation on two rasters or a raster and a constant value."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input1",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            try:
                input1 = str(float(input1))
            except:
                desc = arcpy.Describe(input1)
                input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.equal_to(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Erase(object):
    def __init__(self):
        self.label = "Erase"
        self.description = "Removes all the features, or parts of features, that overlap with the features of the erase vector polygon."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        erase = arcpy.Parameter(
            displayName="Input Erase Polygon Vector File",
            name="erase",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        erase.filter.list = ["Polygon"]

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, erase, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        erase = parameters[1].valueAsText
        if erase is not None:
            desc = arcpy.Describe(erase)
            erase = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.erase(i=i, erase=erase, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ErasePolygonFromLidar(object):
    def __init__(self):
        self.label = "Erase Polygon From Lidar"
        self.description = "Erases (cuts out) a vector polygon or polygons from a LiDAR point cloud."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        polygons = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="polygons",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        polygons.filter.list = ["Polygon"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        params = [i, polygons, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        polygons = parameters[1].valueAsText
        if polygons is not None:
            desc = arcpy.Describe(polygons)
            polygons = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.erase_polygon_from_lidar(i=i, polygons=polygons, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ErasePolygonFromRaster(object):
    def __init__(self):
        self.label = "Erase Polygon From Raster"
        self.description = "Erases (cuts out) a vector polygon from a raster."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        polygons = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="polygons",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        polygons.filter.list = ["Polygon"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, polygons, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        polygons = parameters[1].valueAsText
        if polygons is not None:
            desc = arcpy.Describe(polygons)
            polygons = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.erase_polygon_from_raster(i=i, polygons=polygons, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class EuclideanAllocation(object):
    def __init__(self):
        self.label = "Euclidean Allocation"
        self.description = "Assigns grid cells in the output raster the value of the nearest target cell in the input image, measured by the Shih and Wu (2004) Euclidean distance transform."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.euclidean_allocation(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class EuclideanDistance(object):
    def __init__(self):
        self.label = "Euclidean Distance"
        self.description = "Calculates the Shih and Wu (2004) Euclidean distance transform."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.euclidean_distance(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class EvaluateTrainingSites(object):
    def __init__(self):
        self.label = "Evaluate Training Sites"
        self.description = "This tool can be used to inspect the overlap in spectral signatures of training sites for various classes."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Band Images",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        polys = arcpy.Parameter(
            displayName="Input Training Polygons",
            name="polys",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        polys.filter.list = ["Polygon"]

        field = arcpy.Parameter(
            displayName="Class Name Field",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [polys.name]

        output = arcpy.Parameter(
            displayName="Output File (*.html)",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [inputs, polys, field, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        polys = parameters[1].valueAsText
        if polys is not None:
            desc = arcpy.Describe(polys)
            polys = desc.catalogPath
        field = parameters[2].valueAsText
        output = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.evaluate_training_sites(inputs=inputs, polys=polys, field=field, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Exp(object):
    def __init__(self):
        self.label = "Exp"
        self.description = "Returns the exponential (base e) of values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.exp(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Exp2(object):
    def __init__(self):
        self.label = "Exp2"
        self.description = "Returns the exponential (base 2) of values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.exp2(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ExportTableToCsv(object):
    def __init__(self):
        self.label = "Export Table To Csv"
        self.description = "Exports an attribute table to a CSV text file."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["csv"]

        headers = arcpy.Parameter(
            displayName="Export field names as file header?",
            name="headers",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        headers.value = 'True'

        params = [i, output, headers]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        headers = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.export_table_to_csv(i=i, output=output, headers=headers)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ExposureTowardsWindFlux(object):
    def __init__(self):
        self.label = "Exposure Towards Wind Flux"
        self.description = "Evaluates hydrologic connectivity within a DEM"
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM Raster",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        azimuth = arcpy.Parameter(
            displayName="Wind Azimuth (in degrees)",
            name="azimuth",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        max_dist = arcpy.Parameter(
            displayName="Maximum Search Distance",
            name="max_dist",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        params = [dem, output, azimuth, max_dist, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        azimuth = parameters[2].valueAsText
        max_dist = parameters[3].valueAsText
        zfactor = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.exposure_towards_wind_flux(dem=dem, output=output, azimuth=azimuth, max_dist=max_dist, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ExtendVectorLines(object):
    def __init__(self):
        self.label = "Extend Vector Lines"
        self.description = "Extends vector lines by a specified distance."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Lines File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polyline"]

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        dist = arcpy.Parameter(
            displayName="Extend Distance",
            name="dist",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        extend = arcpy.Parameter(
            displayName="Extend Direction",
            name="extend",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        extend.filter.type = "ValueList"
        extend.filter.list = ['both ends', 'line start', 'line end']
        extend.value = 'both ends'

        params = [i, output, dist, extend]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        dist = parameters[2].valueAsText
        extend = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.extend_vector_lines(i=i, output=output, dist=dist, extend=extend)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ExtractNodes(object):
    def __init__(self):
        self.label = "Extract Nodes"
        self.description = "Converts vector lines or polygons into vertex points."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Points File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.extract_nodes(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ExtractRasterValuesAtPoints(object):
    def __init__(self):
        self.label = "Extract Raster Values At Points"
        self.description = "Extracts the values of raster(s) at vector point locations."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        points = arcpy.Parameter(
            displayName="Input Points File",
            name="points",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        points.filter.list = ["Point"]

        out_text = arcpy.Parameter(
            displayName="Output text?",
            name="out_text",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        out_text.value = 'False'

        params = [inputs, points, out_text]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        points = parameters[1].valueAsText
        if points is not None:
            desc = arcpy.Describe(points)
            points = desc.catalogPath
        out_text = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.extract_raster_values_at_points(inputs=inputs, points=points, out_text=out_text)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ExtractStreams(object):
    def __init__(self):
        self.label = "Extract Streams"
        self.description = "Extracts stream grid cells from a flow accumulation raster."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        flow_accum = arcpy.Parameter(
            displayName="Input D8 Flow Accumulation File",
            name="flow_accum",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        threshold = arcpy.Parameter(
            displayName="Channelization Threshold",
            name="threshold",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [flow_accum, output, threshold, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        flow_accum = parameters[0].valueAsText
        if flow_accum is not None:
            desc = arcpy.Describe(flow_accum)
            flow_accum = desc.catalogPath
        output = parameters[1].valueAsText
        threshold = parameters[2].valueAsText
        zero_background = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.extract_streams(flow_accum=flow_accum, output=output, threshold=threshold, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ExtractValleys(object):
    def __init__(self):
        self.label = "Extract Valleys"
        self.description = "Identifies potential valley bottom grid cells based on local topolography alone."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        variant = arcpy.Parameter(
            displayName="Variant",
            name="variant",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        variant.filter.type = "ValueList"
        variant.filter.list = ['LQ', 'JandR', 'PandD']
        variant.value = 'LQ'

        line_thin = arcpy.Parameter(
            displayName="Perform line-thinning?",
            name="line_thin",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        line_thin.value = 'True'

        filter = arcpy.Parameter(
            displayName="Filter Size (Only For Lower Quartile)",
            name="filter",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filter.value = '5'

        params = [dem, output, variant, line_thin, filter]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        variant = parameters[2].valueAsText
        line_thin = parameters[3].valueAsText
        filter = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.extract_valleys(dem=dem, output=output, variant=variant, line_thin=line_thin, filter=filter)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Fd8FlowAccumulation(object):
    def __init__(self):
        self.label = "Fd8 Flow Accumulation"
        self.description = "Calculates an FD8 flow accumulation raster from an input DEM."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        out_type = arcpy.Parameter(
            displayName="Output Type",
            name="out_type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        out_type.filter.type = "ValueList"
        out_type.filter.list = ['cells', 'specific contributing area', 'catchment area']
        out_type.value = 'specific contributing area'

        exponent = arcpy.Parameter(
            displayName="Exponent Parameter",
            name="exponent",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        exponent.value = '1.1'

        threshold = arcpy.Parameter(
            displayName="Convergence Threshold (grid cells; blank for none)",
            name="threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        clip = arcpy.Parameter(
            displayName="Clip the upper tail by 1%?",
            name="clip",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, out_type, exponent, threshold, log, clip]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        out_type = parameters[2].valueAsText
        exponent = parameters[3].valueAsText
        threshold = parameters[4].valueAsText
        log = parameters[5].valueAsText
        clip = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.fd8_flow_accumulation(dem=dem, output=output, out_type=out_type, exponent=exponent, threshold=threshold, log=log, clip=clip)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Fd8Pointer(object):
    def __init__(self):
        self.label = "Fd8 Pointer"
        self.description = "Calculates an FD8 flow pointer raster from an input DEM."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.fd8_pointer(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FarthestChannelHead(object):
    def __init__(self):
        self.label = "Farthest Channel Head"
        self.description = "Calculates the distance to the furthest upstream channel head for each stream cell."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [d8_pntr, streams, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        zero_background = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.farthest_channel_head(d8_pntr=d8_pntr, streams=streams, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FastAlmostGaussianFilter(object):
    def __init__(self):
        self.label = "Fast Almost Gaussian Filter"
        self.description = "Performs a fast approximate Gaussian filter on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        sigma = arcpy.Parameter(
            displayName="Standard Deviation (pixels)",
            name="sigma",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        sigma.value = '1.8'

        params = [i, output, sigma]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        sigma = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.fast_almost_gaussian_filter(i=i, output=output, sigma=sigma)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FeaturePreservingSmoothing(object):
    def __init__(self):
        self.label = "Feature Preserving Smoothing"
        self.description = "Reduces short-scale variation in an input DEM using a modified Sun et al. (2007) algorithm."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filter = arcpy.Parameter(
            displayName="Filter Size",
            name="filter",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filter.value = '11'

        norm_diff = arcpy.Parameter(
            displayName="Normal Difference Threshold",
            name="norm_diff",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        norm_diff.value = '15.0'

        num_iter = arcpy.Parameter(
            displayName="Iterations",
            name="num_iter",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        num_iter.value = '3'

        max_diff = arcpy.Parameter(
            displayName="Maximum Elevation Change",
            name="max_diff",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        max_diff.value = '0.5'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, filter, norm_diff, num_iter, max_diff, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        filter = parameters[2].valueAsText
        norm_diff = parameters[3].valueAsText
        num_iter = parameters[4].valueAsText
        max_diff = parameters[5].valueAsText
        zfactor = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.feature_preserving_smoothing(dem=dem, output=output, filter=filter, norm_diff=norm_diff, num_iter=num_iter, max_diff=max_diff, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FetchAnalysis(object):
    def __init__(self):
        self.label = "Fetch Analysis"
        self.description = "Performs an analysis of fetch or upwind distance to an obstacle."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        azimuth = arcpy.Parameter(
            displayName="Azimuth (degrees)",
            name="azimuth",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        azimuth.value = '0.0'

        hgt_inc = arcpy.Parameter(
            displayName="Height Increment Value",
            name="hgt_inc",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        hgt_inc.value = '0.05'

        params = [dem, output, azimuth, hgt_inc]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        azimuth = parameters[2].valueAsText
        hgt_inc = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.fetch_analysis(dem=dem, output=output, azimuth=azimuth, hgt_inc=hgt_inc)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FillBurn(object):
    def __init__(self):
        self.label = "Fill Burn"
        self.description = "Burns streams into a DEM using the FillBurn (Saunders, 1999) method."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Vector Streams File",
            name="streams",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        streams.filter.list = ["Polyline"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, streams, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.fill_burn(dem=dem, streams=streams, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FillDepressions(object):
    def __init__(self):
        self.label = "Fill Depressions"
        self.description = "Fills all of the depressions in a DEM. Depression breaching should be preferred in most cases."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        fix_flats = arcpy.Parameter(
            displayName="Fix flat areas?",
            name="fix_flats",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        fix_flats.value = 'True'

        flat_increment = arcpy.Parameter(
            displayName="Flat increment value (z units)",
            name="flat_increment",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        max_depth = arcpy.Parameter(
            displayName="Maximum depth (z units)",
            name="max_depth",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, fix_flats, flat_increment, max_depth]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        fix_flats = parameters[2].valueAsText
        flat_increment = parameters[3].valueAsText
        max_depth = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.fill_depressions(dem=dem, output=output, fix_flats=fix_flats, flat_increment=flat_increment, max_depth=max_depth)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FillDepressionsPlanchonAndDarboux(object):
    def __init__(self):
        self.label = "Fill Depressions Planchon And Darboux"
        self.description = "Fills all of the depressions in a DEM using the Planchon and Darboux (2002) method."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        fix_flats = arcpy.Parameter(
            displayName="Fix flat areas?",
            name="fix_flats",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        fix_flats.value = 'True'

        flat_increment = arcpy.Parameter(
            displayName="Flat increment value (z units)",
            name="flat_increment",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, fix_flats, flat_increment]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        fix_flats = parameters[2].valueAsText
        flat_increment = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.fill_depressions_planchon_and_darboux(dem=dem, output=output, fix_flats=fix_flats, flat_increment=flat_increment)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FillDepressionsWangAndLiu(object):
    def __init__(self):
        self.label = "Fill Depressions Wang And Liu"
        self.description = "Fills all of the depressions in a DEM using the Wang and Liu (2006) method. Depression breaching should be preferred in most cases."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        fix_flats = arcpy.Parameter(
            displayName="Fix flat areas?",
            name="fix_flats",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        fix_flats.value = 'True'

        flat_increment = arcpy.Parameter(
            displayName="Flat increment value (z units)",
            name="flat_increment",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, fix_flats, flat_increment]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        fix_flats = parameters[2].valueAsText
        flat_increment = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.fill_depressions_wang_and_liu(dem=dem, output=output, fix_flats=fix_flats, flat_increment=flat_increment)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FillMissingData(object):
    def __init__(self):
        self.label = "Fill Missing Data"
        self.description = "Fills NoData holes in a DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filter = arcpy.Parameter(
            displayName="Filter Dimension",
            name="filter",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        filter.value = '11'

        weight = arcpy.Parameter(
            displayName="IDW Weight (Exponent) Value",
            name="weight",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        weight.value = '2.0'

        no_edges = arcpy.Parameter(
            displayName="Exclude edge-of-raster-connected NoData cells?",
            name="no_edges",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        no_edges.value = 'True'

        params = [i, output, filter, weight, no_edges]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filter = parameters[2].valueAsText
        weight = parameters[3].valueAsText
        no_edges = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.fill_missing_data(i=i, output=output, filter=filter, weight=weight, no_edges=no_edges)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FillSingleCellPits(object):
    def __init__(self):
        self.label = "Fill Single Cell Pits"
        self.description = "Raises pit cells to the elevation of their lowest neighbour."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.fill_single_cell_pits(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FilterLidar(object):
    def __init__(self):
        self.label = "Filter Lidar"
        self.description = "Filters points within a LiDAR point cloud based on point properties."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR Points",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output LiDAR Points",
            name="output",
            datatype="DEFile",
            parameterType="Optional",
            direction="Output")

        statement = arcpy.Parameter(
            displayName="Statement:",
            name="statement",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        params = [i, output, statement]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        statement = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.filter_lidar(i=i, output=output, statement=statement)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FilterLidarClasses(object):
    def __init__(self):
        self.label = "Filter Lidar Classes"
        self.description = "Removes points in a LAS file with certain specified class values."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        exclude_cls = arcpy.Parameter(
            displayName="Exclusion Classes (0-18, based on LAS spec; e.g. 7,18)",
            name="exclude_cls",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")

        params = [i, output, exclude_cls]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        exclude_cls = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.filter_lidar_classes(i=i, output=output, exclude_cls=exclude_cls)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FilterLidarScanAngles(object):
    def __init__(self):
        self.label = "Filter Lidar Scan Angles"
        self.description = "Removes points in a LAS file with scan angles greater than a threshold."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        threshold = arcpy.Parameter(
            displayName="Threshold (degrees)",
            name="threshold",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        params = [i, output, threshold]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        threshold = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.filter_lidar_scan_angles(i=i, output=output, threshold=threshold)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FilterRasterFeaturesByArea(object):
    def __init__(self):
        self.label = "Filter Raster Features By Area"
        self.description = "Removes small-area features from a raster."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        threshold = arcpy.Parameter(
            displayName="Area Threshold (grid cells)",
            name="threshold",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")

        background = arcpy.Parameter(
            displayName="Background Value",
            name="background",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        background.filter.type = "ValueList"
        background.filter.list = ['zero', 'nodata']
        background.value = 'zero'

        params = [i, output, threshold, background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        threshold = parameters[2].valueAsText
        background = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.filter_raster_features_by_area(i=i, output=output, threshold=threshold, background=background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FindFlightlineEdgePoints(object):
    def __init__(self):
        self.label = "Find Flightline Edge Points"
        self.description = "Identifies points along a flightline's edge in a LAS file."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.find_flightline_edge_points(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FindLowestOrHighestPoints(object):
    def __init__(self):
        self.label = "Find Lowest Or Highest Points"
        self.description = "Locates the lowest and/or highest valued cells in a raster."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Points File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        out_type = arcpy.Parameter(
            displayName="Output Type",
            name="out_type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        out_type.filter.type = "ValueList"
        out_type.filter.list = ['lowest', 'highest', 'both']
        out_type.value = 'lowest'

        params = [i, output, out_type]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        out_type = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.find_lowest_or_highest_points(i=i, output=output, out_type=out_type)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FindMainStem(object):
    def __init__(self):
        self.label = "Find Main Stem"
        self.description = "Finds the main stem, based on stream lengths, of each stream network."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [d8_pntr, streams, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        zero_background = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.find_main_stem(d8_pntr=d8_pntr, streams=streams, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FindNoFlowCells(object):
    def __init__(self):
        self.label = "Find No Flow Cells"
        self.description = "Finds grid cells with no downslope neighbours."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.find_no_flow_cells(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FindParallelFlow(object):
    def __init__(self):
        self.label = "Find Parallel Flow"
        self.description = "Finds areas of parallel flow in D8 flow direction rasters."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [d8_pntr, streams, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.find_parallel_flow(d8_pntr=d8_pntr, streams=streams, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FindPatchOrClassEdgeCells(object):
    def __init__(self):
        self.label = "Find Patch Or Class Edge Cells"
        self.description = "Finds all cells located on the edge of patch or class features."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.find_patch_or_class_edge_cells(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FindRidges(object):
    def __init__(self):
        self.label = "Find Ridges"
        self.description = "Identifies potential ridge and peak grid cells."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        line_thin = arcpy.Parameter(
            displayName="Perform line-thinning?",
            name="line_thin",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        line_thin.value = 'True'

        params = [dem, output, line_thin]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        line_thin = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.find_ridges(dem=dem, output=output, line_thin=line_thin)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FixDanglingArcs(object):
    def __init__(self):
        self.label = "Fix Dangling Arcs"
        self.description = "This tool fixes undershot and overshot arcs, two common topological errors, in an input vector lines file."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Lines",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polyline"]

        output = arcpy.Parameter(
            displayName="Output Lines",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        dist = arcpy.Parameter(
            displayName="Snap Distance",
            name="dist",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        params = [i, output, dist]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        dist = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.fix_dangling_arcs(i=i, output=output, dist=dist)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FlattenLakes(object):
    def __init__(self):
        self.label = "Flatten Lakes"
        self.description = "Flattens lake polygons in a raster DEM."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        lakes = arcpy.Parameter(
            displayName="Input Lakes Vector Polygon File",
            name="lakes",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        lakes.filter.list = ["Polygon"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, lakes, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        lakes = parameters[1].valueAsText
        if lakes is not None:
            desc = arcpy.Describe(lakes)
            lakes = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.flatten_lakes(dem=dem, lakes=lakes, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FlightlineOverlap(object):
    def __init__(self):
        self.label = "Flightline Overlap"
        self.description = "Reads a LiDAR (LAS) point file and outputs a raster containing the number of overlapping flight-lines in each grid cell."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        resolution = arcpy.Parameter(
            displayName="Grid Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        resolution.value = '1.0'

        params = [i, output, resolution]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        resolution = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.flightline_overlap(i=i, output=output, resolution=resolution)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FlipImage(object):
    def __init__(self):
        self.label = "Flip Image"
        self.description = "Reflects an image in the vertical or horizontal axis."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        direction = arcpy.Parameter(
            displayName="Direction",
            name="direction",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        direction.filter.type = "ValueList"
        direction.filter.list = ['vertical', 'horizontal', 'both']
        direction.value = 'vertical'

        params = [i, output, direction]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        direction = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.flip_image(i=i, output=output, direction=direction)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FloodOrder(object):
    def __init__(self):
        self.label = "Flood Order"
        self.description = "Assigns each DEM grid cell its order in the sequence of inundations that are encountered during a search starting from the edges, moving inward at increasing elevations."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.flood_order(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Floor(object):
    def __init__(self):
        self.label = "Floor"
        self.description = "Returns the largest (closest to positive infinity) value that is less than or equal to the values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.floor(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FlowAccumulationFullWorkflow(object):
    def __init__(self):
        self.label = "Flow Accumulation Full Workflow"
        self.description = "Resolves all of the depressions in a DEM, outputting a breached DEM, an aspect-aligned non-divergent flow pointer, and a flow accumulation raster."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        out_dem = arcpy.Parameter(
            displayName="Output DEM File",
            name="out_dem",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_dem.filter.list = ["tif"]

        out_pntr = arcpy.Parameter(
            displayName="Output Flow Pointer File",
            name="out_pntr",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_pntr.filter.list = ["tif"]

        out_accum = arcpy.Parameter(
            displayName="Output Flow Accumulation File",
            name="out_accum",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_accum.filter.list = ["tif"]

        out_type = arcpy.Parameter(
            displayName="Output Type",
            name="out_type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        out_type.filter.type = "ValueList"
        out_type.filter.list = ['Cells', 'Specific Contributing Area', 'Catchment Area']
        out_type.value = 'Specific Contributing Area'

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        clip = arcpy.Parameter(
            displayName="Clip the upper tail by 1%?",
            name="clip",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [dem, out_dem, out_pntr, out_accum, out_type, log, clip, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        out_dem = parameters[1].valueAsText
        out_pntr = parameters[2].valueAsText
        out_accum = parameters[3].valueAsText
        out_type = parameters[4].valueAsText
        log = parameters[5].valueAsText
        clip = parameters[6].valueAsText
        esri_pntr = parameters[7].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.flow_accumulation_full_workflow(dem=dem, out_dem=out_dem, out_pntr=out_pntr, out_accum=out_accum, out_type=out_type, log=log, clip=clip, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class FlowLengthDiff(object):
    def __init__(self):
        self.label = "Flow Length Diff"
        self.description = "Calculates the local maximum absolute difference in downslope flowpath length, useful in mapping drainage divides and ridges."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [d8_pntr, output, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        output = parameters[1].valueAsText
        esri_pntr = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.flow_length_diff(d8_pntr=d8_pntr, output=output, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class GammaCorrection(object):
    def __init__(self):
        self.label = "Gamma Correction"
        self.description = "Performs a gamma correction on an input images."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        gamma = arcpy.Parameter(
            displayName="Gamma Value",
            name="gamma",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        gamma.value = '0.5'

        params = [i, output, gamma]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        gamma = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.gamma_correction(i=i, output=output, gamma=gamma)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class GaussianContrastStretch(object):
    def __init__(self):
        self.label = "Gaussian Contrast Stretch"
        self.description = "Performs a Gaussian contrast stretch on input images."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        num_tones = arcpy.Parameter(
            displayName="Number of Tones",
            name="num_tones",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        num_tones.value = '256'

        params = [i, output, num_tones]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        num_tones = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.gaussian_contrast_stretch(i=i, output=output, num_tones=num_tones)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class GaussianCurvature(object):
    def __init__(self):
        self.label = "Gaussian Curvature"
        self.description = "Calculates a mean curvature raster from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.gaussian_curvature(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class GaussianFilter(object):
    def __init__(self):
        self.label = "Gaussian Filter"
        self.description = "Performs a Gaussian filter on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        sigma = arcpy.Parameter(
            displayName="Standard Deviation (pixels)",
            name="sigma",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        sigma.value = '0.75'

        params = [i, output, sigma]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        sigma = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.gaussian_filter(i=i, output=output, sigma=sigma)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class GaussianScaleSpace(object):
    def __init__(self):
        self.label = "Gaussian Scale Space"
        self.description = "Uses the fast Gaussian approximation algorithm to produce scaled land-surface parameter measurements from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM Raster",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        points = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="points",
            datatype="GPFeatureLayer",
            parameterType="Optional",
            direction="Input")
        points.filter.list = ["Point"]

        output = arcpy.Parameter(
            displayName="Output Land-surface Parameter Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        output_zscore = arcpy.Parameter(
            displayName="Output z-Score Raster File",
            name="output_zscore",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output_zscore.filter.list = ["tif"]

        output_scale = arcpy.Parameter(
            displayName="Output Scale Raster File",
            name="output_scale",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output_scale.filter.list = ["tif"]

        sigma = arcpy.Parameter(
            displayName="Starting Scale",
            name="sigma",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        sigma.value = '0.5'

        step = arcpy.Parameter(
            displayName="Step Size",
            name="step",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        step.value = '0.5'

        num_steps = arcpy.Parameter(
            displayName="Number of Steps",
            name="num_steps",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        num_steps.value = '10'

        lsp = arcpy.Parameter(
            displayName="Land-surface Parameter to Calculate",
            name="lsp",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        lsp.filter.type = "ValueList"
        lsp.filter.list = ['AnisotropyLTP', 'Aspect', 'DiffMeanElev', 'Eastness', 'Elevation', 'Hillshade', 'MeanCurvature', 'Northness', 'PlanCurvature', 'ProfileCurvature', 'Ruggedness', 'Slope', 'TanCurvature', 'TotalCurvature']
        lsp.value = 'Slope'

        z_factor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="z_factor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, points, output, output_zscore, output_scale, sigma, step, num_steps, lsp, z_factor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        points = parameters[1].valueAsText
        if points is not None:
            desc = arcpy.Describe(points)
            points = desc.catalogPath
        output = parameters[2].valueAsText
        output_zscore = parameters[3].valueAsText
        output_scale = parameters[4].valueAsText
        sigma = parameters[5].valueAsText
        step = parameters[6].valueAsText
        num_steps = parameters[7].valueAsText
        lsp = parameters[8].valueAsText
        z_factor = parameters[9].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.gaussian_scale_space(dem=dem, points=points, output=output, output_zscore=output_zscore, output_scale=output_scale, sigma=sigma, step=step, num_steps=num_steps, lsp=lsp, z_factor=z_factor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class GeneralizeClassifiedRaster(object):
    def __init__(self):
        self.label = "Generalize Classified Raster"
        self.description = "Generalizes a raster containing class or object features by removing small features."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster Image",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        min_size = arcpy.Parameter(
            displayName="Min. Feature Size (in grid cells)",
            name="min_size",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_size.value = '4'

        method = arcpy.Parameter(
            displayName="Method",
            name="method",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        method.filter.type = "ValueList"
        method.filter.list = ['longest', 'largest', 'nearest']
        method.value = 'longest'

        params = [i, output, min_size, method]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        min_size = parameters[2].valueAsText
        method = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.generalize_classified_raster(i=i, output=output, min_size=min_size, method=method)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class GeneralizeWithSimilarity(object):
    def __init__(self):
        self.label = "Generalize With Similarity"
        self.description = "Generalizes a raster containing class or object features by removing small features using similarity criteria of neighbouring features."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster Image",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        similarity = arcpy.Parameter(
            displayName="Input Similarity Images",
            name="similarity",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        similarity.multiValue = True

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        min_size = arcpy.Parameter(
            displayName="Min. Feature Size (in grid cells)",
            name="min_size",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_size.value = '4'

        params = [i, similarity, output, min_size]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        similarity = parameters[1].valueAsText
        if similarity is not None:
            items = similarity.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            similarity = ";".join(items_path)
        output = parameters[2].valueAsText
        min_size = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.generalize_with_similarity(i=i, similarity=similarity, output=output, min_size=min_size)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class GeneratingFunction(object):
    def __init__(self):
        self.label = "Generating Function"
        self.description = "This tool calculates generating function from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input Raster DEM",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster Image",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z-factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        zfactor.value = '1.0'

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.generating_function(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Geomorphons(object):
    def __init__(self):
        self.label = "Geomorphons"
        self.description = "Computes geomorphon patterns."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM file.",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output file.",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        search = arcpy.Parameter(
            displayName="Search distance (cells).",
            name="search",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        search.value = '50'

        threshold = arcpy.Parameter(
            displayName="Flatness threshold (degrees).",
            name="threshold",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        threshold.value = '0.0'

        fdist = arcpy.Parameter(
            displayName="Flatness distance (cells).",
            name="fdist",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        fdist.value = '0'

        skip = arcpy.Parameter(
            displayName="Skip distance (cells).",
            name="skip",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        skip.value = '0'

        forms = arcpy.Parameter(
            displayName="Output forms",
            name="forms",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        forms.value = 'True'

        residuals = arcpy.Parameter(
            displayName="Analyze residuals",
            name="residuals",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        residuals.value = 'False'

        params = [dem, output, search, threshold, fdist, skip, forms, residuals]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        search = parameters[2].valueAsText
        threshold = parameters[3].valueAsText
        fdist = parameters[4].valueAsText
        skip = parameters[5].valueAsText
        forms = parameters[6].valueAsText
        residuals = parameters[7].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.geomorphons(dem=dem, output=output, search=search, threshold=threshold, fdist=fdist, skip=skip, forms=forms, residuals=residuals)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class GreaterThan(object):
    def __init__(self):
        self.label = "Greater Than"
        self.description = "Performs a greater-than comparison operation on two rasters or a raster and a constant value."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input1",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        incl_equals = arcpy.Parameter(
            displayName="Perform a greater-than-OR-EQUAL-TO operation?",
            name="incl_equals",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [input1, input2, output, incl_equals]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            try:
                input1 = str(float(input1))
            except:
                desc = arcpy.Describe(input1)
                input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        output = parameters[2].valueAsText
        incl_equals = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.greater_than(input1=input1, input2=input2, output=output, incl_equals=incl_equals)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HackStreamOrder(object):
    def __init__(self):
        self.label = "Hack Stream Order"
        self.description = "Assigns the Hack stream order to each tributary in a stream network."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [d8_pntr, streams, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        zero_background = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.hack_stream_order(d8_pntr=d8_pntr, streams=streams, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HeatMap(object):
    def __init__(self):
        self.label = "Heat Map"
        self.description = "Calculates a heat map, or kernel density estimation (KDE), for an input point set."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Points",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        weight_field = arcpy.Parameter(
            displayName="Weight Field Name (Optional)",
            name="weight_field",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster Image",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        bandwidth = arcpy.Parameter(
            displayName="Bandwidth",
            name="bandwidth",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        kernel = arcpy.Parameter(
            displayName="Kernel Type",
            name="kernel",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        kernel.filter.type = "ValueList"
        kernel.filter.list = ['uniform', 'triangular', 'epanechnikov', 'quartic', 'triweight', 'tricube', 'gaussian', 'cosine', 'logistic', 'sigmoid', 'silverman']
        kernel.value = 'quartic'

        cell_size = arcpy.Parameter(
            displayName="Output Raster Cell Size (Optional)",
            name="cell_size",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        base = arcpy.Parameter(
            displayName="Base Raster (Optional)",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        params = [i, weight_field, output, bandwidth, kernel, cell_size, base]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        weight_field = parameters[1].valueAsText
        output = parameters[2].valueAsText
        bandwidth = parameters[3].valueAsText
        kernel = parameters[4].valueAsText
        cell_size = parameters[5].valueAsText
        base = parameters[6].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.heat_map(i=i, weight_field=weight_field, output=output, bandwidth=bandwidth, kernel=kernel, cell_size=cell_size, base=base)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HeightAboveGround(object):
    def __init__(self):
        self.label = "Height Above Ground"
        self.description = "Normalizes a LiDAR point cloud, providing the height above the nearest ground-classified point."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Optional",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.height_above_ground(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HighPassBilateralFilter(object):
    def __init__(self):
        self.label = "High Pass Bilateral Filter"
        self.description = "Performs a high-pass bilateral filter, by differencing an input image by the bilateral filter by Tomasi and Manduchi (1998)."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        sigma_dist = arcpy.Parameter(
            displayName="Distance Standard Deviation (pixels)",
            name="sigma_dist",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        sigma_dist.value = '0.75'

        sigma_int = arcpy.Parameter(
            displayName="Intensity Standard Deviation (intensity units)",
            name="sigma_int",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        sigma_int.value = '1.0'

        params = [i, output, sigma_dist, sigma_int]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        sigma_dist = parameters[2].valueAsText
        sigma_int = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.high_pass_bilateral_filter(i=i, output=output, sigma_dist=sigma_dist, sigma_int=sigma_int)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HighPassFilter(object):
    def __init__(self):
        self.label = "High Pass Filter"
        self.description = "Performs a high-pass filter on an input image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        params = [i, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.high_pass_filter(i=i, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HighPassMedianFilter(object):
    def __init__(self):
        self.label = "High Pass Median Filter"
        self.description = "Performs a high pass median filter on an input image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        sig_digits = arcpy.Parameter(
            displayName="Number of Significant Digits",
            name="sig_digits",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        sig_digits.value = '2'

        params = [i, output, filterx, filtery, sig_digits]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        sig_digits = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.high_pass_median_filter(i=i, output=output, filterx=filterx, filtery=filtery, sig_digits=sig_digits)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HighestPosition(object):
    def __init__(self):
        self.label = "Highest Position"
        self.description = "Identifies the stack position of the maximum value within a raster stack on a cell-by-cell basis."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [inputs, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.highest_position(inputs=inputs, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Hillshade(object):
    def __init__(self):
        self.label = "Hillshade"
        self.description = "Calculates a hillshade raster from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        azimuth = arcpy.Parameter(
            displayName="Azimuth (degrees)",
            name="azimuth",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        azimuth.value = '315.0'

        altitude = arcpy.Parameter(
            displayName="Altitude (degrees)",
            name="altitude",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        altitude.value = '30.0'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, azimuth, altitude, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        azimuth = parameters[2].valueAsText
        altitude = parameters[3].valueAsText
        zfactor = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.hillshade(dem=dem, output=output, azimuth=azimuth, altitude=altitude, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Hillslopes(object):
    def __init__(self):
        self.label = "Hillslopes"
        self.description = "Identifies the individual hillslopes draining to each link in a stream network."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [d8_pntr, streams, output, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.hillslopes(d8_pntr=d8_pntr, streams=streams, output=output, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HistogramEqualization(object):
    def __init__(self):
        self.label = "Histogram Equalization"
        self.description = "Performs a histogram equalization contrast enhancement on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        num_tones = arcpy.Parameter(
            displayName="Number of Tones",
            name="num_tones",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        num_tones.value = '256'

        params = [i, output, num_tones]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        num_tones = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.histogram_equalization(i=i, output=output, num_tones=num_tones)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HistogramMatching(object):
    def __init__(self):
        self.label = "Histogram Matching"
        self.description = "Alters the statistical distribution of a raster image matching it to a specified PDF."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        histo_file = arcpy.Parameter(
            displayName="Input Probability Distribution Function (PDF) Text File",
            name="histo_file",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, histo_file, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        histo_file = parameters[1].valueAsText
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.histogram_matching(i=i, histo_file=histo_file, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HistogramMatchingTwoImages(object):
    def __init__(self):
        self.label = "Histogram Matching Two Images"
        self.description = "Alters the cumulative distribution function of a raster image to that of another image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File To Modify",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input Reference File",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.histogram_matching_two_images(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HoleProportion(object):
    def __init__(self):
        self.label = "Hole Proportion"
        self.description = "Calculates the proportion of the total area of a polygon's holes relative to the area of the polygon's hull."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.hole_proportion(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HorizonAngle(object):
    def __init__(self):
        self.label = "Horizon Angle"
        self.description = "Calculates horizon angle (maximum upwind slope) for each grid cell in an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        azimuth = arcpy.Parameter(
            displayName="Azimuth",
            name="azimuth",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        azimuth.value = '0.0'

        max_dist = arcpy.Parameter(
            displayName="Maximum Search Distance",
            name="max_dist",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        max_dist.value = '100.0'

        params = [dem, output, azimuth, max_dist]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        azimuth = parameters[2].valueAsText
        max_dist = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.horizon_angle(dem=dem, output=output, azimuth=azimuth, max_dist=max_dist)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HorizontalExcessCurvature(object):
    def __init__(self):
        self.label = "Horizontal Excess Curvature"
        self.description = "This tool calculates horizontal excess curvature from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input Raster DEM",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster Image",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z-factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        zfactor.value = '1.0'

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.horizontal_excess_curvature(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HortonStreamOrder(object):
    def __init__(self):
        self.label = "Horton Stream Order"
        self.description = "Assigns the Horton stream order to each tributary in a stream network."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [d8_pntr, streams, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        zero_background = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.horton_stream_order(d8_pntr=d8_pntr, streams=streams, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HydrologicConnectivity(object):
    def __init__(self):
        self.label = "Hydrologic Connectivity"
        self.description = "This tool evaluates hydrologic connectivity within a DEM"
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM Raster",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output1 = arcpy.Parameter(
            displayName="Output Downslope Unsaturated Length File",
            name="output1",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output1.filter.list = ["tif"]

        output2 = arcpy.Parameter(
            displayName="Output Upslope Disconnected Saturated Area File",
            name="output2",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output2.filter.list = ["tif"]

        exponent = arcpy.Parameter(
            displayName="Exponent Parameter",
            name="exponent",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        exponent.value = '1.0'

        threshold = arcpy.Parameter(
            displayName="Convergence Threshold (grid cells; blank for none)",
            name="threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output1, output2, exponent, threshold]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output1 = parameters[1].valueAsText
        output2 = parameters[2].valueAsText
        exponent = parameters[3].valueAsText
        threshold = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.hydrologic_connectivity(dem=dem, output1=output1, output2=output2, exponent=exponent, threshold=threshold)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HypsometricAnalysis(object):
    def __init__(self):
        self.label = "Hypsometric Analysis"
        self.description = "Calculates a hypsometric curve for one or more DEMs."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input DEM Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        watershed = arcpy.Parameter(
            displayName="Input Watershed Files (optional)",
            name="watershed",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")
        watershed.multiValue = True

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [inputs, watershed, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        watershed = parameters[1].valueAsText
        if watershed is not None:
            items = watershed.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            watershed = ";".join(items_path)
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.hypsometric_analysis(inputs=inputs, watershed=watershed, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class HypsometricallyTintedHillshade(object):
    def __init__(self):
        self.label = "Hypsometrically Tinted Hillshade"
        self.description = "Creates an colour shaded relief image from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        altitude = arcpy.Parameter(
            displayName="Illumination Source Altitude (degrees)",
            name="altitude",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        altitude.value = '45.0'

        hs_weight = arcpy.Parameter(
            displayName="Hillshade Weight",
            name="hs_weight",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        hs_weight.value = '0.5'

        brightness = arcpy.Parameter(
            displayName="Brightness",
            name="brightness",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        brightness.value = '0.5'

        atmospheric = arcpy.Parameter(
            displayName="Atmospheric Effects",
            name="atmospheric",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        atmospheric.value = '0.0'

        palette = arcpy.Parameter(
            displayName="Palette",
            name="palette",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        palette.filter.type = "ValueList"
        palette.filter.list = ['atlas', 'high_relief', 'arid', 'soft', 'muted', 'purple', 'viridis', 'gn_yl', 'pi_y_g', 'bl_yl_rd', 'deep']
        palette.value = 'atlas'

        reverse = arcpy.Parameter(
            displayName="Reverse palette?",
            name="reverse",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        reverse.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        full_mode = arcpy.Parameter(
            displayName="Full 360-degree hillshade mode?",
            name="full_mode",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        full_mode.value = 'False'

        params = [dem, output, altitude, hs_weight, brightness, atmospheric, palette, reverse, zfactor, full_mode]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        altitude = parameters[2].valueAsText
        hs_weight = parameters[3].valueAsText
        brightness = parameters[4].valueAsText
        atmospheric = parameters[5].valueAsText
        palette = parameters[6].valueAsText
        reverse = parameters[7].valueAsText
        zfactor = parameters[8].valueAsText
        full_mode = parameters[9].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.hypsometrically_tinted_hillshade(dem=dem, output=output, altitude=altitude, hs_weight=hs_weight, brightness=brightness, atmospheric=atmospheric, palette=palette, reverse=reverse, zfactor=zfactor, full_mode=full_mode)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class IdwInterpolation(object):
    def __init__(self):
        self.label = "Idw Interpolation"
        self.description = "Interpolates vector points into a raster surface using an inverse-distance weighted scheme."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        field = arcpy.Parameter(
            displayName="Field Name",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [i.name]

        use_z = arcpy.Parameter(
            displayName="Use z-coordinate instead of field?",
            name="use_z",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        use_z.value = 'False'

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        weight = arcpy.Parameter(
            displayName="IDW Weight (Exponent) Value",
            name="weight",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        weight.value = '2.0'

        radius = arcpy.Parameter(
            displayName="Search Radius (map units)",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        min_points = arcpy.Parameter(
            displayName="Min. Number of Points",
            name="min_points",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")

        cell_size = arcpy.Parameter(
            displayName="Cell Size (optional)",
            name="cell_size",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        base = arcpy.Parameter(
            displayName="Base Raster File (optional)",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        params = [i, field, use_z, output, weight, radius, min_points, cell_size, base]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        use_z = parameters[2].valueAsText
        output = parameters[3].valueAsText
        weight = parameters[4].valueAsText
        radius = parameters[5].valueAsText
        min_points = parameters[6].valueAsText
        cell_size = parameters[7].valueAsText
        base = parameters[8].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.idw_interpolation(i=i, field=field, use_z=use_z, output=output, weight=weight, radius=radius, min_points=min_points, cell_size=cell_size, base=base)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class IhsToRgb(object):
    def __init__(self):
        self.label = "Ihs To Rgb"
        self.description = "Converts intensity, hue, and saturation (IHS) images into red, green, and blue (RGB) images."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        intensity = arcpy.Parameter(
            displayName="Input Intensity File",
            name="intensity",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        hue = arcpy.Parameter(
            displayName="Input Hue File",
            name="hue",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        saturation = arcpy.Parameter(
            displayName="Input Saturation File",
            name="saturation",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        red = arcpy.Parameter(
            displayName="Output Red Band File (optional; only if colour-composite not specified)",
            name="red",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        red.filter.list = ["tif"]

        green = arcpy.Parameter(
            displayName="Output Green Band File (optional; only if colour-composite not specified)",
            name="green",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        green.filter.list = ["tif"]

        blue = arcpy.Parameter(
            displayName="Output Blue Band File (optional; only if colour-composite not specified)",
            name="blue",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        blue.filter.list = ["tif"]

        output = arcpy.Parameter(
            displayName="Output Colour-Composite File (optional; only if individual bands not specified)",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [intensity, hue, saturation, red, green, blue, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        intensity = parameters[0].valueAsText
        if intensity is not None:
            desc = arcpy.Describe(intensity)
            intensity = desc.catalogPath
        hue = parameters[1].valueAsText
        if hue is not None:
            desc = arcpy.Describe(hue)
            hue = desc.catalogPath
        saturation = parameters[2].valueAsText
        if saturation is not None:
            desc = arcpy.Describe(saturation)
            saturation = desc.catalogPath
        red = parameters[3].valueAsText
        green = parameters[4].valueAsText
        blue = parameters[5].valueAsText
        output = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.ihs_to_rgb(intensity=intensity, hue=hue, saturation=saturation, red=red, green=green, blue=blue, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ImageAutocorrelation(object):
    def __init__(self):
        self.label = "Image Autocorrelation"
        self.description = "Performs Moran's I analysis on two or more input images."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        contiguity = arcpy.Parameter(
            displayName="Contiguity Type",
            name="contiguity",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        contiguity.filter.type = "ValueList"
        contiguity.filter.list = ['Rook', 'King', 'Bishop']
        contiguity.value = 'Rook'

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [inputs, contiguity, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        contiguity = parameters[1].valueAsText
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.image_autocorrelation(inputs=inputs, contiguity=contiguity, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ImageCorrelation(object):
    def __init__(self):
        self.label = "Image Correlation"
        self.description = "Performs image correlation on two or more input images."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [inputs, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.image_correlation(inputs=inputs, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ImageCorrelationNeighbourhoodAnalysis(object):
    def __init__(self):
        self.label = "Image Correlation Neighbourhood Analysis"
        self.description = "Performs image correlation on two input images neighbourhood search windows."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Image 1",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Image 2",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output1 = arcpy.Parameter(
            displayName="Output Correlation File",
            name="output1",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output1.filter.list = ["tif"]

        output2 = arcpy.Parameter(
            displayName="Output Significance File",
            name="output2",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output2.filter.list = ["tif"]

        filter = arcpy.Parameter(
            displayName="Filter Size",
            name="filter",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filter.value = '11'

        stat = arcpy.Parameter(
            displayName="Correlation Statistic Type",
            name="stat",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        stat.filter.type = "ValueList"
        stat.filter.list = ['pearson', 'kendall', 'spearman']
        stat.value = 'pearson'

        params = [input1, input2, output1, output2, filter, stat]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output1 = parameters[2].valueAsText
        output2 = parameters[3].valueAsText
        filter = parameters[4].valueAsText
        stat = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.image_correlation_neighbourhood_analysis(input1=input1, input2=input2, output1=output1, output2=output2, filter=filter, stat=stat)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ImageRegression(object):
    def __init__(self):
        self.label = "Image Regression"
        self.description = "Performs image regression analysis on two input images."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Independent Variable (X).",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Dependent Variable (Y).",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Summary Report File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        out_residuals = arcpy.Parameter(
            displayName="Optional Residuals Output File",
            name="out_residuals",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_residuals.filter.list = ["tif"]

        standardize = arcpy.Parameter(
            displayName="Standardize the residuals map?",
            name="standardize",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        scattergram = arcpy.Parameter(
            displayName="Output scattergram?",
            name="scattergram",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        num_samples = arcpy.Parameter(
            displayName="Num. Samples For Scattergram",
            name="num_samples",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        num_samples.value = '1000'

        params = [input1, input2, output, out_residuals, standardize, scattergram, num_samples]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        out_residuals = parameters[3].valueAsText
        standardize = parameters[4].valueAsText
        scattergram = parameters[5].valueAsText
        num_samples = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.image_regression(input1=input1, input2=input2, output=output, out_residuals=out_residuals, standardize=standardize, scattergram=scattergram, num_samples=num_samples)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ImageSegmentation(object):
    def __init__(self):
        self.label = "Image Segmentation"
        self.description = "Performs a region-growing based segmentation on a set of multi-spectral images."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Band Images",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        threshold = arcpy.Parameter(
            displayName="Distance Threshold (z-scores)",
            name="threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        threshold.value = '0.5'

        steps = arcpy.Parameter(
            displayName="Number of Steps",
            name="steps",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        steps.value = '10'

        min_area = arcpy.Parameter(
            displayName="Min. Object Area (in grid cells)",
            name="min_area",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_area.value = '4'

        params = [inputs, output, threshold, steps, min_area]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        threshold = parameters[2].valueAsText
        steps = parameters[3].valueAsText
        min_area = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.image_segmentation(inputs=inputs, output=output, threshold=threshold, steps=steps, min_area=min_area)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ImageSlider(object):
    def __init__(self):
        self.label = "Image Slider"
        self.description = "This tool creates an image slider from two input images."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Left Input Raster Image",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        palette1 = arcpy.Parameter(
            displayName="Left Image Palette",
            name="palette1",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        palette1.filter.type = "ValueList"
        palette1.filter.list = ['grey', 'atlas', 'high_relief', 'arid', 'soft', 'muted', 'purple', 'viridi', 'gn_yl', 'pi_y_g', 'bl_yl_rd', 'deep', 'rgb']
        palette1.value = 'grey'

        reverse1 = arcpy.Parameter(
            displayName="Reverse left image palette?",
            name="reverse1",
            datatype="GPBoolean",
            parameterType="Required",
            direction="Input")
        reverse1.value = 'False'

        label1 = arcpy.Parameter(
            displayName="Left Image Label (blank for none)",
            name="label1",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        input2 = arcpy.Parameter(
            displayName="Right Input Raster Image",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        palette2 = arcpy.Parameter(
            displayName="Right Image Palette",
            name="palette2",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        palette2.filter.type = "ValueList"
        palette2.filter.list = ['grey', 'atlas', 'high_relief', 'arid', 'soft', 'muted', 'purple', 'viridi', 'gn_yl', 'pi_y_g', 'bl_yl_rd', 'deep', 'rgb']
        palette2.value = 'grey'

        reverse2 = arcpy.Parameter(
            displayName="Reverse right image palette?",
            name="reverse2",
            datatype="GPBoolean",
            parameterType="Required",
            direction="Input")
        reverse2.value = 'False'

        label2 = arcpy.Parameter(
            displayName="Right Image Label (blank for none)",
            name="label2",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        output = arcpy.Parameter(
            displayName="Output File (*.html)",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        height = arcpy.Parameter(
            displayName="Image Height (in pixels)",
            name="height",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        height.value = '600'

        params = [input1, palette1, reverse1, label1, input2, palette2, reverse2, label2, output, height]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        palette1 = parameters[1].valueAsText
        reverse1 = parameters[2].valueAsText
        label1 = parameters[3].valueAsText
        input2 = parameters[4].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        palette2 = parameters[5].valueAsText
        reverse2 = parameters[6].valueAsText
        label2 = parameters[7].valueAsText
        output = parameters[8].valueAsText
        height = parameters[9].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.image_slider(input1=input1, palette1=palette1, reverse1=reverse1, label1=label1, input2=input2, palette2=palette2, reverse2=reverse2, label2=label2, output=output, height=height)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ImageStackProfile(object):
    def __init__(self):
        self.label = "Image Stack Profile"
        self.description = "Plots an image stack profile (i.e. signature) for a set of points and multispectral images."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        points = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="points",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        points.filter.list = ["Point"]

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [inputs, points, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        points = parameters[1].valueAsText
        if points is not None:
            desc = arcpy.Describe(points)
            points = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.image_stack_profile(inputs=inputs, points=points, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ImpoundmentSizeIndex(object):
    def __init__(self):
        self.label = "Impoundment Size Index"
        self.description = "Calculates the impoundment size resulting from damming a DEM."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        out_mean = arcpy.Parameter(
            displayName="Output Mean Depth File",
            name="out_mean",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_mean.filter.list = ["tif"]

        out_max = arcpy.Parameter(
            displayName="Output Max. Depth File",
            name="out_max",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_max.filter.list = ["tif"]

        out_volume = arcpy.Parameter(
            displayName="Output Volume File",
            name="out_volume",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_volume.filter.list = ["tif"]

        out_area = arcpy.Parameter(
            displayName="Output Area File",
            name="out_area",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_area.filter.list = ["tif"]

        out_dam_height = arcpy.Parameter(
            displayName="Output Dam Height File",
            name="out_dam_height",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_dam_height.filter.list = ["tif"]

        damlength = arcpy.Parameter(
            displayName="Max dam length (grid cells)",
            name="damlength",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        params = [dem, out_mean, out_max, out_volume, out_area, out_dam_height, damlength]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        out_mean = parameters[1].valueAsText
        out_max = parameters[2].valueAsText
        out_volume = parameters[3].valueAsText
        out_area = parameters[4].valueAsText
        out_dam_height = parameters[5].valueAsText
        damlength = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.impoundment_size_index(dem=dem, out_mean=out_mean, out_max=out_max, out_volume=out_volume, out_area=out_area, out_dam_height=out_dam_height, damlength=damlength)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class InPlaceAdd(object):
    def __init__(self):
        self.label = "In Place Add"
        self.description = "Performs an in-place addition operation (input1 += input2)."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input Raster File",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        params = [input1, input2]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.in_place_add(input1=input1, input2=input2)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class InPlaceDivide(object):
    def __init__(self):
        self.label = "In Place Divide"
        self.description = "Performs an in-place division operation (input1 /= input2)."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input Raster File",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        params = [input1, input2]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.in_place_divide(input1=input1, input2=input2)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class InPlaceMultiply(object):
    def __init__(self):
        self.label = "In Place Multiply"
        self.description = "Performs an in-place multiplication operation (input1 *= input2)."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input Raster File",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        params = [input1, input2]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.in_place_multiply(input1=input1, input2=input2)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class InPlaceSubtract(object):
    def __init__(self):
        self.label = "In Place Subtract"
        self.description = "Performs an in-place subtraction operation (input1 -= input2)."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input Raster File",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        params = [input1, input2]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.in_place_subtract(input1=input1, input2=input2)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Increment(object):
    def __init__(self):
        self.label = "Increment"
        self.description = "Increases the values of each grid cell in an input raster by 1.0. (see also InPlaceAdd)"
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.increment(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class IndividualTreeDetection(object):
    def __init__(self):
        self.label = "Individual Tree Detection"
        self.description = "Identifies points in a LiDAR point cloud that are associated with the tops of individual trees."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output Vector",
            name="output",
            datatype="DEShapefile",
            parameterType="Optional",
            direction="Output")

        min_search_radius = arcpy.Parameter(
            displayName="Min. Search Radius",
            name="min_search_radius",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        min_search_radius.value = '1.0'

        min_height = arcpy.Parameter(
            displayName="Min. Height",
            name="min_height",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        min_height.value = '0.0'

        max_search_radius = arcpy.Parameter(
            displayName="Max. Search Radius",
            name="max_search_radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        max_height = arcpy.Parameter(
            displayName="Max. Height",
            name="max_height",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        only_use_veg = arcpy.Parameter(
            displayName="Only use veg. class points?",
            name="only_use_veg",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        only_use_veg.value = 'False'

        params = [i, output, min_search_radius, min_height, max_search_radius, max_height, only_use_veg]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        min_search_radius = parameters[2].valueAsText
        min_height = parameters[3].valueAsText
        max_search_radius = parameters[4].valueAsText
        max_height = parameters[5].valueAsText
        only_use_veg = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.individual_tree_detection(i=i, output=output, min_search_radius=min_search_radius, min_height=min_height, max_search_radius=max_search_radius, max_height=max_height, only_use_veg=only_use_veg)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class InsertDams(object):
    def __init__(self):
        self.label = "Insert Dams"
        self.description = "Calculates the impoundment size resulting from damming a DEM."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        dam_pts = arcpy.Parameter(
            displayName="Input Dam Points",
            name="dam_pts",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        dam_pts.filter.list = ["Point"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        damlength = arcpy.Parameter(
            displayName="Max dam length (grid cells)",
            name="damlength",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        params = [dem, dam_pts, output, damlength]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        dam_pts = parameters[1].valueAsText
        if dam_pts is not None:
            desc = arcpy.Describe(dam_pts)
            dam_pts = desc.catalogPath
        output = parameters[2].valueAsText
        damlength = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.insert_dams(dem=dem, dam_pts=dam_pts, output=output, damlength=damlength)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class InstallWbExtension(object):
    def __init__(self):
        self.label = "Install Wb Extension"
        self.description = "Use to install a Whitebox extension product."
        self.category = "Whitebox Utilities"

    def getParameterInfo(self):
        install_extension = arcpy.Parameter(
            displayName="Whitebox Extension Product Name",
            name="install_extension",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        install_extension.filter.type = "ValueList"
        install_extension.filter.list = ['General Toolset Extension', 'DEM & Spatial Hydrology Extension', 'Lidar & Remote Sensing Extension', 'Agriculture Extension']
        install_extension.value = 'General Toolset Extension'

        params = [install_extension]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        install_extension = parameters[0].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.install_wb_extension(install_extension=install_extension)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class IntegerDivision(object):
    def __init__(self):
        self.label = "Integer Division"
        self.description = "Performs an integer division operation on two rasters or a raster and a constant value."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input1",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            try:
                input1 = str(float(input1))
            except:
                desc = arcpy.Describe(input1)
                input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.integer_division(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class IntegralImage(object):
    def __init__(self):
        self.label = "Integral Image"
        self.description = "Transforms an input image (summed area table) into its integral image equivalent."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.integral_image(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Intersect(object):
    def __init__(self):
        self.label = "Intersect"
        self.description = "Identifies the parts of features in common between two input vector layers."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        overlay = arcpy.Parameter(
            displayName="Input Overlay Vector File",
            name="overlay",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        snap = arcpy.Parameter(
            displayName="Snap Tolerance",
            name="snap",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        snap.value = '0.0'

        params = [i, overlay, output, snap]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        overlay = parameters[1].valueAsText
        if overlay is not None:
            desc = arcpy.Describe(overlay)
            overlay = desc.catalogPath
        output = parameters[2].valueAsText
        snap = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.intersect(i=i, overlay=overlay, output=output, snap=snap)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class InversePrincipalComponentAnalysis(object):
    def __init__(self):
        self.label = "Inverse Pca"
        self.description = "This tool performs an inverse principal component analysis on a series of input component images."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input PCA Component Images",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        report = arcpy.Parameter(
            displayName="Input PCA Report File",
            name="report",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        report.filter.list = ["html"]

        params = [inputs, report]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        report = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.inverse_principal_component_analysis(inputs=inputs, report=report)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class IsNoData(object):
    def __init__(self):
        self.label = "Is No Data"
        self.description = "Identifies NoData valued pixels in an image."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.is_no_data(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Isobasins(object):
    def __init__(self):
        self.label = "Isobasins"
        self.description = "Divides a landscape into nearly equal sized drainage basins (i.e. watersheds)."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        size = arcpy.Parameter(
            displayName="Target Basin Size (grid cells)",
            name="size",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")

        connections = arcpy.Parameter(
            displayName="Output basin upstream-downstream connections?",
            name="connections",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        connections.value = 'False'

        params = [dem, output, size, connections]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        size = parameters[2].valueAsText
        connections = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.isobasins(dem=dem, output=output, size=size, connections=connections)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class JensonSnapPourPoints(object):
    def __init__(self):
        self.label = "Jenson Snap Pour Points"
        self.description = "Moves outlet points used to specify points of interest in a watershedding operation to the nearest stream cell."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        pour_pts = arcpy.Parameter(
            displayName="Input Pour Points (Outlet) File",
            name="pour_pts",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        pour_pts.filter.list = ["Point"]

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        snap_dist = arcpy.Parameter(
            displayName="Maximum Snap Distance (map units)",
            name="snap_dist",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        params = [pour_pts, streams, output, snap_dist]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        pour_pts = parameters[0].valueAsText
        if pour_pts is not None:
            desc = arcpy.Describe(pour_pts)
            pour_pts = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        snap_dist = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.jenson_snap_pour_points(pour_pts=pour_pts, streams=streams, output=output, snap_dist=snap_dist)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class JoinTables(object):
    def __init__(self):
        self.label = "Join Tables"
        self.description = "Merge a vector's attribute table with another table based on a common field."
        self.category = "Data Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input Primary Vector File",
            name="input1",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        pkey = arcpy.Parameter(
            displayName="Primary Key Field",
            name="pkey",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        pkey.parameterDependencies = [input1.name]

        input2 = arcpy.Parameter(
            displayName="Input Foreign Vector File",
            name="input2",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        fkey = arcpy.Parameter(
            displayName="Foreign Key Field",
            name="fkey",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        fkey.parameterDependencies = [input2.name]

        import_field = arcpy.Parameter(
            displayName="Imported Field",
            name="import_field",
            datatype="Field",
            parameterType="Optional",
            direction="Input")
        import_field.parameterDependencies = [input2.name]

        params = [input1, pkey, input2, fkey, import_field]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        pkey = parameters[1].valueAsText
        input2 = parameters[2].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        fkey = parameters[3].valueAsText
        import_field = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.join_tables(input1=input1, pkey=pkey, input2=input2, fkey=fkey, import_field=import_field)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class KMeansClustering(object):
    def __init__(self):
        self.label = "K Means Clustering"
        self.description = "Performs a k-means clustering operation on a multi-spectral dataset."
        self.category = "Machine Learning"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        out_html = arcpy.Parameter(
            displayName="Output HTML Report File",
            name="out_html",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_html.filter.list = ["html"]

        classes = arcpy.Parameter(
            displayName="Num. Classes (k)",
            name="classes",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")

        max_iterations = arcpy.Parameter(
            displayName="Max. Iterations",
            name="max_iterations",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        max_iterations.value = '10'

        class_change = arcpy.Parameter(
            displayName="Percent Class Change Threshold",
            name="class_change",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        class_change.value = '2.0'

        initialize = arcpy.Parameter(
            displayName="How to Initialize Cluster Centres?",
            name="initialize",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        initialize.filter.type = "ValueList"
        initialize.filter.list = ['diagonal', 'random']
        initialize.value = 'diagonal'

        min_class_size = arcpy.Parameter(
            displayName="Min. Class Size",
            name="min_class_size",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_class_size.value = '10'

        params = [inputs, output, out_html, classes, max_iterations, class_change, initialize, min_class_size]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        out_html = parameters[2].valueAsText
        classes = parameters[3].valueAsText
        max_iterations = parameters[4].valueAsText
        class_change = parameters[5].valueAsText
        initialize = parameters[6].valueAsText
        min_class_size = parameters[7].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.k_means_clustering(inputs=inputs, output=output, out_html=out_html, classes=classes, max_iterations=max_iterations, class_change=class_change, initialize=initialize, min_class_size=min_class_size)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class KNearestMeanFilter(object):
    def __init__(self):
        self.label = "K Nearest Mean Filter"
        self.description = "A k-nearest mean filter is a type of edge-preserving smoothing filter."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        k = arcpy.Parameter(
            displayName="K-value (pixels)",
            name="k",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        k.value = '5'

        params = [i, output, filterx, filtery, k]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        k = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.k_nearest_mean_filter(i=i, output=output, filterx=filterx, filtery=filtery, k=k)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class KappaIndex(object):
    def __init__(self):
        self.label = "Kappa Index"
        self.description = "Performs a kappa index of agreement (KIA) analysis on two categorical raster files."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input Classification File",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input Reference File",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.kappa_index(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class KnnClassification(object):
    def __init__(self):
        self.label = "Knn Classification"
        self.description = "Performs a supervised k-nearest neighbour classification using training site polygons/points and predictor rasters."
        self.category = "Machine Learning"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Predictor Rasters",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        training = arcpy.Parameter(
            displayName="Input Training Polygons/Points",
            name="training",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        field = arcpy.Parameter(
            displayName="Class Name Field",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [training.name]

        test_proportion = arcpy.Parameter(
            displayName="Test Proportion",
            name="test_proportion",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        test_proportion.value = '0.2'

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        scaling = arcpy.Parameter(
            displayName="Scaling Method",
            name="scaling",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        scaling.filter.type = "ValueList"
        scaling.filter.list = ['None', 'Normalize', 'Standardize']
        scaling.value = 'Normalize'

        k = arcpy.Parameter(
            displayName="Number of Nearest Neighbours, k",
            name="k",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        k.value = '5'

        clip = arcpy.Parameter(
            displayName="Perform training data clipping?",
            name="clip",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        clip.value = 'True'

        params = [inputs, training, field, test_proportion, output, scaling, k, clip]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        training = parameters[1].valueAsText
        if training is not None:
            desc = arcpy.Describe(training)
            training = desc.catalogPath
        field = parameters[2].valueAsText
        test_proportion = parameters[3].valueAsText
        output = parameters[4].valueAsText
        scaling = parameters[5].valueAsText
        k = parameters[6].valueAsText
        clip = parameters[7].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.knn_classification(inputs=inputs, training=training, field=field, test_proportion=test_proportion, output=output, scaling=scaling, k=k, clip=clip)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class KnnRegression(object):
    def __init__(self):
        self.label = "Knn Regression"
        self.description = "Performs a supervised k-nearest neighbour regression using training site points and predictor rasters."
        self.category = "Machine Learning"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Predictor Rasters",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        scaling = arcpy.Parameter(
            displayName="Scaling Method",
            name="scaling",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        scaling.filter.type = "ValueList"
        scaling.filter.list = ['None', 'Normalize', 'Standardize']
        scaling.value = 'Normalize'

        training = arcpy.Parameter(
            displayName="Input Training Points",
            name="training",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        training.filter.list = ["Point"]

        field = arcpy.Parameter(
            displayName="Response Variable Field Name",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [training.name]

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        k = arcpy.Parameter(
            displayName="Number of Nearest Neighbours, k",
            name="k",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        k.value = '5'

        weight = arcpy.Parameter(
            displayName="Use distance weighting?",
            name="weight",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        weight.value = 'True'

        test_proportion = arcpy.Parameter(
            displayName="Test Proportion",
            name="test_proportion",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        test_proportion.value = '0.2'

        params = [inputs, scaling, training, field, output, k, weight, test_proportion]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        scaling = parameters[1].valueAsText
        training = parameters[2].valueAsText
        if training is not None:
            desc = arcpy.Describe(training)
            training = desc.catalogPath
        field = parameters[3].valueAsText
        output = parameters[4].valueAsText
        k = parameters[5].valueAsText
        weight = parameters[6].valueAsText
        test_proportion = parameters[7].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.knn_regression(inputs=inputs, scaling=scaling, training=training, field=field, output=output, k=k, weight=weight, test_proportion=test_proportion)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class KsTestForNormality(object):
    def __init__(self):
        self.label = "Ks Test For Normality"
        self.description = "Evaluates whether the values in a raster are normally distributed."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        num_samples = arcpy.Parameter(
            displayName="Num. Samples (blank for while image)",
            name="num_samples",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")

        params = [i, output, num_samples]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        num_samples = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.ks_test_for_normality(i=i, output=output, num_samples=num_samples)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LaplacianFilter(object):
    def __init__(self):
        self.label = "Laplacian Filter"
        self.description = "Performs a Laplacian filter on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        variant = arcpy.Parameter(
            displayName="Variant",
            name="variant",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        variant.filter.type = "ValueList"
        variant.filter.list = ['3x3(1)', '3x3(2)', '3x3(3)', '3x3(4)', '5x5(1)', '5x5(2)']
        variant.value = '3x3(1)'

        clip = arcpy.Parameter(
            displayName="Distribution Tail Clip Amount (%)",
            name="clip",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        clip.value = '0.0'

        params = [i, output, variant, clip]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        variant = parameters[2].valueAsText
        clip = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.laplacian_filter(i=i, output=output, variant=variant, clip=clip)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LaplacianOfGaussianFilter(object):
    def __init__(self):
        self.label = "Laplacian Of Gaussian Filter"
        self.description = "Performs a Laplacian-of-Gaussian (LoG) filter on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        sigma = arcpy.Parameter(
            displayName="Standard Deviation (Pixels)",
            name="sigma",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        sigma.value = '0.75'

        params = [i, output, sigma]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        sigma = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.laplacian_of_gaussian_filter(i=i, output=output, sigma=sigma)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LasToAscii(object):
    def __init__(self):
        self.label = "Las To Ascii"
        self.description = "Converts one or more LAS files into ASCII text files."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input LiDAR Files",
            name="inputs",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True
        inputs.filter.list = ["las", "zip"]

        params = [inputs]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.las_to_ascii(inputs=inputs)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LasToLaz(object):
    def __init__(self):
        self.label = "Las To Laz"
        self.description = "This tool converts one or more LAS files into the LAZ format"
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LAS File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output LAZ File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.las_to_laz(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LasToMultipointShapefile(object):
    def __init__(self):
        self.label = "Las To Multipoint Shapefile"
        self.description = "Converts one or more LAS files into MultipointZ vector Shapefiles. When the input parameter is not specified, the tool grids all LAS files contained within the working directory."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.las_to_multipoint_shapefile(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LasToShapefile(object):
    def __init__(self):
        self.label = "Las To Shapefile"
        self.description = "Converts one or more LAS files into a vector Shapefile of POINT ShapeType."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.las_to_shapefile(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LasToZlidar(object):
    def __init__(self):
        self.label = "Las To Zlidar"
        self.description = "Converts one or more LAS files into the zlidar compressed LiDAR data format."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input LAS Files",
            name="inputs",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        inputs.multiValue = True
        inputs.filter.list = ["las", "zip"]

        outdir = arcpy.Parameter(
            displayName="Output Directory",
            name="outdir",
            datatype="DEFolder",
            parameterType="Optional",
            direction="Input")

        compress = arcpy.Parameter(
            displayName="Compression Method",
            name="compress",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        compress.filter.type = "ValueList"
        compress.filter.list = ['brotli', 'deflate']
        compress.value = 'brotli'

        level = arcpy.Parameter(
            displayName="Compression Level",
            name="level",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        level.value = '5'

        params = [inputs, outdir, compress, level]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        outdir = parameters[1].valueAsText
        compress = parameters[2].valueAsText
        level = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.las_to_zlidar(inputs=inputs, outdir=outdir, compress=compress, level=level)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LaunchWbRunner(object):
    def __init__(self):
        self.label = "Launch Wb Runner"
        self.description = "Opens the Whitebox Runner application."
        self.category = "Whitebox Utilities"

    def getParameterInfo(self):
        clear_app_state = arcpy.Parameter(
            displayName="Clear the application state memory?",
            name="clear_app_state",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        clear_app_state.value = 'False'

        params = [clear_app_state]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        clear_app_state = parameters[0].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.launch_wb_runner(clear_app_state=clear_app_state)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LayerFootprint(object):
    def __init__(self):
        self.label = "Layer Footprint"
        self.description = "Creates a vector polygon footprint of the area covered by a raster grid or vector layer."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster or Vector File",
            name="i",
            datatype=["DERasterDataset", "DEShapefile"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.layer_footprint(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LazToLas(object):
    def __init__(self):
        self.label = "Laz To Las"
        self.description = "This tool converts one or more LAZ files into the LAS format"
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LAZ File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output LAS File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.laz_to_las(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LeeSigmaFilter(object):
    def __init__(self):
        self.label = "Lee Sigma Filter"
        self.description = "Performs a Lee (Sigma) smoothing filter on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        sigma = arcpy.Parameter(
            displayName="Sigma",
            name="sigma",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        sigma.value = '10.0'

        m = arcpy.Parameter(
            displayName="M-value",
            name="m",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        m.value = '5.0'

        params = [i, output, filterx, filtery, sigma, m]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        sigma = parameters[4].valueAsText
        m = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lee_sigma_filter(i=i, output=output, filterx=filterx, filtery=filtery, sigma=sigma, m=m)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LengthOfUpstreamChannels(object):
    def __init__(self):
        self.label = "Length Of Upstream Channels"
        self.description = "Calculates the total length of channels upstream."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [d8_pntr, streams, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        zero_background = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.length_of_upstream_channels(d8_pntr=d8_pntr, streams=streams, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LessThan(object):
    def __init__(self):
        self.label = "Less Than"
        self.description = "Performs a less-than comparison operation on two rasters or a raster and a constant value."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input1",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        incl_equals = arcpy.Parameter(
            displayName="Perform a less-than-OR-EQUAL-TO operation?",
            name="incl_equals",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [input1, input2, output, incl_equals]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            try:
                input1 = str(float(input1))
            except:
                desc = arcpy.Describe(input1)
                input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        output = parameters[2].valueAsText
        incl_equals = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.less_than(input1=input1, input2=input2, output=output, incl_equals=incl_equals)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarBlockMaximum(object):
    def __init__(self):
        self.label = "Lidar Block Maximum"
        self.description = "Creates a block-maximum raster from an input LAS file. When the input/output parameters are not specified, the tool grids all LAS files contained within the working directory."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        resolution = arcpy.Parameter(
            displayName="Grid Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        resolution.value = '1.0'

        params = [i, output, resolution]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        resolution = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_block_maximum(i=i, output=output, resolution=resolution)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarBlockMinimum(object):
    def __init__(self):
        self.label = "Lidar Block Minimum"
        self.description = "Creates a block-minimum raster from an input LAS file. When the input/output parameters are not specified, the tool grids all LAS files contained within the working directory."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        resolution = arcpy.Parameter(
            displayName="Grid Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        resolution.value = '1.0'

        params = [i, output, resolution]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        resolution = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_block_minimum(i=i, output=output, resolution=resolution)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarClassifySubset(object):
    def __init__(self):
        self.label = "Lidar Classify Subset"
        self.description = "Classifies the values in one LiDAR point cloud that correspond with points in a subset cloud."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        base = arcpy.Parameter(
            displayName="Input Base LiDAR File",
            name="base",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        base.filter.list = ["las", "zip"]

        subset = arcpy.Parameter(
            displayName="Input Subset LiDAR File",
            name="subset",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        subset.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output LiDAR File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        subset_class = arcpy.Parameter(
            displayName="Subset Point Class Value",
            name="subset_class",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        nonsubset_class = arcpy.Parameter(
            displayName="Non-Subset Point Class Value (Optional)",
            name="nonsubset_class",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [base, subset, output, subset_class, nonsubset_class]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        base = parameters[0].valueAsText
        subset = parameters[1].valueAsText
        output = parameters[2].valueAsText
        subset_class = parameters[3].valueAsText
        nonsubset_class = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_classify_subset(base=base, subset=subset, output=output, subset_class=subset_class, nonsubset_class=nonsubset_class)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarColourize(object):
    def __init__(self):
        self.label = "Lidar Colourize"
        self.description = "Adds the red-green-blue colour fields of a LiDAR (LAS) file based on an input image."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        in_lidar = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="in_lidar",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        in_lidar.filter.list = ["las", "zip"]

        in_image = arcpy.Parameter(
            displayName="Input Colour Image File",
            name="in_image",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output LiDAR File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        params = [in_lidar, in_image, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        in_lidar = parameters[0].valueAsText
        in_image = parameters[1].valueAsText
        if in_image is not None:
            desc = arcpy.Describe(in_image)
            in_image = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_colourize(in_lidar=in_lidar, in_image=in_image, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarContour(object):
    def __init__(self):
        self.label = "Lidar Contour"
        self.description = "This tool creates a vector contour coverage from an input LiDAR point file."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR Points",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output Vector Lines",
            name="output",
            datatype="DEShapefile",
            parameterType="Optional",
            direction="Output")

        interval = arcpy.Parameter(
            displayName="Contour Interval",
            name="interval",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        interval.value = '10.0'

        base = arcpy.Parameter(
            displayName="Base Contour",
            name="base",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        base.value = '0.0'

        smooth = arcpy.Parameter(
            displayName="Smoothing Filter Size",
            name="smooth",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        smooth.value = '5'

        parameter = arcpy.Parameter(
            displayName="Interpolation Parameter",
            name="parameter",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        parameter.filter.type = "ValueList"
        parameter.filter.list = ['elevation', 'intensity', 'user_data']
        parameter.value = 'elevation'

        returns = arcpy.Parameter(
            displayName="Point Returns Included",
            name="returns",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        returns.filter.type = "ValueList"
        returns.filter.list = ['all', 'last', 'first']
        returns.value = 'all'

        exclude_cls = arcpy.Parameter(
            displayName="Exclusion Classes (0-18, based on LAS spec; e.g. 3,4,5,6,7)",
            name="exclude_cls",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")

        minz = arcpy.Parameter(
            displayName="Minimum Elevation Value (optional)",
            name="minz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        maxz = arcpy.Parameter(
            displayName="Maximum Elevation Value (optional)",
            name="maxz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        max_triangle_edge_length = arcpy.Parameter(
            displayName="Maximum Triangle Length (optional)",
            name="max_triangle_edge_length",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [i, output, interval, base, smooth, parameter, returns, exclude_cls, minz, maxz, max_triangle_edge_length]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        interval = parameters[2].valueAsText
        base = parameters[3].valueAsText
        smooth = parameters[4].valueAsText
        parameter = parameters[5].valueAsText
        returns = parameters[6].valueAsText
        exclude_cls = parameters[7].valueAsText
        minz = parameters[8].valueAsText
        maxz = parameters[9].valueAsText
        max_triangle_edge_length = parameters[10].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_contour(i=i, output=output, interval=interval, base=base, smooth=smooth, parameter=parameter, returns=returns, exclude_cls=exclude_cls, minz=minz, maxz=maxz, max_triangle_edge_length=max_triangle_edge_length)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarDigitalSurfaceModel(object):
    def __init__(self):
        self.label = "Lidar Digital Surface Model"
        self.description = "Creates a top-surface digital surface model (DSM) from a LiDAR point cloud."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        resolution = arcpy.Parameter(
            displayName="Grid Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        resolution.value = '1.0'

        radius = arcpy.Parameter(
            displayName="Search Radius",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        radius.value = '0.5'

        minz = arcpy.Parameter(
            displayName="Minimum Elevation Value (optional)",
            name="minz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        maxz = arcpy.Parameter(
            displayName="Maximum Elevation Value (optional)",
            name="maxz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        max_triangle_edge_length = arcpy.Parameter(
            displayName="Maximum Triangle Edge Length (optional)",
            name="max_triangle_edge_length",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [i, output, resolution, radius, minz, maxz, max_triangle_edge_length]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        resolution = parameters[2].valueAsText
        radius = parameters[3].valueAsText
        minz = parameters[4].valueAsText
        maxz = parameters[5].valueAsText
        max_triangle_edge_length = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_digital_surface_model(i=i, output=output, resolution=resolution, radius=radius, minz=minz, maxz=maxz, max_triangle_edge_length=max_triangle_edge_length)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarEigenvalueFeatures(object):
    def __init__(self):
        self.label = "Lidar Eigenvalue Features"
        self.description = "Calculate eigenvalue-based metrics from a LiDAR point cloud."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR Points",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        num_neighbours = arcpy.Parameter(
            displayName="Number of Neighbours:",
            name="num_neighbours",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")

        radius = arcpy.Parameter(
            displayName="Search Distance:",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [i, num_neighbours, radius]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        num_neighbours = parameters[1].valueAsText
        radius = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_eigenvalue_features(i=i, num_neighbours=num_neighbours, radius=radius)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarElevationSlice(object):
    def __init__(self):
        self.label = "Lidar Elevation Slice"
        self.description = "Outputs all of the points within a LiDAR (LAS) point file that lie between a specified elevation range."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        minz = arcpy.Parameter(
            displayName="Minimum Elevation Value",
            name="minz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        maxz = arcpy.Parameter(
            displayName="Maximum Elevation Value",
            name="maxz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        cls = arcpy.Parameter(
            displayName="Retain but reclass points outside the specified elevation range?",
            name="cls",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        inclassval = arcpy.Parameter(
            displayName="Class Value Assigned to Points Within Range (Optional)",
            name="inclassval",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        inclassval.value = '2'

        outclassval = arcpy.Parameter(
            displayName="Class Value Assigned to Points Outside Range (Optional)",
            name="outclassval",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        outclassval.value = '1'

        params = [i, output, minz, maxz, cls, inclassval, outclassval]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        minz = parameters[2].valueAsText
        maxz = parameters[3].valueAsText
        cls = parameters[4].valueAsText
        inclassval = parameters[5].valueAsText
        outclassval = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_elevation_slice(i=i, output=output, minz=minz, maxz=maxz, cls=cls, inclassval=inclassval, outclassval=outclassval)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarGroundPointFilter(object):
    def __init__(self):
        self.label = "Lidar Ground Point Filter"
        self.description = "Identifies ground points within LiDAR dataset using a slope-based method."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        radius = arcpy.Parameter(
            displayName="Search Radius",
            name="radius",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        radius.value = '2.0'

        min_neighbours = arcpy.Parameter(
            displayName="Minimum Number of Neighbours",
            name="min_neighbours",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_neighbours.value = '0'

        slope_threshold = arcpy.Parameter(
            displayName="Inter-point Slope Threshold",
            name="slope_threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        slope_threshold.value = '45.0'

        height_threshold = arcpy.Parameter(
            displayName="Off-terrain Point Height Threshold",
            name="height_threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        height_threshold.value = '1.0'

        classify = arcpy.Parameter(
            displayName="Classify Points",
            name="classify",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        classify.value = 'True'

        slope_norm = arcpy.Parameter(
            displayName="Perform initial ground slope normalization?",
            name="slope_norm",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        slope_norm.value = 'True'

        height_above_ground = arcpy.Parameter(
            displayName="Transform output to height above average ground elevation?",
            name="height_above_ground",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        height_above_ground.value = 'False'

        params = [i, output, radius, min_neighbours, slope_threshold, height_threshold, classify, slope_norm, height_above_ground]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        radius = parameters[2].valueAsText
        min_neighbours = parameters[3].valueAsText
        slope_threshold = parameters[4].valueAsText
        height_threshold = parameters[5].valueAsText
        classify = parameters[6].valueAsText
        slope_norm = parameters[7].valueAsText
        height_above_ground = parameters[8].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_ground_point_filter(i=i, output=output, radius=radius, min_neighbours=min_neighbours, slope_threshold=slope_threshold, height_threshold=height_threshold, classify=classify, slope_norm=slope_norm, height_above_ground=height_above_ground)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarHexBinning(object):
    def __init__(self):
        self.label = "Lidar Hex Binning"
        self.description = "Hex-bins a set of LiDAR points."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Base File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        width = arcpy.Parameter(
            displayName="Hexagon Width",
            name="width",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        orientation = arcpy.Parameter(
            displayName="Grid Orientation",
            name="orientation",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        orientation.filter.type = "ValueList"
        orientation.filter.list = ['horizontal', 'vertical']
        orientation.value = 'horizontal'

        params = [i, output, width, orientation]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        width = parameters[2].valueAsText
        orientation = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_hex_binning(i=i, output=output, width=width, orientation=orientation)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarHillshade(object):
    def __init__(self):
        self.label = "Lidar Hillshade"
        self.description = "Calculates a hillshade value for points within a LAS file and stores these data in the RGB field."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        azimuth = arcpy.Parameter(
            displayName="Azimuth (degrees)",
            name="azimuth",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        azimuth.value = '315.0'

        altitude = arcpy.Parameter(
            displayName="Altitude (degrees)",
            name="altitude",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        altitude.value = '30.0'

        radius = arcpy.Parameter(
            displayName="Search Radius",
            name="radius",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        radius.value = '1.0'

        params = [i, output, azimuth, altitude, radius]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        azimuth = parameters[2].valueAsText
        altitude = parameters[3].valueAsText
        radius = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_hillshade(i=i, output=output, azimuth=azimuth, altitude=altitude, radius=radius)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarHistogram(object):
    def __init__(self):
        self.label = "Lidar Histogram"
        self.description = "Creates a histogram of LiDAR data."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        parameter = arcpy.Parameter(
            displayName="Parameter",
            name="parameter",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        parameter.filter.type = "ValueList"
        parameter.filter.list = ['elevation', 'intensity', 'scan angle', 'class', 'time']
        parameter.value = 'elevation'

        clip = arcpy.Parameter(
            displayName="Tail Clip Percent",
            name="clip",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        clip.value = '1.0'

        params = [i, output, parameter, clip]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        parameter = parameters[2].valueAsText
        clip = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_histogram(i=i, output=output, parameter=parameter, clip=clip)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarIdwInterpolation(object):
    def __init__(self):
        self.label = "Lidar Idw Interpolation"
        self.description = "Interpolates LAS files using an inverse-distance weighted (IDW) scheme. When the input/output parameters are not specified, the tool interpolates all LAS files contained within the working directory."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        parameter = arcpy.Parameter(
            displayName="Interpolation Parameter",
            name="parameter",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        parameter.filter.type = "ValueList"
        parameter.filter.list = ['elevation', 'intensity', 'class', 'return_number', 'number_of_returns', 'scan angle', 'rgb', 'user data']
        parameter.value = 'elevation'

        returns = arcpy.Parameter(
            displayName="Point Returns Included",
            name="returns",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        returns.filter.type = "ValueList"
        returns.filter.list = ['all', 'last', 'first']
        returns.value = 'all'

        resolution = arcpy.Parameter(
            displayName="Grid Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        resolution.value = '1.0'

        weight = arcpy.Parameter(
            displayName="IDW Weight (Exponent) Value",
            name="weight",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        weight.value = '1.0'

        radius = arcpy.Parameter(
            displayName="Search Radius",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        radius.value = '2.5'

        exclude_cls = arcpy.Parameter(
            displayName="Exclusion Classes (0-18, based on LAS spec; e.g. 3,4,5,6,7)",
            name="exclude_cls",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")

        minz = arcpy.Parameter(
            displayName="Minimum Elevation Value (optional)",
            name="minz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        maxz = arcpy.Parameter(
            displayName="Maximum Elevation Value (optional)",
            name="maxz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [i, output, parameter, returns, resolution, weight, radius, exclude_cls, minz, maxz]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        parameter = parameters[2].valueAsText
        returns = parameters[3].valueAsText
        resolution = parameters[4].valueAsText
        weight = parameters[5].valueAsText
        radius = parameters[6].valueAsText
        exclude_cls = parameters[7].valueAsText
        minz = parameters[8].valueAsText
        maxz = parameters[9].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_idw_interpolation(i=i, output=output, parameter=parameter, returns=returns, resolution=resolution, weight=weight, radius=radius, exclude_cls=exclude_cls, minz=minz, maxz=maxz)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarInfo(object):
    def __init__(self):
        self.label = "Lidar Info"
        self.description = "Prints information about a LiDAR (LAS) dataset, including header, point return frequency, and classification data and information about the variable length records (VLRs) and geokeys."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output Summary Report File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        density = arcpy.Parameter(
            displayName="Calculate the average point density and nominal point spacing?",
            name="density",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        density.value = 'True'

        vlr = arcpy.Parameter(
            displayName="Print the variable length records (VLRs)?",
            name="vlr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        vlr.value = 'True'

        geokeys = arcpy.Parameter(
            displayName="Print the geokeys?",
            name="geokeys",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        geokeys.value = 'True'

        params = [i, output, density, vlr, geokeys]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        density = parameters[2].valueAsText
        vlr = parameters[3].valueAsText
        geokeys = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_info(i=i, output=output, density=density, vlr=vlr, geokeys=geokeys)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarJoin(object):
    def __init__(self):
        self.label = "Lidar Join"
        self.description = "Joins multiple LiDAR (LAS) files into a single LAS file."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input LiDAR Files",
            name="inputs",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True
        inputs.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        params = [inputs, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_join(inputs=inputs, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarKappaIndex(object):
    def __init__(self):
        self.label = "Lidar Kappa Index"
        self.description = "Performs a kappa index of agreement (KIA) analysis on the classifications of two LAS files."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input LiDAR File (Classification)",
            name="input1",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        input1.filter.list = ["las", "zip"]

        input2 = arcpy.Parameter(
            displayName="Input LiDAR File (Reference)",
            name="input2",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        input2.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        class_accuracy = arcpy.Parameter(
            displayName="Output Class Accuracy Raster File",
            name="class_accuracy",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        class_accuracy.filter.list = ["tif"]

        resolution = arcpy.Parameter(
            displayName="Grid Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        resolution.value = '1.0'

        params = [input1, input2, output, class_accuracy, resolution]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        input2 = parameters[1].valueAsText
        output = parameters[2].valueAsText
        class_accuracy = parameters[3].valueAsText
        resolution = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_kappa_index(input1=input1, input2=input2, output=output, class_accuracy=class_accuracy, resolution=resolution)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarNearestNeighbourGridding(object):
    def __init__(self):
        self.label = "Lidar Nearest Neighbour Gridding"
        self.description = "Grids LiDAR files using nearest-neighbour scheme. When the input/output parameters are not specified, the tool grids all LAS files contained within the working directory."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        parameter = arcpy.Parameter(
            displayName="Interpolation Parameter",
            name="parameter",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        parameter.filter.type = "ValueList"
        parameter.filter.list = ['elevation', 'intensity', 'class', 'return_number', 'number_of_returns', 'scan angle', 'rgb', 'user data', 'time']
        parameter.value = 'elevation'

        returns = arcpy.Parameter(
            displayName="Point Returns Included",
            name="returns",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        returns.filter.type = "ValueList"
        returns.filter.list = ['all', 'last', 'first']
        returns.value = 'all'

        resolution = arcpy.Parameter(
            displayName="Grid Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        resolution.value = '1.0'

        radius = arcpy.Parameter(
            displayName="Search Radius",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        radius.value = '2.5'

        exclude_cls = arcpy.Parameter(
            displayName="Exclusion Classes (0-18, based on LAS spec; e.g. 3,4,5,6,7)",
            name="exclude_cls",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")

        minz = arcpy.Parameter(
            displayName="Minimum Elevation Value (optional)",
            name="minz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        maxz = arcpy.Parameter(
            displayName="Maximum Elevation Value (optional)",
            name="maxz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [i, output, parameter, returns, resolution, radius, exclude_cls, minz, maxz]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        parameter = parameters[2].valueAsText
        returns = parameters[3].valueAsText
        resolution = parameters[4].valueAsText
        radius = parameters[5].valueAsText
        exclude_cls = parameters[6].valueAsText
        minz = parameters[7].valueAsText
        maxz = parameters[8].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_nearest_neighbour_gridding(i=i, output=output, parameter=parameter, returns=returns, resolution=resolution, radius=radius, exclude_cls=exclude_cls, minz=minz, maxz=maxz)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarPointDensity(object):
    def __init__(self):
        self.label = "Lidar Point Density"
        self.description = "Calculates the spatial pattern of point density for a LiDAR data set. When the input/output parameters are not specified, the tool grids all LAS files contained within the working directory."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        returns = arcpy.Parameter(
            displayName="Point Returns Included",
            name="returns",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        returns.filter.type = "ValueList"
        returns.filter.list = ['all', 'last', 'first']
        returns.value = 'all'

        resolution = arcpy.Parameter(
            displayName="Grid Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        resolution.value = '1.0'

        radius = arcpy.Parameter(
            displayName="Search Radius",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        radius.value = '2.5'

        exclude_cls = arcpy.Parameter(
            displayName="Exclusion Classes (0-18, based on LAS spec; e.g. 3,4,5,6,7)",
            name="exclude_cls",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")

        minz = arcpy.Parameter(
            displayName="Minimum Elevation Value (optional)",
            name="minz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        maxz = arcpy.Parameter(
            displayName="Maximum Elevation Value (optional)",
            name="maxz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [i, output, returns, resolution, radius, exclude_cls, minz, maxz]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        returns = parameters[2].valueAsText
        resolution = parameters[3].valueAsText
        radius = parameters[4].valueAsText
        exclude_cls = parameters[5].valueAsText
        minz = parameters[6].valueAsText
        maxz = parameters[7].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_point_density(i=i, output=output, returns=returns, resolution=resolution, radius=radius, exclude_cls=exclude_cls, minz=minz, maxz=maxz)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarPointReturnAnalysis(object):
    def __init__(self):
        self.label = "Lidar Point Return Analysis"
        self.description = "This tool performs a quality control check on the return values of points in a LiDAR file."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR Points",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output LiDAR Points",
            name="output",
            datatype="DEFile",
            parameterType="Optional",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_point_return_analysis(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarPointStats(object):
    def __init__(self):
        self.label = "Lidar Point Stats"
        self.description = "Creates several rasters summarizing the distribution of LAS point data. When the input/output parameters are not specified, the tool works on all LAS files contained within the working directory."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        resolution = arcpy.Parameter(
            displayName="Grid Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        resolution.value = '1.0'

        num_points = arcpy.Parameter(
            displayName="Output number of points?",
            name="num_points",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        num_points.value = 'True'

        num_pulses = arcpy.Parameter(
            displayName="Output number of pulses?",
            name="num_pulses",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        avg_points_per_pulse = arcpy.Parameter(
            displayName="Output average number of points per pulse?",
            name="avg_points_per_pulse",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        avg_points_per_pulse.value = 'True'

        z_range = arcpy.Parameter(
            displayName="Output elevation range?",
            name="z_range",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        intensity_range = arcpy.Parameter(
            displayName="Output intensity range?",
            name="intensity_range",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        predom_class = arcpy.Parameter(
            displayName="Output predominant class?",
            name="predom_class",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [i, resolution, num_points, num_pulses, avg_points_per_pulse, z_range, intensity_range, predom_class]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        resolution = parameters[1].valueAsText
        num_points = parameters[2].valueAsText
        num_pulses = parameters[3].valueAsText
        avg_points_per_pulse = parameters[4].valueAsText
        z_range = parameters[5].valueAsText
        intensity_range = parameters[6].valueAsText
        predom_class = parameters[7].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_point_stats(i=i, resolution=resolution, num_points=num_points, num_pulses=num_pulses, avg_points_per_pulse=avg_points_per_pulse, z_range=z_range, intensity_range=intensity_range, predom_class=predom_class)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarRansacPlanes(object):
    def __init__(self):
        self.label = "Lidar Ransac Planes"
        self.description = "Performs a RANSAC analysis to identify points within a LiDAR point cloud that belong to linear planes."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        radius = arcpy.Parameter(
            displayName="Search Radius",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        radius.value = '2.0'

        num_iter = arcpy.Parameter(
            displayName="Number of Iterations",
            name="num_iter",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        num_iter.value = '50'

        num_samples = arcpy.Parameter(
            displayName="Number of Sample Points",
            name="num_samples",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        num_samples.value = '5'

        threshold = arcpy.Parameter(
            displayName="Inlier Threshold",
            name="threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        threshold.value = '0.35'

        model_size = arcpy.Parameter(
            displayName="Acceptable Model Size",
            name="model_size",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        model_size.value = '8'

        max_slope = arcpy.Parameter(
            displayName="Maximum Planar Slope",
            name="max_slope",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        max_slope.value = '80.0'

        classify = arcpy.Parameter(
            displayName="Classify Points",
            name="classify",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        classify.value = 'False'

        last_returns = arcpy.Parameter(
            displayName="Last Returns Only",
            name="last_returns",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        last_returns.value = 'False'

        params = [i, output, radius, num_iter, num_samples, threshold, model_size, max_slope, classify, last_returns]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        radius = parameters[2].valueAsText
        num_iter = parameters[3].valueAsText
        num_samples = parameters[4].valueAsText
        threshold = parameters[5].valueAsText
        model_size = parameters[6].valueAsText
        max_slope = parameters[7].valueAsText
        classify = parameters[8].valueAsText
        last_returns = parameters[9].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_ransac_planes(i=i, output=output, radius=radius, num_iter=num_iter, num_samples=num_samples, threshold=threshold, model_size=model_size, max_slope=max_slope, classify=classify, last_returns=last_returns)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarRbfInterpolation(object):
    def __init__(self):
        self.label = "Lidar Rbf Interpolation"
        self.description = "Interpolates LAS files using a radial basis function (RBF) scheme. When the input/output parameters are not specified, the tool interpolates all LAS files contained within the working directory."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        parameter = arcpy.Parameter(
            displayName="Interpolation Parameter",
            name="parameter",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        parameter.filter.type = "ValueList"
        parameter.filter.list = ['elevation', 'intensity', 'class', 'return_number', 'number_of_returns', 'scan angle', 'rgb', 'user data']
        parameter.value = 'elevation'

        returns = arcpy.Parameter(
            displayName="Point Returns Included",
            name="returns",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        returns.filter.type = "ValueList"
        returns.filter.list = ['all', 'last', 'first']
        returns.value = 'all'

        resolution = arcpy.Parameter(
            displayName="Grid Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        resolution.value = '1.0'

        num_points = arcpy.Parameter(
            displayName="Number of Points",
            name="num_points",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        num_points.value = '20'

        exclude_cls = arcpy.Parameter(
            displayName="Exclusion Classes (0-18, based on LAS spec; e.g. 3,4,5,6,7)",
            name="exclude_cls",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")

        minz = arcpy.Parameter(
            displayName="Minimum Elevation Value (optional)",
            name="minz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        maxz = arcpy.Parameter(
            displayName="Maximum Elevation Value (optional)",
            name="maxz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        func_type = arcpy.Parameter(
            displayName="Radial Basis Function Type",
            name="func_type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        func_type.filter.type = "ValueList"
        func_type.filter.list = ['ThinPlateSpline', 'PolyHarmonic', 'Gaussian', 'MultiQuadric', 'InverseMultiQuadric']
        func_type.value = 'ThinPlateSpline'

        poly_order = arcpy.Parameter(
            displayName="Polynomial Order",
            name="poly_order",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        poly_order.filter.type = "ValueList"
        poly_order.filter.list = ['none', 'constant', 'affine']
        poly_order.value = 'none'

        weight = arcpy.Parameter(
            displayName="Weight",
            name="weight",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        weight.value = '5'

        params = [i, output, parameter, returns, resolution, num_points, exclude_cls, minz, maxz, func_type, poly_order, weight]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        parameter = parameters[2].valueAsText
        returns = parameters[3].valueAsText
        resolution = parameters[4].valueAsText
        num_points = parameters[5].valueAsText
        exclude_cls = parameters[6].valueAsText
        minz = parameters[7].valueAsText
        maxz = parameters[8].valueAsText
        func_type = parameters[9].valueAsText
        poly_order = parameters[10].valueAsText
        weight = parameters[11].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_rbf_interpolation(i=i, output=output, parameter=parameter, returns=returns, resolution=resolution, num_points=num_points, exclude_cls=exclude_cls, minz=minz, maxz=maxz, func_type=func_type, poly_order=poly_order, weight=weight)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarRemoveDuplicates(object):
    def __init__(self):
        self.label = "Lidar Remove Duplicates"
        self.description = "Removes duplicate points from a LiDAR data set."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        include_z = arcpy.Parameter(
            displayName="Include z-values in point comparison?",
            name="include_z",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        include_z.value = 'False'

        params = [i, output, include_z]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        include_z = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_remove_duplicates(i=i, output=output, include_z=include_z)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarRemoveOutliers(object):
    def __init__(self):
        self.label = "Lidar Remove Outliers"
        self.description = "Removes outliers (high and low points) in a LiDAR point cloud."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        radius = arcpy.Parameter(
            displayName="Search Radius",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        radius.value = '2.0'

        elev_diff = arcpy.Parameter(
            displayName="Max. Elevation Difference",
            name="elev_diff",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        elev_diff.value = '50.0'

        use_median = arcpy.Parameter(
            displayName="Use difference from median elevation?",
            name="use_median",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        classify = arcpy.Parameter(
            displayName="Classify Points",
            name="classify",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        classify.value = 'True'

        params = [i, output, radius, elev_diff, use_median, classify]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        radius = parameters[2].valueAsText
        elev_diff = parameters[3].valueAsText
        use_median = parameters[4].valueAsText
        classify = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_remove_outliers(i=i, output=output, radius=radius, elev_diff=elev_diff, use_median=use_median, classify=classify)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarRooftopAnalysis(object):
    def __init__(self):
        self.label = "Lidar Rooftop Analysis"
        self.description = "Identifies roof segments in a LiDAR point cloud."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        buildings = arcpy.Parameter(
            displayName="Input Building Footprint Polygon File",
            name="buildings",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        buildings.filter.list = ["Polygon"]

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        radius = arcpy.Parameter(
            displayName="Search Radius",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        radius.value = '2.0'

        num_iter = arcpy.Parameter(
            displayName="Number of Iterations",
            name="num_iter",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        num_iter.value = '50'

        num_samples = arcpy.Parameter(
            displayName="Number of Sample Points",
            name="num_samples",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        num_samples.value = '10'

        threshold = arcpy.Parameter(
            displayName="Inlier Threshold",
            name="threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        threshold.value = '0.15'

        model_size = arcpy.Parameter(
            displayName="Acceptable Model Size (points)",
            name="model_size",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        model_size.value = '15'

        max_slope = arcpy.Parameter(
            displayName="Maximum Planar Slope (degrees)",
            name="max_slope",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        max_slope.value = '65.0'

        norm_diff = arcpy.Parameter(
            displayName="Normal Difference Threshold (degrees)",
            name="norm_diff",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        norm_diff.value = '10.0'

        azimuth = arcpy.Parameter(
            displayName="Azimuth (degrees)",
            name="azimuth",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        azimuth.value = '180.0'

        altitude = arcpy.Parameter(
            displayName="Altitude (degrees)",
            name="altitude",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        altitude.value = '30.0'

        params = [i, buildings, output, radius, num_iter, num_samples, threshold, model_size, max_slope, norm_diff, azimuth, altitude]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        buildings = parameters[1].valueAsText
        if buildings is not None:
            desc = arcpy.Describe(buildings)
            buildings = desc.catalogPath
        output = parameters[2].valueAsText
        radius = parameters[3].valueAsText
        num_iter = parameters[4].valueAsText
        num_samples = parameters[5].valueAsText
        threshold = parameters[6].valueAsText
        model_size = parameters[7].valueAsText
        max_slope = parameters[8].valueAsText
        norm_diff = parameters[9].valueAsText
        azimuth = parameters[10].valueAsText
        altitude = parameters[11].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_rooftop_analysis(i=i, buildings=buildings, output=output, radius=radius, num_iter=num_iter, num_samples=num_samples, threshold=threshold, model_size=model_size, max_slope=max_slope, norm_diff=norm_diff, azimuth=azimuth, altitude=altitude)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarSegmentation(object):
    def __init__(self):
        self.label = "Lidar Segmentation"
        self.description = "Segments a LiDAR point cloud based on differences in the orientation of fitted planar surfaces and point proximity."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        radius = arcpy.Parameter(
            displayName="Search Radius",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        radius.value = '2.0'

        num_iter = arcpy.Parameter(
            displayName="Number of Iterations",
            name="num_iter",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        num_iter.value = '50'

        num_samples = arcpy.Parameter(
            displayName="Number of Sample Points",
            name="num_samples",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        num_samples.value = '10'

        threshold = arcpy.Parameter(
            displayName="Inlier Threshold",
            name="threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        threshold.value = '0.15'

        model_size = arcpy.Parameter(
            displayName="Acceptable Model Size",
            name="model_size",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        model_size.value = '15'

        max_slope = arcpy.Parameter(
            displayName="Maximum Planar Slope",
            name="max_slope",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        max_slope.value = '80.0'

        norm_diff = arcpy.Parameter(
            displayName="Normal Difference Threshold",
            name="norm_diff",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        norm_diff.value = '10.0'

        maxzdiff = arcpy.Parameter(
            displayName="Maximum Elevation Difference Between Points",
            name="maxzdiff",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        maxzdiff.value = '1.0'

        classes = arcpy.Parameter(
            displayName="Don't cross class boundaries?",
            name="classes",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        classes.value = 'False'

        ground = arcpy.Parameter(
            displayName="Classify largest segment as ground?",
            name="ground",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        ground.value = 'False'

        params = [i, output, radius, num_iter, num_samples, threshold, model_size, max_slope, norm_diff, maxzdiff, classes, ground]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        radius = parameters[2].valueAsText
        num_iter = parameters[3].valueAsText
        num_samples = parameters[4].valueAsText
        threshold = parameters[5].valueAsText
        model_size = parameters[6].valueAsText
        max_slope = parameters[7].valueAsText
        norm_diff = parameters[8].valueAsText
        maxzdiff = parameters[9].valueAsText
        classes = parameters[10].valueAsText
        ground = parameters[11].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_segmentation(i=i, output=output, radius=radius, num_iter=num_iter, num_samples=num_samples, threshold=threshold, model_size=model_size, max_slope=max_slope, norm_diff=norm_diff, maxzdiff=maxzdiff, classes=classes, ground=ground)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarSegmentationBasedFilter(object):
    def __init__(self):
        self.label = "Lidar Segmentation Based Filter"
        self.description = "Identifies ground points within LiDAR point clouds using a segmentation based approach."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        radius = arcpy.Parameter(
            displayName="Search Radius",
            name="radius",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        radius.value = '5.0'

        norm_diff = arcpy.Parameter(
            displayName="Normal Difference Threshold",
            name="norm_diff",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        norm_diff.value = '2.0'

        maxzdiff = arcpy.Parameter(
            displayName="Maximum Elevation Difference Between Points",
            name="maxzdiff",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        maxzdiff.value = '1.0'

        classify = arcpy.Parameter(
            displayName="Classify Points",
            name="classify",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [i, output, radius, norm_diff, maxzdiff, classify]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        radius = parameters[2].valueAsText
        norm_diff = parameters[3].valueAsText
        maxzdiff = parameters[4].valueAsText
        classify = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_segmentation_based_filter(i=i, output=output, radius=radius, norm_diff=norm_diff, maxzdiff=maxzdiff, classify=classify)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarShift(object):
    def __init__(self):
        self.label = "Lidar Shift"
        self.description = "Shifts the x,y,z coordinates of a LiDAR file."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR Points",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output LiDAR Points",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        x_shift = arcpy.Parameter(
            displayName="x-shift",
            name="x_shift",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        y_shift = arcpy.Parameter(
            displayName="y-shift",
            name="y_shift",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        z_shift = arcpy.Parameter(
            displayName="z-shift",
            name="z_shift",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        params = [i, output, x_shift, y_shift, z_shift]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        x_shift = parameters[2].valueAsText
        y_shift = parameters[3].valueAsText
        z_shift = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_shift(i=i, output=output, x_shift=x_shift, y_shift=y_shift, z_shift=z_shift)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarSibsonInterpolation(object):
    def __init__(self):
        self.label = "Lidar Sibson Interpolation"
        self.description = "This tool interpolates one or more LiDAR tiles using Sibson's natural neighbour method."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR Points",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output Raster",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        parameter = arcpy.Parameter(
            displayName="Interpolation Parameter",
            name="parameter",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        parameter.filter.type = "ValueList"
        parameter.filter.list = ['elevation', 'intensity', 'class', 'return_number', 'number_of_returns', 'scan_angle', 'user_data']
        parameter.value = 'elevation'

        returns = arcpy.Parameter(
            displayName="Point Returns Included",
            name="returns",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        returns.filter.type = "ValueList"
        returns.filter.list = ['all', 'last', 'first']
        returns.value = 'all'

        resolution = arcpy.Parameter(
            displayName="Output Grid Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        resolution.value = '1.0'

        exclude_cls = arcpy.Parameter(
            displayName="Exclusion Classes (0-18, based on LAS spec; e.g. 3,4,5,6,7)",
            name="exclude_cls",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")

        minz = arcpy.Parameter(
            displayName="Minimum Elevation Value (optional)",
            name="minz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        maxz = arcpy.Parameter(
            displayName="Maximum Elevation Value (optional)",
            name="maxz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [i, output, parameter, returns, resolution, exclude_cls, minz, maxz]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        parameter = parameters[2].valueAsText
        returns = parameters[3].valueAsText
        resolution = parameters[4].valueAsText
        exclude_cls = parameters[5].valueAsText
        minz = parameters[6].valueAsText
        maxz = parameters[7].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_sibson_interpolation(i=i, output=output, parameter=parameter, returns=returns, resolution=resolution, exclude_cls=exclude_cls, minz=minz, maxz=maxz)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarTinGridding(object):
    def __init__(self):
        self.label = "Lidar Tin Gridding"
        self.description = "Creates a raster grid based on a Delaunay triangular irregular network (TIN) fitted to LiDAR points."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        parameter = arcpy.Parameter(
            displayName="Interpolation Parameter",
            name="parameter",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        parameter.filter.type = "ValueList"
        parameter.filter.list = ['elevation', 'intensity', 'class', 'return_number', 'number_of_returns', 'scan angle', 'rgb', 'user data']
        parameter.value = 'elevation'

        returns = arcpy.Parameter(
            displayName="Point Returns Included",
            name="returns",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        returns.filter.type = "ValueList"
        returns.filter.list = ['all', 'last', 'first']
        returns.value = 'all'

        resolution = arcpy.Parameter(
            displayName="Grid Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        resolution.value = '1.0'

        exclude_cls = arcpy.Parameter(
            displayName="Exclusion Classes (0-18, based on LAS spec; e.g. 3,4,5,6,7)",
            name="exclude_cls",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        exclude_cls.value = '7,18'

        minz = arcpy.Parameter(
            displayName="Minimum Elevation Value (optional)",
            name="minz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        maxz = arcpy.Parameter(
            displayName="Maximum Elevation Value (optional)",
            name="maxz",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        max_triangle_edge_length = arcpy.Parameter(
            displayName="Maximum Triangle Edge Length (optional)",
            name="max_triangle_edge_length",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [i, output, parameter, returns, resolution, exclude_cls, minz, maxz, max_triangle_edge_length]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        parameter = parameters[2].valueAsText
        returns = parameters[3].valueAsText
        resolution = parameters[4].valueAsText
        exclude_cls = parameters[5].valueAsText
        minz = parameters[6].valueAsText
        maxz = parameters[7].valueAsText
        max_triangle_edge_length = parameters[8].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_tin_gridding(i=i, output=output, parameter=parameter, returns=returns, resolution=resolution, exclude_cls=exclude_cls, minz=minz, maxz=maxz, max_triangle_edge_length=max_triangle_edge_length)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarThin(object):
    def __init__(self):
        self.label = "Lidar Thin"
        self.description = "Thins a LiDAR point cloud, reducing point density."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        resolution = arcpy.Parameter(
            displayName="Sample Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        resolution.value = '2.0'

        method = arcpy.Parameter(
            displayName="Point Selection Method",
            name="method",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        method.filter.type = "ValueList"
        method.filter.list = ['first', 'last', 'lowest', 'highest', 'nearest']
        method.value = 'lowest'

        save_filtered = arcpy.Parameter(
            displayName="Save filtered points to separate file?",
            name="save_filtered",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        save_filtered.value = 'False'

        params = [i, output, resolution, method, save_filtered]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        resolution = parameters[2].valueAsText
        method = parameters[3].valueAsText
        save_filtered = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_thin(i=i, output=output, resolution=resolution, method=method, save_filtered=save_filtered)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarThinHighDensity(object):
    def __init__(self):
        self.label = "Lidar Thin High Density"
        self.description = "Thins points from high density areas within a LiDAR point cloud."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        resolution = arcpy.Parameter(
            displayName="Grid Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        resolution.value = '1.0'

        density = arcpy.Parameter(
            displayName="Max. Point Density (pts/m^2)",
            name="density",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        save_filtered = arcpy.Parameter(
            displayName="Save filtered points to separate file?",
            name="save_filtered",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        save_filtered.value = 'False'

        params = [i, output, resolution, density, save_filtered]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        resolution = parameters[2].valueAsText
        density = parameters[3].valueAsText
        save_filtered = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_thin_high_density(i=i, output=output, resolution=resolution, density=density, save_filtered=save_filtered)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarTile(object):
    def __init__(self):
        self.label = "Lidar Tile"
        self.description = "Tiles a LiDAR LAS file into multiple LAS files."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        width = arcpy.Parameter(
            displayName="Tile Width",
            name="width",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        width.value = '1000.0'

        height = arcpy.Parameter(
            displayName="Tile Height",
            name="height",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        height.value = '1000.0'

        origin_x = arcpy.Parameter(
            displayName="Origin Point X-Coordinate",
            name="origin_x",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        origin_x.value = '0.0'

        origin_y = arcpy.Parameter(
            displayName="Origin Point Y-Coordinate",
            name="origin_y",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        origin_y.value = '0.0'

        min_points = arcpy.Parameter(
            displayName="Minimum Number of Tile Points",
            name="min_points",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_points.value = '2'

        params = [i, width, height, origin_x, origin_y, min_points]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        width = parameters[1].valueAsText
        height = parameters[2].valueAsText
        origin_x = parameters[3].valueAsText
        origin_y = parameters[4].valueAsText
        min_points = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_tile(i=i, width=width, height=height, origin_x=origin_x, origin_y=origin_y, min_points=min_points)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarTileFootprint(object):
    def __init__(self):
        self.label = "Lidar Tile Footprint"
        self.description = "Creates a vector polygon of the convex hull of a LiDAR point cloud. When the input/output parameters are not specified, the tool works with all LAS files contained within the working directory."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        hull = arcpy.Parameter(
            displayName="Create Convex Hull Around Points",
            name="hull",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        hull.value = 'False'

        params = [i, output, hull]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        hull = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_tile_footprint(i=i, output=output, hull=hull)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LidarTophatTransform(object):
    def __init__(self):
        self.label = "Lidar Tophat Transform"
        self.description = "Performs a white top-hat transform on a Lidar dataset; as an estimate of height above ground, this is useful for modelling the vegetation canopy."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        radius = arcpy.Parameter(
            displayName="Search Radius",
            name="radius",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        radius.value = '1.0'

        params = [i, output, radius]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        radius = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lidar_tophat_transform(i=i, output=output, radius=radius)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LineDetectionFilter(object):
    def __init__(self):
        self.label = "Line Detection Filter"
        self.description = "Performs a line-detection filter on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        variant = arcpy.Parameter(
            displayName="Variant",
            name="variant",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        variant.filter.type = "ValueList"
        variant.filter.list = ['vertical', 'horizontal', '45', '135']
        variant.value = 'vertical'

        absvals = arcpy.Parameter(
            displayName="Output absolute values?",
            name="absvals",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        clip = arcpy.Parameter(
            displayName="Distribution Tail Clip Amount (%)",
            name="clip",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        clip.value = '0.0'

        params = [i, output, variant, absvals, clip]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        variant = parameters[2].valueAsText
        absvals = parameters[3].valueAsText
        clip = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.line_detection_filter(i=i, output=output, variant=variant, absvals=absvals, clip=clip)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LineIntersections(object):
    def __init__(self):
        self.label = "Line Intersections"
        self.description = "Identifies points where the features of two vector line layers intersect."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input Vector Lines File",
            name="input1",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        input1.filter.list = ["Polyline", "Polygon"]

        input2 = arcpy.Parameter(
            displayName="Input Vector Lines File",
            name="input2",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        input2.filter.list = ["Polyline", "Polygon"]

        output = arcpy.Parameter(
            displayName="Output Vector Point File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.line_intersections(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LineThinning(object):
    def __init__(self):
        self.label = "Line Thinning"
        self.description = "Performs line thinning a on Boolean raster image; intended to be used with the RemoveSpurs tool."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.line_thinning(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LinearityIndex(object):
    def __init__(self):
        self.label = "Linearity Index"
        self.description = "Calculates the linearity index for vector polygons."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.linearity_index(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LinesToPolygons(object):
    def __init__(self):
        self.label = "Lines To Polygons"
        self.description = "Converts vector polylines to polygons."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Line File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polyline"]

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lines_to_polygons(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ListUniqueValues(object):
    def __init__(self):
        self.label = "List Unique Values"
        self.description = "Lists the unique values contained in a field within a vector's attribute table."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        field = arcpy.Parameter(
            displayName="Field Name",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [i.name]

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [i, field, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.list_unique_values(i=i, field=field, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ListUniqueValuesRaster(object):
    def __init__(self):
        self.label = "List Unique Values Raster"
        self.description = "Lists the unique values contained in a field within a vector's attribute table."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.list_unique_values_raster(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Ln(object):
    def __init__(self):
        self.label = "Ln"
        self.description = "Returns the natural logarithm of values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.ln(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LocalHypsometricAnalysis(object):
    def __init__(self):
        self.label = "Local Hypsometric Analysis"
        self.description = "This tool calculates a local, neighbourhood-based hypsometric integral raster."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster DEM",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        out_mag = arcpy.Parameter(
            displayName="Output Magnitude Raster",
            name="out_mag",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_mag.filter.list = ["tif"]

        out_scale = arcpy.Parameter(
            displayName="Output Scale Raster",
            name="out_scale",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_scale.filter.list = ["tif"]

        min_scale = arcpy.Parameter(
            displayName="Minimum Search Neighbourhood Radius (grid cells)",
            name="min_scale",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_scale.value = '4'

        step = arcpy.Parameter(
            displayName="Base Step Size",
            name="step",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        step.value = '1'

        num_steps = arcpy.Parameter(
            displayName="Number of Steps",
            name="num_steps",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        num_steps.value = '10'

        step_nonlinearity = arcpy.Parameter(
            displayName="Step Nonlinearity",
            name="step_nonlinearity",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        step_nonlinearity.value = '1.0'

        params = [i, out_mag, out_scale, min_scale, step, num_steps, step_nonlinearity]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        out_mag = parameters[1].valueAsText
        out_scale = parameters[2].valueAsText
        min_scale = parameters[3].valueAsText
        step = parameters[4].valueAsText
        num_steps = parameters[5].valueAsText
        step_nonlinearity = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.local_hypsometric_analysis(i=i, out_mag=out_mag, out_scale=out_scale, min_scale=min_scale, step=step, num_steps=num_steps, step_nonlinearity=step_nonlinearity)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LocalQuadraticRegression(object):
    def __init__(self):
        self.label = "Local Quadratic Regression"
        self.description = "An implementation of the constrained quadratic regression algorithm using a flexible window size described in Wood (1996)."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM Raster",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filter = arcpy.Parameter(
            displayName="Filter Edge Length",
            name="filter",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filter.value = '3'

        params = [dem, output, filter]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        filter = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.local_quadratic_regression(dem=dem, output=output, filter=filter)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Log10(object):
    def __init__(self):
        self.label = "Log10"
        self.description = "Returns the base-10 logarithm of values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.log10(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Log2(object):
    def __init__(self):
        self.label = "Log2"
        self.description = "Returns the base-2 logarithm of values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.log2(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LogisticRegression(object):
    def __init__(self):
        self.label = "Logistic Regression"
        self.description = "Performs a logistic regression analysis using training site polygons/points and predictor rasters."
        self.category = "Machine Learning"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Predictor Rasters",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        scaling = arcpy.Parameter(
            displayName="Scaling Method",
            name="scaling",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        scaling.filter.type = "ValueList"
        scaling.filter.list = ['None', 'Normalize', 'Standardize']
        scaling.value = 'Normalize'

        training = arcpy.Parameter(
            displayName="Input Training Polygons/Points",
            name="training",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        field = arcpy.Parameter(
            displayName="Class Field Name",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [training.name]

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        test_proportion = arcpy.Parameter(
            displayName="Test Proportion",
            name="test_proportion",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        test_proportion.value = '0.2'

        params = [inputs, scaling, training, field, output, test_proportion]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        scaling = parameters[1].valueAsText
        training = parameters[2].valueAsText
        if training is not None:
            desc = arcpy.Describe(training)
            training = desc.catalogPath
        field = parameters[3].valueAsText
        output = parameters[4].valueAsText
        test_proportion = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.logistic_regression(inputs=inputs, scaling=scaling, training=training, field=field, output=output, test_proportion=test_proportion)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LongProfile(object):
    def __init__(self):
        self.label = "Long Profile"
        self.description = "Plots the stream longitudinal profiles for one or more rivers."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [d8_pntr, streams, dem, output, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        dem = parameters[2].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[3].valueAsText
        esri_pntr = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.long_profile(d8_pntr=d8_pntr, streams=streams, dem=dem, output=output, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LongProfileFromPoints(object):
    def __init__(self):
        self.label = "Long Profile From Points"
        self.description = "Plots the longitudinal profiles from flow-paths initiating from a set of vector points."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        points = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="points",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        points.filter.list = ["Point"]

        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [d8_pntr, points, dem, output, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        points = parameters[1].valueAsText
        if points is not None:
            desc = arcpy.Describe(points)
            points = desc.catalogPath
        dem = parameters[2].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[3].valueAsText
        esri_pntr = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.long_profile_from_points(d8_pntr=d8_pntr, points=points, dem=dem, output=output, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LongestFlowpath(object):
    def __init__(self):
        self.label = "Longest Flowpath"
        self.description = "Delineates the longest flowpaths for a group of subbasins or watersheds."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        basins = arcpy.Parameter(
            displayName="Basins File",
            name="basins",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [dem, basins, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        basins = parameters[1].valueAsText
        if basins is not None:
            desc = arcpy.Describe(basins)
            basins = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.longest_flowpath(dem=dem, basins=basins, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LowPointsOnHeadwaterDivides(object):
    def __init__(self):
        self.label = "Low Points On Headwater Divides"
        self.description = "This tool locates saddle points along ridges within a digital elevation model (DEM)"
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM Raster",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams Raster",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [dem, streams, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.low_points_on_headwater_divides(dem=dem, streams=streams, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class LowestPosition(object):
    def __init__(self):
        self.label = "Lowest Position"
        self.description = "Identifies the stack position of the minimum value within a raster stack on a cell-by-cell basis."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [inputs, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.lowest_position(inputs=inputs, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MdInfFlowAccumulation(object):
    def __init__(self):
        self.label = "Md Inf Flow Accumulation"
        self.description = "Calculates an FD8 flow accumulation raster from an input DEM."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        out_type = arcpy.Parameter(
            displayName="Output Type",
            name="out_type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        out_type.filter.type = "ValueList"
        out_type.filter.list = ['cells', 'specific contributing area', 'catchment area']
        out_type.value = 'specific contributing area'

        exponent = arcpy.Parameter(
            displayName="Exponent Parameter",
            name="exponent",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        exponent.value = '1.1'

        threshold = arcpy.Parameter(
            displayName="Convergence Threshold (grid cells; blank for none)",
            name="threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        clip = arcpy.Parameter(
            displayName="Clip the upper tail by 1%?",
            name="clip",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, out_type, exponent, threshold, log, clip]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        out_type = parameters[2].valueAsText
        exponent = parameters[3].valueAsText
        threshold = parameters[4].valueAsText
        log = parameters[5].valueAsText
        clip = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.md_inf_flow_accumulation(dem=dem, output=output, out_type=out_type, exponent=exponent, threshold=threshold, log=log, clip=clip)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MajorityFilter(object):
    def __init__(self):
        self.label = "Majority Filter"
        self.description = "Assigns each cell in the output grid the most frequently occurring value (mode) in a moving window centred on each grid cell in the input raster."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        params = [i, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.majority_filter(i=i, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MapOffTerrainObjects(object):
    def __init__(self):
        self.label = "Map Off Terrain Objects"
        self.description = "Maps off-terrain objects in a digital elevation model (DEM)."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        max_slope = arcpy.Parameter(
            displayName="Maximum Slope",
            name="max_slope",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        max_slope.value = '40.0'

        min_size = arcpy.Parameter(
            displayName="Minimum Feature Size",
            name="min_size",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        min_size.value = '1'

        params = [dem, output, max_slope, min_size]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        max_slope = parameters[2].valueAsText
        min_size = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.map_off_terrain_objects(dem=dem, output=output, max_slope=max_slope, min_size=min_size)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Max(object):
    def __init__(self):
        self.label = "Max"
        self.description = "Performs a MAX operation on two rasters or a raster and a constant value."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input1",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            try:
                input1 = str(float(input1))
            except:
                desc = arcpy.Describe(input1)
                input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.max(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MaxAbsoluteOverlay(object):
    def __init__(self):
        self.label = "Max Absolute Overlay"
        self.description = "Evaluates the maximum absolute value for each grid cell from a stack of input rasters."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [inputs, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.max_absolute_overlay(inputs=inputs, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MaxAnisotropyDev(object):
    def __init__(self):
        self.label = "Max Anisotropy Dev"
        self.description = "Calculates the maximum anisotropy (directionality) in elevation deviation over a range of spatial scales."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        out_mag = arcpy.Parameter(
            displayName="Output DEVmax Magnitude File",
            name="out_mag",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_mag.filter.list = ["tif"]

        out_scale = arcpy.Parameter(
            displayName="Output DEVmax Scale File",
            name="out_scale",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_scale.filter.list = ["tif"]

        min_scale = arcpy.Parameter(
            displayName="Minimum Search Neighbourhood Radius (grid cells)",
            name="min_scale",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        min_scale.value = '3'

        max_scale = arcpy.Parameter(
            displayName="Maximum Search Neighbourhood Radius (grid cells)",
            name="max_scale",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")

        step = arcpy.Parameter(
            displayName="Step Size",
            name="step",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        step.value = '2'

        params = [dem, out_mag, out_scale, min_scale, max_scale, step]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        out_mag = parameters[1].valueAsText
        out_scale = parameters[2].valueAsText
        min_scale = parameters[3].valueAsText
        max_scale = parameters[4].valueAsText
        step = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.max_anisotropy_dev(dem=dem, out_mag=out_mag, out_scale=out_scale, min_scale=min_scale, max_scale=max_scale, step=step)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MaxAnisotropyDevSignature(object):
    def __init__(self):
        self.label = "Max Anisotropy Dev Signature"
        self.description = "Calculates the anisotropy in deviation from mean for points over a range of spatial scales."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        points = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="points",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        points.filter.list = ["Point"]

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        min_scale = arcpy.Parameter(
            displayName="Minimum Search Neighbourhood Radius (grid cells)",
            name="min_scale",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_scale.value = '1'

        max_scale = arcpy.Parameter(
            displayName="Maximum Search Neighbourhood Radius (grid cells)",
            name="max_scale",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")

        step = arcpy.Parameter(
            displayName="Step Size",
            name="step",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        step.value = '1'

        params = [dem, points, output, min_scale, max_scale, step]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        points = parameters[1].valueAsText
        if points is not None:
            desc = arcpy.Describe(points)
            points = desc.catalogPath
        output = parameters[2].valueAsText
        min_scale = parameters[3].valueAsText
        max_scale = parameters[4].valueAsText
        step = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.max_anisotropy_dev_signature(dem=dem, points=points, output=output, min_scale=min_scale, max_scale=max_scale, step=step)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MaxBranchLength(object):
    def __init__(self):
        self.label = "Max Branch Length"
        self.description = "Lindsay and Seibert's (2013) branch length index is used to map drainage divides or ridge lines."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, log]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.max_branch_length(dem=dem, output=output, log=log)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MaxDifferenceFromMean(object):
    def __init__(self):
        self.label = "Max Difference From Mean"
        self.description = "Calculates the maximum difference from mean elevation over a range of spatial scales."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        out_mag = arcpy.Parameter(
            displayName="Output DIFFmax Magnitude File",
            name="out_mag",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_mag.filter.list = ["tif"]

        out_scale = arcpy.Parameter(
            displayName="Output DIFFmax Scale File",
            name="out_scale",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_scale.filter.list = ["tif"]

        min_scale = arcpy.Parameter(
            displayName="Minimum Search Neighbourhood Radius (grid cells)",
            name="min_scale",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")

        max_scale = arcpy.Parameter(
            displayName="Maximum Search Neighbourhood Radius (grid cells)",
            name="max_scale",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")

        step = arcpy.Parameter(
            displayName="Step Size",
            name="step",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        step.value = '1'

        params = [dem, out_mag, out_scale, min_scale, max_scale, step]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        out_mag = parameters[1].valueAsText
        out_scale = parameters[2].valueAsText
        min_scale = parameters[3].valueAsText
        max_scale = parameters[4].valueAsText
        step = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.max_difference_from_mean(dem=dem, out_mag=out_mag, out_scale=out_scale, min_scale=min_scale, max_scale=max_scale, step=step)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MaxDownslopeElevChange(object):
    def __init__(self):
        self.label = "Max Downslope Elev Change"
        self.description = "Calculates the maximum downslope change in elevation between a grid cell and its eight downslope neighbors."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.max_downslope_elev_change(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MaxElevDevSignature(object):
    def __init__(self):
        self.label = "Max Elev Dev Signature"
        self.description = "Calculates the maximum elevation deviation over a range of spatial scales and for a set of points."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        points = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="points",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        points.filter.list = ["Point"]

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        min_scale = arcpy.Parameter(
            displayName="Minimum Search Neighbourhood Radius (grid cells)",
            name="min_scale",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")

        max_scale = arcpy.Parameter(
            displayName="Maximum Search Neighbourhood Radius (grid cells)",
            name="max_scale",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")

        step = arcpy.Parameter(
            displayName="Step Size",
            name="step",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        step.value = '10'

        params = [dem, points, output, min_scale, max_scale, step]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        points = parameters[1].valueAsText
        if points is not None:
            desc = arcpy.Describe(points)
            points = desc.catalogPath
        output = parameters[2].valueAsText
        min_scale = parameters[3].valueAsText
        max_scale = parameters[4].valueAsText
        step = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.max_elev_dev_signature(dem=dem, points=points, output=output, min_scale=min_scale, max_scale=max_scale, step=step)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MaxElevationDeviation(object):
    def __init__(self):
        self.label = "Max Elevation Deviation"
        self.description = "Calculates the maximum elevation deviation over a range of spatial scales."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        out_mag = arcpy.Parameter(
            displayName="Output DEVmax Magnitude File",
            name="out_mag",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_mag.filter.list = ["tif"]

        out_scale = arcpy.Parameter(
            displayName="Output DEVmax Scale File",
            name="out_scale",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_scale.filter.list = ["tif"]

        min_scale = arcpy.Parameter(
            displayName="Minimum Search Neighbourhood Radius (grid cells)",
            name="min_scale",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")

        max_scale = arcpy.Parameter(
            displayName="Maximum Search Neighbourhood Radius (grid cells)",
            name="max_scale",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")

        step = arcpy.Parameter(
            displayName="Step Size",
            name="step",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        step.value = '1'

        params = [dem, out_mag, out_scale, min_scale, max_scale, step]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        out_mag = parameters[1].valueAsText
        out_scale = parameters[2].valueAsText
        min_scale = parameters[3].valueAsText
        max_scale = parameters[4].valueAsText
        step = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.max_elevation_deviation(dem=dem, out_mag=out_mag, out_scale=out_scale, min_scale=min_scale, max_scale=max_scale, step=step)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MaxOverlay(object):
    def __init__(self):
        self.label = "Max Overlay"
        self.description = "Evaluates the maximum value for each grid cell from a stack of input rasters."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [inputs, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.max_overlay(inputs=inputs, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MaxUpslopeElevChange(object):
    def __init__(self):
        self.label = "Max Upslope Elev Change"
        self.description = "Calculates the maximum upslope change in elevation between a grid cell and its eight downslope neighbors."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.max_upslope_elev_change(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MaxUpslopeFlowpathLength(object):
    def __init__(self):
        self.label = "Max Upslope Flowpath Length"
        self.description = "Measures the maximum length of all upslope flowpaths draining each grid cell."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.max_upslope_flowpath_length(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MaxUpslopeValue(object):
    def __init__(self):
        self.label = "Max Upslope Value"
        self.description = "Calculates the maximum upslope value from an input values raster along flowpaths."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        values = arcpy.Parameter(
            displayName="Values Raster File",
            name="values",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, values, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        values = parameters[1].valueAsText
        if values is not None:
            desc = arcpy.Describe(values)
            values = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.max_upslope_value(dem=dem, values=values, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MaximalCurvature(object):
    def __init__(self):
        self.label = "Maximal Curvature"
        self.description = "Calculates a mean curvature raster from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.maximal_curvature(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MaximumFilter(object):
    def __init__(self):
        self.label = "Maximum Filter"
        self.description = "Assigns each cell in the output grid the maximum value in a moving window centred on each grid cell in the input raster."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        params = [i, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.maximum_filter(i=i, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MeanCurvature(object):
    def __init__(self):
        self.label = "Mean Curvature"
        self.description = "Calculates a mean curvature raster from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.mean_curvature(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MeanFilter(object):
    def __init__(self):
        self.label = "Mean Filter"
        self.description = "Performs a mean filter (low-pass filter) on an input image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '3'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '3'

        params = [i, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.mean_filter(i=i, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MedianFilter(object):
    def __init__(self):
        self.label = "Median Filter"
        self.description = "Performs a median filter on an input image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        sig_digits = arcpy.Parameter(
            displayName="Number of Significant Digits",
            name="sig_digits",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        sig_digits.value = '2'

        params = [i, output, filterx, filtery, sig_digits]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        sig_digits = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.median_filter(i=i, output=output, filterx=filterx, filtery=filtery, sig_digits=sig_digits)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Medoid(object):
    def __init__(self):
        self.label = "Medoid"
        self.description = "Calculates the medoid for a series of vector features contained in a shapefile."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.medoid(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MergeLineSegments(object):
    def __init__(self):
        self.label = "Merge Line Segments"
        self.description = "Merges vector line segments into larger features."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polyline"]

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        snap = arcpy.Parameter(
            displayName="Snap Tolerance",
            name="snap",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        snap.value = '0.0'

        params = [i, output, snap]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        snap = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.merge_line_segments(i=i, output=output, snap=snap)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MergeTableWithCsv(object):
    def __init__(self):
        self.label = "Merge Table With Csv"
        self.description = "Merge a vector's attribute table with a table contained within a CSV text file."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Primary Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        pkey = arcpy.Parameter(
            displayName="Primary Key Field",
            name="pkey",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        pkey.parameterDependencies = [i.name]

        csv = arcpy.Parameter(
            displayName="Input CSV File",
            name="csv",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        csv.filter.list = ["csv"]

        fkey = arcpy.Parameter(
            displayName="Foreign Key Field",
            name="fkey",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        fkey.parameterDependencies = [csv.name]

        import_field = arcpy.Parameter(
            displayName="Imported Field",
            name="import_field",
            datatype="Field",
            parameterType="Optional",
            direction="Input")
        import_field.parameterDependencies = [csv.name]

        params = [i, pkey, csv, fkey, import_field]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        pkey = parameters[1].valueAsText
        csv = parameters[2].valueAsText
        fkey = parameters[3].valueAsText
        import_field = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.merge_table_with_csv(i=i, pkey=pkey, csv=csv, fkey=fkey, import_field=import_field)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MergeVectors(object):
    def __init__(self):
        self.label = "Merge Vectors"
        self.description = "Combines two or more input vectors of the same ShapeType creating a single, new output vector."
        self.category = "Data Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Vector Files",
            name="inputs",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [inputs, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.merge_vectors(inputs=inputs, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Min(object):
    def __init__(self):
        self.label = "Min"
        self.description = "Performs a MIN operation on two rasters or a raster and a constant value."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input1",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            try:
                input1 = str(float(input1))
            except:
                desc = arcpy.Describe(input1)
                input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.min(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MinAbsoluteOverlay(object):
    def __init__(self):
        self.label = "Min Absolute Overlay"
        self.description = "Evaluates the minimum absolute value for each grid cell from a stack of input rasters."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [inputs, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.min_absolute_overlay(inputs=inputs, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MinDistClassification(object):
    def __init__(self):
        self.label = "Min Dist Classification"
        self.description = "Performs a supervised minimum-distance classification using training site polygons and multi-spectral images."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Band Images",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        polys = arcpy.Parameter(
            displayName="Input Training Polygons",
            name="polys",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        polys.filter.list = ["Polygon"]

        field = arcpy.Parameter(
            displayName="Class Name Field",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [polys.name]

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        threshold = arcpy.Parameter(
            displayName="Distance Threshold (z-scores; blank for none)",
            name="threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [inputs, polys, field, output, threshold]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        polys = parameters[1].valueAsText
        if polys is not None:
            desc = arcpy.Describe(polys)
            polys = desc.catalogPath
        field = parameters[2].valueAsText
        output = parameters[3].valueAsText
        threshold = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.min_dist_classification(inputs=inputs, polys=polys, field=field, output=output, threshold=threshold)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MinDownslopeElevChange(object):
    def __init__(self):
        self.label = "Min Downslope Elev Change"
        self.description = "Calculates the minimum downslope change in elevation between a grid cell and its eight downslope neighbors."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.min_downslope_elev_change(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MinMaxContrastStretch(object):
    def __init__(self):
        self.label = "Min Max Contrast Stretch"
        self.description = "Performs a min-max contrast stretch on an input greytone image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        min_val = arcpy.Parameter(
            displayName="Lower Tail Clip Value",
            name="min_val",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        max_val = arcpy.Parameter(
            displayName="Upper Tail Clip Value",
            name="max_val",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        num_tones = arcpy.Parameter(
            displayName="Number of Tones",
            name="num_tones",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        num_tones.value = '256'

        params = [i, output, min_val, max_val, num_tones]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        min_val = parameters[2].valueAsText
        max_val = parameters[3].valueAsText
        num_tones = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.min_max_contrast_stretch(i=i, output=output, min_val=min_val, max_val=max_val, num_tones=num_tones)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MinOverlay(object):
    def __init__(self):
        self.label = "Min Overlay"
        self.description = "Evaluates the minimum value for each grid cell from a stack of input rasters."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [inputs, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.min_overlay(inputs=inputs, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MinimalCurvature(object):
    def __init__(self):
        self.label = "Minimal Curvature"
        self.description = "Calculates a mean curvature raster from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.minimal_curvature(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MinimumBoundingBox(object):
    def __init__(self):
        self.label = "Minimum Bounding Box"
        self.description = "Creates a vector minimum bounding rectangle around vector features."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        criterion = arcpy.Parameter(
            displayName="Minimization Criterion",
            name="criterion",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        criterion.filter.type = "ValueList"
        criterion.filter.list = ['area', 'length', 'width', 'perimeter']
        criterion.value = 'area'

        features = arcpy.Parameter(
            displayName="Find bounding rectangles around each individual feature.",
            name="features",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        features.value = 'True'

        params = [i, output, criterion, features]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        criterion = parameters[2].valueAsText
        features = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.minimum_bounding_box(i=i, output=output, criterion=criterion, features=features)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MinimumBoundingCircle(object):
    def __init__(self):
        self.label = "Minimum Bounding Circle"
        self.description = "Delineates the minimum bounding circle (i.e. smallest enclosing circle) for a group of vectors."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        features = arcpy.Parameter(
            displayName="Find bounding circle around each individual feature.",
            name="features",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        features.value = 'True'

        params = [i, output, features]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        features = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.minimum_bounding_circle(i=i, output=output, features=features)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MinimumBoundingEnvelope(object):
    def __init__(self):
        self.label = "Minimum Bounding Envelope"
        self.description = "Creates a vector axis-aligned minimum bounding rectangle (envelope) around vector features."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        features = arcpy.Parameter(
            displayName="Find bounding envelop around each individual feature.",
            name="features",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        features.value = 'True'

        params = [i, output, features]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        features = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.minimum_bounding_envelope(i=i, output=output, features=features)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MinimumConvexHull(object):
    def __init__(self):
        self.label = "Minimum Convex Hull"
        self.description = "Creates a vector convex polygon around vector features."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        features = arcpy.Parameter(
            displayName="Find hulls around each individual feature.",
            name="features",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        features.value = 'True'

        params = [i, output, features]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        features = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.minimum_convex_hull(i=i, output=output, features=features)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MinimumFilter(object):
    def __init__(self):
        self.label = "Minimum Filter"
        self.description = "Assigns each cell in the output grid the minimum value in a moving window centred on each grid cell in the input raster."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        params = [i, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.minimum_filter(i=i, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ModifiedKMeansClustering(object):
    def __init__(self):
        self.label = "Modified K Means Clustering"
        self.description = "Performs a modified k-means clustering operation on a multi-spectral dataset."
        self.category = "Machine Learning"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        out_html = arcpy.Parameter(
            displayName="Output HTML Report File",
            name="out_html",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_html.filter.list = ["html"]

        start_clusters = arcpy.Parameter(
            displayName="Initial Num. of Clusters",
            name="start_clusters",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        start_clusters.value = '1000'

        merge_dist = arcpy.Parameter(
            displayName="Cluster Merger Distance",
            name="merge_dist",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        max_iterations = arcpy.Parameter(
            displayName="Max. Iterations",
            name="max_iterations",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        max_iterations.value = '10'

        class_change = arcpy.Parameter(
            displayName="Percent Class Change Threshold",
            name="class_change",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        class_change.value = '2.0'

        params = [inputs, output, out_html, start_clusters, merge_dist, max_iterations, class_change]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        out_html = parameters[2].valueAsText
        start_clusters = parameters[3].valueAsText
        merge_dist = parameters[4].valueAsText
        max_iterations = parameters[5].valueAsText
        class_change = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.modified_k_means_clustering(inputs=inputs, output=output, out_html=out_html, start_clusters=start_clusters, merge_dist=merge_dist, max_iterations=max_iterations, class_change=class_change)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ModifyLidar(object):
    def __init__(self):
        self.label = "Modify Lidar"
        self.description = "Modify points within a LiDAR point cloud based on point properties."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR Points",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output LiDAR Points",
            name="output",
            datatype="DEFile",
            parameterType="Optional",
            direction="Output")

        statement = arcpy.Parameter(
            displayName="Statement:",
            name="statement",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        params = [i, output, statement]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        statement = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.modify_lidar(i=i, output=output, statement=statement)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ModifyNoDataValue(object):
    def __init__(self):
        self.label = "Modify No Data Value"
        self.description = "Modifies nodata values in a raster."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        new_value = arcpy.Parameter(
            displayName="New NoData Value",
            name="new_value",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        new_value.value = '-32768.0'

        params = [i, new_value]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        new_value = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.modify_no_data_value(i=i, new_value=new_value)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Modulo(object):
    def __init__(self):
        self.label = "Modulo"
        self.description = "Performs a modulo operation on two rasters or a raster and a constant value."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input1",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            try:
                input1 = str(float(input1))
            except:
                desc = arcpy.Describe(input1)
                input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.modulo(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Mosaic(object):
    def __init__(self):
        self.label = "Mosaic"
        self.description = "Mosaics two or more images together."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        method = arcpy.Parameter(
            displayName="Resampling Method",
            name="method",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        method.filter.type = "ValueList"
        method.filter.list = ['nn', 'bilinear', 'cc']
        method.value = 'nn'

        params = [inputs, output, method]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        method = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.mosaic(inputs=inputs, output=output, method=method)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MosaicWithFeathering(object):
    def __init__(self):
        self.label = "Mosaic With Feathering"
        self.description = "Mosaics two images together using a feathering technique in overlapping areas to reduce edge-effects."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File To Modify",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input Reference File",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        method = arcpy.Parameter(
            displayName="Resampling Method",
            name="method",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        method.filter.type = "ValueList"
        method.filter.list = ['nn', 'bilinear', 'cc']
        method.value = 'cc'

        weight = arcpy.Parameter(
            displayName="Distance Weight",
            name="weight",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        weight.value = '4.0'

        params = [input1, input2, output, method, weight]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        method = parameters[3].valueAsText
        weight = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.mosaic_with_feathering(input1=input1, input2=input2, output=output, method=method, weight=weight)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MultiPartToSinglePart(object):
    def __init__(self):
        self.label = "Multi Part To Single Part"
        self.description = "Converts a vector file containing multi-part features into a vector containing only single-part features."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Line or Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Line or Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        exclude_holes = arcpy.Parameter(
            displayName="Exclude hole parts?",
            name="exclude_holes",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        exclude_holes.value = 'True'

        params = [i, output, exclude_holes]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        exclude_holes = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.multi_part_to_single_part(i=i, output=output, exclude_holes=exclude_holes)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MultidirectionalHillshade(object):
    def __init__(self):
        self.label = "Multidirectional Hillshade"
        self.description = "Calculates a multi-direction hillshade raster from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        altitude = arcpy.Parameter(
            displayName="Altitude (degrees)",
            name="altitude",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        altitude.value = '45.0'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        full_mode = arcpy.Parameter(
            displayName="Full 360-degree mode?",
            name="full_mode",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        full_mode.value = 'False'

        params = [dem, output, altitude, zfactor, full_mode]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        altitude = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        full_mode = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.multidirectional_hillshade(dem=dem, output=output, altitude=altitude, zfactor=zfactor, full_mode=full_mode)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Multiply(object):
    def __init__(self):
        self.label = "Multiply"
        self.description = "Performs a multiplication operation on two rasters or a raster and a constant value."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input1",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            try:
                input1 = str(float(input1))
            except:
                desc = arcpy.Describe(input1)
                input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.multiply(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MultiplyOverlay(object):
    def __init__(self):
        self.label = "Multiply Overlay"
        self.description = "Calculates the sum for each grid cell from a group of raster images."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [inputs, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.multiply_overlay(inputs=inputs, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MultiscaleCurvatures(object):
    def __init__(self):
        self.label = "Multiscale Curvatures"
        self.description = "This tool calculates several multiscale curvatures and curvature-based indices from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input Raster DEM",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        curv_type = arcpy.Parameter(
            displayName="Curvature Type",
            name="curv_type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        curv_type.filter.type = "ValueList"
        curv_type.filter.list = ['AccumulationCurv', 'Curvedness', 'DifferenceCurv', 'GaussianCurv', 'GeneratingFunction', 'HorizontalExcessCurv', 'MaximalCurv', 'MeanCurv', 'MinimalCurv', 'PlanCurv', 'ProfileCurv', 'RingCurv', 'Rotor', 'ShapeIndex', 'TangentialCurv', 'TotalCurv', 'Unsphericity', 'VerticalExcessCurv']
        curv_type.value = 'ProfileCurv'

        out_mag = arcpy.Parameter(
            displayName="Output Magnitude File",
            name="out_mag",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_mag.filter.list = ["tif"]

        out_scale = arcpy.Parameter(
            displayName="Output Scale File",
            name="out_scale",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_scale.filter.list = ["tif"]

        min_scale = arcpy.Parameter(
            displayName="Minimum Search Neighbourhood Radius (grid cells)",
            name="min_scale",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_scale.value = '0'

        step = arcpy.Parameter(
            displayName="Base Step Size",
            name="step",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        step.value = '1'

        num_steps = arcpy.Parameter(
            displayName="Number of Steps",
            name="num_steps",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        num_steps.value = '1'

        step_nonlinearity = arcpy.Parameter(
            displayName="Step Nonlinearity",
            name="step_nonlinearity",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        step_nonlinearity.value = '1.0'

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'True'

        standardize = arcpy.Parameter(
            displayName="Standardize Each Scale?",
            name="standardize",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        standardize.value = 'False'

        params = [dem, curv_type, out_mag, out_scale, min_scale, step, num_steps, step_nonlinearity, log, standardize]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        curv_type = parameters[1].valueAsText
        out_mag = parameters[2].valueAsText
        out_scale = parameters[3].valueAsText
        min_scale = parameters[4].valueAsText
        step = parameters[5].valueAsText
        num_steps = parameters[6].valueAsText
        step_nonlinearity = parameters[7].valueAsText
        log = parameters[8].valueAsText
        standardize = parameters[9].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.multiscale_curvatures(dem=dem, curv_type=curv_type, out_mag=out_mag, out_scale=out_scale, min_scale=min_scale, step=step, num_steps=num_steps, step_nonlinearity=step_nonlinearity, log=log, standardize=standardize)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MultiscaleElevationPercentile(object):
    def __init__(self):
        self.label = "Multiscale Elevation Percentile"
        self.description = "Calculates surface roughness over a range of spatial scales."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        out_mag = arcpy.Parameter(
            displayName="Output Roughness Magnitude File",
            name="out_mag",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_mag.filter.list = ["tif"]

        out_scale = arcpy.Parameter(
            displayName="Output Roughness Scale File",
            name="out_scale",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_scale.filter.list = ["tif"]

        sig_digits = arcpy.Parameter(
            displayName="Number of Significant Digits",
            name="sig_digits",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        sig_digits.value = '3'

        min_scale = arcpy.Parameter(
            displayName="Minimum Search Neighbourhood Radius (grid cells)",
            name="min_scale",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_scale.value = '4'

        step = arcpy.Parameter(
            displayName="Base Step Size",
            name="step",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        step.value = '1'

        num_steps = arcpy.Parameter(
            displayName="Number of Steps",
            name="num_steps",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        num_steps.value = '10'

        step_nonlinearity = arcpy.Parameter(
            displayName="Step Nonlinearity",
            name="step_nonlinearity",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        step_nonlinearity.value = '1.0'

        params = [dem, out_mag, out_scale, sig_digits, min_scale, step, num_steps, step_nonlinearity]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        out_mag = parameters[1].valueAsText
        out_scale = parameters[2].valueAsText
        sig_digits = parameters[3].valueAsText
        min_scale = parameters[4].valueAsText
        step = parameters[5].valueAsText
        num_steps = parameters[6].valueAsText
        step_nonlinearity = parameters[7].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.multiscale_elevation_percentile(dem=dem, out_mag=out_mag, out_scale=out_scale, sig_digits=sig_digits, min_scale=min_scale, step=step, num_steps=num_steps, step_nonlinearity=step_nonlinearity)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MultiscaleRoughness(object):
    def __init__(self):
        self.label = "Multiscale Roughness"
        self.description = "Calculates surface roughness over a range of spatial scales."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        out_mag = arcpy.Parameter(
            displayName="Output Roughness Magnitude File",
            name="out_mag",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_mag.filter.list = ["tif"]

        out_scale = arcpy.Parameter(
            displayName="Output Roughness Scale File",
            name="out_scale",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_scale.filter.list = ["tif"]

        min_scale = arcpy.Parameter(
            displayName="Minimum Search Neighbourhood Radius (grid cells)",
            name="min_scale",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_scale.value = '1'

        max_scale = arcpy.Parameter(
            displayName="Maximum Search Neighbourhood Radius (grid cells)",
            name="max_scale",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")

        step = arcpy.Parameter(
            displayName="Step Size",
            name="step",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        step.value = '1'

        params = [dem, out_mag, out_scale, min_scale, max_scale, step]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        out_mag = parameters[1].valueAsText
        out_scale = parameters[2].valueAsText
        min_scale = parameters[3].valueAsText
        max_scale = parameters[4].valueAsText
        step = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.multiscale_roughness(dem=dem, out_mag=out_mag, out_scale=out_scale, min_scale=min_scale, max_scale=max_scale, step=step)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MultiscaleRoughnessSignature(object):
    def __init__(self):
        self.label = "Multiscale Roughness Signature"
        self.description = "Calculates the surface roughness for points over a range of spatial scales."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        points = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="points",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        points.filter.list = ["Point"]

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        min_scale = arcpy.Parameter(
            displayName="Minimum Search Neighbourhood Radius (grid cells)",
            name="min_scale",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_scale.value = '1'

        max_scale = arcpy.Parameter(
            displayName="Maximum Search Neighbourhood Radius (grid cells)",
            name="max_scale",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")

        step = arcpy.Parameter(
            displayName="Step Size",
            name="step",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        step.value = '1'

        params = [dem, points, output, min_scale, max_scale, step]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        points = parameters[1].valueAsText
        if points is not None:
            desc = arcpy.Describe(points)
            points = desc.catalogPath
        output = parameters[2].valueAsText
        min_scale = parameters[3].valueAsText
        max_scale = parameters[4].valueAsText
        step = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.multiscale_roughness_signature(dem=dem, points=points, output=output, min_scale=min_scale, max_scale=max_scale, step=step)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MultiscaleStdDevNormals(object):
    def __init__(self):
        self.label = "Multiscale Std Dev Normals"
        self.description = "Calculates surface roughness over a range of spatial scales."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        out_mag = arcpy.Parameter(
            displayName="Output Roughness Magnitude File",
            name="out_mag",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_mag.filter.list = ["tif"]

        out_scale = arcpy.Parameter(
            displayName="Output Roughness Scale File",
            name="out_scale",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_scale.filter.list = ["tif"]

        min_scale = arcpy.Parameter(
            displayName="Minimum Search Neighbourhood Radius (grid cells)",
            name="min_scale",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_scale.value = '1'

        step = arcpy.Parameter(
            displayName="Base Step Size",
            name="step",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        step.value = '1'

        num_steps = arcpy.Parameter(
            displayName="Number of Steps",
            name="num_steps",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        num_steps.value = '10'

        step_nonlinearity = arcpy.Parameter(
            displayName="Step Nonlinearity",
            name="step_nonlinearity",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        step_nonlinearity.value = '1.0'

        params = [dem, out_mag, out_scale, min_scale, step, num_steps, step_nonlinearity]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        out_mag = parameters[1].valueAsText
        out_scale = parameters[2].valueAsText
        min_scale = parameters[3].valueAsText
        step = parameters[4].valueAsText
        num_steps = parameters[5].valueAsText
        step_nonlinearity = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.multiscale_std_dev_normals(dem=dem, out_mag=out_mag, out_scale=out_scale, min_scale=min_scale, step=step, num_steps=num_steps, step_nonlinearity=step_nonlinearity)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MultiscaleStdDevNormalsSignature(object):
    def __init__(self):
        self.label = "Multiscale Std Dev Normals Signature"
        self.description = "Calculates the surface roughness for points over a range of spatial scales."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        points = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="points",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        points.filter.list = ["Point"]

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        min_scale = arcpy.Parameter(
            displayName="Minimum Search Neighbourhood Radius (grid cells)",
            name="min_scale",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_scale.value = '1'

        step = arcpy.Parameter(
            displayName="Base Step Size",
            name="step",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        step.value = '1'

        num_steps = arcpy.Parameter(
            displayName="Number of Steps",
            name="num_steps",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        num_steps.value = '10'

        step_nonlinearity = arcpy.Parameter(
            displayName="Step Nonlinearity",
            name="step_nonlinearity",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        step_nonlinearity.value = '1.0'

        params = [dem, points, output, min_scale, step, num_steps, step_nonlinearity]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        points = parameters[1].valueAsText
        if points is not None:
            desc = arcpy.Describe(points)
            points = desc.catalogPath
        output = parameters[2].valueAsText
        min_scale = parameters[3].valueAsText
        step = parameters[4].valueAsText
        num_steps = parameters[5].valueAsText
        step_nonlinearity = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.multiscale_std_dev_normals_signature(dem=dem, points=points, output=output, min_scale=min_scale, step=step, num_steps=num_steps, step_nonlinearity=step_nonlinearity)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class MultiscaleTopographicPositionImage(object):
    def __init__(self):
        self.label = "Multiscale Topographic Position Image"
        self.description = "Creates a multiscale topographic position image from three DEVmax rasters of differing spatial scale ranges."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        local = arcpy.Parameter(
            displayName="Input Local-Scale File",
            name="local",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        meso = arcpy.Parameter(
            displayName="Input Meso-Scale File",
            name="meso",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        broad = arcpy.Parameter(
            displayName="Input Broad-Scale File",
            name="broad",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        hillshade = arcpy.Parameter(
            displayName="Optional Hillshade File",
            name="hillshade",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        lightness = arcpy.Parameter(
            displayName="Image Lightness Value",
            name="lightness",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        lightness.value = '1.2'

        params = [local, meso, broad, hillshade, output, lightness]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        local = parameters[0].valueAsText
        if local is not None:
            desc = arcpy.Describe(local)
            local = desc.catalogPath
        meso = parameters[1].valueAsText
        if meso is not None:
            desc = arcpy.Describe(meso)
            meso = desc.catalogPath
        broad = parameters[2].valueAsText
        if broad is not None:
            desc = arcpy.Describe(broad)
            broad = desc.catalogPath
        hillshade = parameters[3].valueAsText
        if hillshade is not None:
            desc = arcpy.Describe(hillshade)
            hillshade = desc.catalogPath
        output = parameters[4].valueAsText
        lightness = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.multiscale_topographic_position_image(local=local, meso=meso, broad=broad, hillshade=hillshade, output=output, lightness=lightness)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class NarrownessIndex(object):
    def __init__(self):
        self.label = "Narrowness Index"
        self.description = "Calculates the narrowness of raster polygons."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.narrowness_index(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class NaturalNeighbourInterpolation(object):
    def __init__(self):
        self.label = "Natural Neighbour Interpolation"
        self.description = "Creates a raster grid based on Sibson's natural neighbour method."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        field = arcpy.Parameter(
            displayName="Field Name",
            name="field",
            datatype="Field",
            parameterType="Optional",
            direction="Input")
        field.parameterDependencies = [i.name]

        use_z = arcpy.Parameter(
            displayName="Use Shapefile 'z' values?",
            name="use_z",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        use_z.value = 'False'

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        cell_size = arcpy.Parameter(
            displayName="Cell Size (optional)",
            name="cell_size",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        base = arcpy.Parameter(
            displayName="Base Raster File (optional)",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        clip = arcpy.Parameter(
            displayName="Clip to convex hull?",
            name="clip",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        clip.value = 'True'

        params = [i, field, use_z, output, cell_size, base, clip]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        use_z = parameters[2].valueAsText
        output = parameters[3].valueAsText
        cell_size = parameters[4].valueAsText
        base = parameters[5].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        clip = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.natural_neighbour_interpolation(i=i, field=field, use_z=use_z, output=output, cell_size=cell_size, base=base, clip=clip)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class NearestNeighbourGridding(object):
    def __init__(self):
        self.label = "Nearest Neighbour Gridding"
        self.description = "Creates a raster grid based on a set of vector points and assigns grid values using the nearest neighbour."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        field = arcpy.Parameter(
            displayName="Field Name",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [i.name]

        use_z = arcpy.Parameter(
            displayName="Use z-coordinate instead of field?",
            name="use_z",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        use_z.value = 'False'

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        cell_size = arcpy.Parameter(
            displayName="Cell Size (optional)",
            name="cell_size",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        base = arcpy.Parameter(
            displayName="Base Raster File (optional)",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        max_dist = arcpy.Parameter(
            displayName="Maximum Search Distance",
            name="max_dist",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [i, field, use_z, output, cell_size, base, max_dist]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        use_z = parameters[2].valueAsText
        output = parameters[3].valueAsText
        cell_size = parameters[4].valueAsText
        base = parameters[5].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        max_dist = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.nearest_neighbour_gridding(i=i, field=field, use_z=use_z, output=output, cell_size=cell_size, base=base, max_dist=max_dist)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Negate(object):
    def __init__(self):
        self.label = "Negate"
        self.description = "Changes the sign of values in a raster or the 0-1 values of a Boolean raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.negate(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class NewRasterFromBase(object):
    def __init__(self):
        self.label = "New Raster From Base"
        self.description = "Creates a new raster using a base image."
        self.category = "Data Tools"

    def getParameterInfo(self):
        base = arcpy.Parameter(
            displayName="Input Base File",
            name="base",
            datatype=["DERasterDataset", "DEShapefile"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        value = arcpy.Parameter(
            displayName="Constant Value",
            name="value",
            datatype=["GPString", "GPDouble"],
            parameterType="Optional",
            direction="Input")
        value.value = 'nodata'

        data_type = arcpy.Parameter(
            displayName="Data Type",
            name="data_type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        data_type.filter.type = "ValueList"
        data_type.filter.list = ['double', 'float', 'integer']
        data_type.value = 'float'

        cell_size = arcpy.Parameter(
            displayName="Cell Size (optional)",
            name="cell_size",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [base, output, value, data_type, cell_size]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        base = parameters[0].valueAsText
        output = parameters[1].valueAsText
        value = parameters[2].valueAsText
        data_type = parameters[3].valueAsText
        cell_size = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.new_raster_from_base(base=base, output=output, value=value, data_type=data_type, cell_size=cell_size)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class NormalVectors(object):
    def __init__(self):
        self.label = "Normal Vectors"
        self.description = "Calculates normal vectors for points within a LAS file and stores these data (XYZ vector components) in the RGB field."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        radius = arcpy.Parameter(
            displayName="Search Radius",
            name="radius",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        radius.value = '1.0'

        params = [i, output, radius]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        radius = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.normal_vectors(i=i, output=output, radius=radius)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class NormalizeLidar(object):
    def __init__(self):
        self.label = "Normalize Lidar"
        self.description = "Normalizes a LiDAR point cloud."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR File",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output Lidar File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        dtm = arcpy.Parameter(
            displayName="Input DTM Raster File",
            name="dtm",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        params = [i, output, dtm]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        dtm = parameters[2].valueAsText
        if dtm is not None:
            desc = arcpy.Describe(dtm)
            dtm = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.normalize_lidar(i=i, output=output, dtm=dtm)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class NormalizedDifferenceIndex(object):
    def __init__(self):
        self.label = "Normalized Difference Index"
        self.description = "Calculate a normalized-difference index (NDI) from two bands of multispectral image data."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input 1 File",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input 2 File",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        clip = arcpy.Parameter(
            displayName="Distribution Tail Clip Amount (%)",
            name="clip",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        clip.value = '0.0'

        correction = arcpy.Parameter(
            displayName="Correction value",
            name="correction",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        correction.value = '0.0'

        params = [input1, input2, output, clip, correction]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        clip = parameters[3].valueAsText
        correction = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.normalized_difference_index(input1=input1, input2=input2, output=output, clip=clip, correction=correction)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Not(object):
    def __init__(self):
        self.label = "Not"
        self.description = "Performs a logical NOT operator on two Boolean raster images."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.Not(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class NotEqualTo(object):
    def __init__(self):
        self.label = "Not Equal To"
        self.description = "Performs a not-equal-to comparison operation on two rasters or a raster and a constant value."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input1",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            try:
                input1 = str(float(input1))
            except:
                desc = arcpy.Describe(input1)
                input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.not_equal_to(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class NumDownslopeNeighbours(object):
    def __init__(self):
        self.label = "Num Downslope Neighbours"
        self.description = "Calculates the number of downslope neighbours to each grid cell in a DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.num_downslope_neighbours(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class NumInflowingNeighbours(object):
    def __init__(self):
        self.label = "Num Inflowing Neighbours"
        self.description = "Computes the number of inflowing neighbours to each cell in an input DEM based on the D8 algorithm."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.num_inflowing_neighbours(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class NumUpslopeNeighbours(object):
    def __init__(self):
        self.label = "Num Upslope Neighbours"
        self.description = "Calculates the number of upslope neighbours to each grid cell in a DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.num_upslope_neighbours(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class OlympicFilter(object):
    def __init__(self):
        self.label = "Olympic Filter"
        self.description = "Performs an olympic smoothing filter on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        params = [i, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.olympic_filter(i=i, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Opening(object):
    def __init__(self):
        self.label = "Opening"
        self.description = "An opening is a mathematical morphology operation involving a dilation (max filter) of an erosion (min filter) set."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        params = [i, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.opening(i=i, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Openness(object):
    def __init__(self):
        self.label = "Openness"
        self.description = "This tool calculates the topographic openness index from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster DEM",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        pos_output = arcpy.Parameter(
            displayName="Positive Openness Output Raster",
            name="pos_output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        pos_output.filter.list = ["tif"]

        neg_output = arcpy.Parameter(
            displayName="Negative Openness Output Raster",
            name="neg_output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        neg_output.filter.list = ["tif"]

        dist = arcpy.Parameter(
            displayName="Search Distance (grid cells)",
            name="dist",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        dist.value = '20'

        params = [i, pos_output, neg_output, dist]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        pos_output = parameters[1].valueAsText
        neg_output = parameters[2].valueAsText
        dist = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.openness(i=i, pos_output=pos_output, neg_output=neg_output, dist=dist)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Or(object):
    def __init__(self):
        self.label = "Or"
        self.description = "Performs a logical OR operator on two Boolean raster images."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.Or(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PairedSampleTTest(object):
    def __init__(self):
        self.label = "Paired Sample T Test"
        self.description = "Performs a 2-sample K-S test for significant differences on two input rasters."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="First Input File",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Second Input File",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        num_samples = arcpy.Parameter(
            displayName="Num. Samples (blank for whole image)",
            name="num_samples",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")

        params = [input1, input2, output, num_samples]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        num_samples = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.paired_sample_t_test(input1=input1, input2=input2, output=output, num_samples=num_samples)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PanchromaticSharpening(object):
    def __init__(self):
        self.label = "Panchromatic Sharpening"
        self.description = "Increases the spatial resolution of image data by combining multispectral bands with panchromatic data."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        red = arcpy.Parameter(
            displayName="Input Red Band File (optional; only if colour-composite not specified)",
            name="red",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        green = arcpy.Parameter(
            displayName="Input Green Band File (optional; only if colour-composite not specified)",
            name="green",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        blue = arcpy.Parameter(
            displayName="Input Blue Band File (optional; only if colour-composite not specified)",
            name="blue",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        composite = arcpy.Parameter(
            displayName="Input Colour-Composite Image File (optional; only if individual bands not specified)",
            name="composite",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        pan = arcpy.Parameter(
            displayName="Input Panchromatic Band File",
            name="pan",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Colour Composite File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        method = arcpy.Parameter(
            displayName="Pan-Sharpening Method",
            name="method",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        method.filter.type = "ValueList"
        method.filter.list = ['brovey', 'ihs']
        method.value = 'brovey'

        params = [red, green, blue, composite, pan, output, method]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        red = parameters[0].valueAsText
        if red is not None:
            desc = arcpy.Describe(red)
            red = desc.catalogPath
        green = parameters[1].valueAsText
        if green is not None:
            desc = arcpy.Describe(green)
            green = desc.catalogPath
        blue = parameters[2].valueAsText
        if blue is not None:
            desc = arcpy.Describe(blue)
            blue = desc.catalogPath
        composite = parameters[3].valueAsText
        if composite is not None:
            desc = arcpy.Describe(composite)
            composite = desc.catalogPath
        pan = parameters[4].valueAsText
        if pan is not None:
            desc = arcpy.Describe(pan)
            pan = desc.catalogPath
        output = parameters[5].valueAsText
        method = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.panchromatic_sharpening(red=red, green=green, blue=blue, composite=composite, pan=pan, output=output, method=method)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ParallelepipedClassification(object):
    def __init__(self):
        self.label = "Parallelepiped Classification"
        self.description = "Performs a supervised parallelepiped classification using training site polygons and multi-spectral images."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Band Images",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        polys = arcpy.Parameter(
            displayName="Input Training Polygons",
            name="polys",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        polys.filter.list = ["Polygon"]

        field = arcpy.Parameter(
            displayName="Class Name Field",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [polys.name]

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [inputs, polys, field, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        polys = parameters[1].valueAsText
        if polys is not None:
            desc = arcpy.Describe(polys)
            polys = desc.catalogPath
        field = parameters[2].valueAsText
        output = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.parallelepiped_classification(inputs=inputs, polys=polys, field=field, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PatchOrientation(object):
    def __init__(self):
        self.label = "Patch Orientation"
        self.description = "Calculates the orientation of vector polygons."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.patch_orientation(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PennockLandformClass(object):
    def __init__(self):
        self.label = "Pennock Landform Class"
        self.description = "Classifies hillslope zones based on slope, profile curvature, and plan curvature."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        slope = arcpy.Parameter(
            displayName="Slope Threshold (degrees)",
            name="slope",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        slope.value = '3.0'

        prof = arcpy.Parameter(
            displayName="Profile Curvature Threshold",
            name="prof",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        prof.value = '0.1'

        plan = arcpy.Parameter(
            displayName="Plan Curvature Threshold",
            name="plan",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        plan.value = '0.0'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, slope, prof, plan, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        slope = parameters[2].valueAsText
        prof = parameters[3].valueAsText
        plan = parameters[4].valueAsText
        zfactor = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.pennock_landform_class(dem=dem, output=output, slope=slope, prof=prof, plan=plan, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PercentElevRange(object):
    def __init__(self):
        self.label = "Percent Elev Range"
        self.description = "Calculates percent of elevation range from a DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '3'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '3'

        params = [dem, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.percent_elev_range(dem=dem, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PercentEqualTo(object):
    def __init__(self):
        self.label = "Percent Equal To"
        self.description = "Calculates the percentage of a raster stack that have cell values equal to an input on a cell-by-cell basis."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        comparison = arcpy.Parameter(
            displayName="Input Comparison File",
            name="comparison",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [inputs, comparison, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        comparison = parameters[1].valueAsText
        if comparison is not None:
            desc = arcpy.Describe(comparison)
            comparison = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.percent_equal_to(inputs=inputs, comparison=comparison, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PercentGreaterThan(object):
    def __init__(self):
        self.label = "Percent Greater Than"
        self.description = "Calculates the percentage of a raster stack that have cell values greater than an input on a cell-by-cell basis."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        comparison = arcpy.Parameter(
            displayName="Input Comparison File",
            name="comparison",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [inputs, comparison, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        comparison = parameters[1].valueAsText
        if comparison is not None:
            desc = arcpy.Describe(comparison)
            comparison = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.percent_greater_than(inputs=inputs, comparison=comparison, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PercentLessThan(object):
    def __init__(self):
        self.label = "Percent Less Than"
        self.description = "Calculates the percentage of a raster stack that have cell values less than an input on a cell-by-cell basis."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        comparison = arcpy.Parameter(
            displayName="Input Comparison File",
            name="comparison",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [inputs, comparison, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        comparison = parameters[1].valueAsText
        if comparison is not None:
            desc = arcpy.Describe(comparison)
            comparison = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.percent_less_than(inputs=inputs, comparison=comparison, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PercentageContrastStretch(object):
    def __init__(self):
        self.label = "Percentage Contrast Stretch"
        self.description = "Performs a percentage linear contrast stretch on input images."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        clip = arcpy.Parameter(
            displayName="Distribution Tail Clip Amount (%)",
            name="clip",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        clip.value = '1.0'

        tail = arcpy.Parameter(
            displayName="Tail",
            name="tail",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        tail.filter.type = "ValueList"
        tail.filter.list = ['upper', 'lower', 'both']
        tail.value = 'both'

        num_tones = arcpy.Parameter(
            displayName="Number of Tones",
            name="num_tones",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        num_tones.value = '256'

        params = [i, output, clip, tail, num_tones]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        clip = parameters[2].valueAsText
        tail = parameters[3].valueAsText
        num_tones = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.percentage_contrast_stretch(i=i, output=output, clip=clip, tail=tail, num_tones=num_tones)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PercentileFilter(object):
    def __init__(self):
        self.label = "Percentile Filter"
        self.description = "Performs a percentile filter on an input image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        sig_digits = arcpy.Parameter(
            displayName="Number of Significant Digits",
            name="sig_digits",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        sig_digits.value = '2'

        params = [i, output, filterx, filtery, sig_digits]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        sig_digits = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.percentile_filter(i=i, output=output, filterx=filterx, filtery=filtery, sig_digits=sig_digits)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PerimeterAreaRatio(object):
    def __init__(self):
        self.label = "Perimeter Area Ratio"
        self.description = "Calculates the perimeter-area ratio of vector polygons."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.perimeter_area_ratio(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PhiCoefficient(object):
    def __init__(self):
        self.label = "Phi Coefficient"
        self.description = "This tool performs a binary classification accuracy assessment."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input Raster Image 1",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input Raster Image 2",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.phi_coefficient(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PickFromList(object):
    def __init__(self):
        self.label = "Pick From List"
        self.description = "Outputs the value from a raster stack specified by a position raster."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        pos_input = arcpy.Parameter(
            displayName="Input Position File",
            name="pos_input",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [inputs, pos_input, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        pos_input = parameters[1].valueAsText
        if pos_input is not None:
            desc = arcpy.Describe(pos_input)
            pos_input = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.pick_from_list(inputs=inputs, pos_input=pos_input, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PiecewiseContrastStretch(object):
    def __init__(self):
        self.label = "Piecewise Contrast Stretch"
        self.description = "Performs a piecewise contrast stretch on an input image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster Image",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster Image",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        function = arcpy.Parameter(
            displayName="Piecewise Function Break-points:",
            name="function",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        greytones = arcpy.Parameter(
            displayName="Number of Output Greytones:",
            name="greytones",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        greytones.value = '1024'

        params = [i, output, function, greytones]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        function = parameters[2].valueAsText
        greytones = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.piecewise_contrast_stretch(i=i, output=output, function=function, greytones=greytones)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PlanCurvature(object):
    def __init__(self):
        self.label = "Plan Curvature"
        self.description = "Calculates a plan (contour) curvature raster from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.plan_curvature(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PolygonArea(object):
    def __init__(self):
        self.label = "Polygon Area"
        self.description = "Calculates the area of vector polygons."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.polygon_area(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PolygonLongAxis(object):
    def __init__(self):
        self.label = "Polygon Long Axis"
        self.description = "Used to map the long axis of polygon features."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.polygon_long_axis(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PolygonPerimeter(object):
    def __init__(self):
        self.label = "Polygon Perimeter"
        self.description = "Calculates the perimeter of vector polygons."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.polygon_perimeter(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PolygonShortAxis(object):
    def __init__(self):
        self.label = "Polygon Short Axis"
        self.description = "Used to map the short axis of polygon features."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.polygon_short_axis(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Polygonize(object):
    def __init__(self):
        self.label = "Polygonize"
        self.description = "Creates a polygon layer from two or more intersecting line features contained in one or more input vector line files."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Vector Lines File",
            name="inputs",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True
        inputs.filter.list = ["Polyline"]

        output = arcpy.Parameter(
            displayName="Output Vector Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [inputs, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.polygonize(inputs=inputs, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PolygonsToLines(object):
    def __init__(self):
        self.label = "Polygons To Lines"
        self.description = "Converts vector polygons to polylines."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        output = arcpy.Parameter(
            displayName="Output Line File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.polygons_to_lines(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Power(object):
    def __init__(self):
        self.label = "Power"
        self.description = "Raises the values in grid cells of one rasters, or a constant value, by values in another raster or constant value."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input1",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            try:
                input1 = str(float(input1))
            except:
                desc = arcpy.Describe(input1)
                input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.power(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PrewittFilter(object):
    def __init__(self):
        self.label = "Prewitt Filter"
        self.description = "Performs a Prewitt edge-detection filter on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        clip = arcpy.Parameter(
            displayName="Distribution Tail Clip Amount (Percent)",
            name="clip",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        clip.value = '0.0'

        params = [i, output, clip]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        clip = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.prewitt_filter(i=i, output=output, clip=clip)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PrincipalComponentAnalysis(object):
    def __init__(self):
        self.label = "Principal Component Analysis"
        self.description = "Performs a principal component analysis (PCA) on a multi-spectral dataset."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output HTML Report File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        num_comp = arcpy.Parameter(
            displayName="Num. of Component Images (blank for all)",
            name="num_comp",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")

        standardized = arcpy.Parameter(
            displayName="Perform Standaradized PCA?",
            name="standardized",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [inputs, output, num_comp, standardized]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        num_comp = parameters[2].valueAsText
        standardized = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.principal_component_analysis(inputs=inputs, output=output, num_comp=num_comp, standardized=standardized)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class PrintGeoTiffTags(object):
    def __init__(self):
        self.label = "Print Geo Tiff Tags"
        self.description = "Prints the tags within a GeoTIFF."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input GeoTIFF Raster File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.print_geo_tiff_tags(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Profile(object):
    def __init__(self):
        self.label = "Profile"
        self.description = "Plots profiles from digital surface models."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        lines = arcpy.Parameter(
            displayName="Input Vector Line File",
            name="lines",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        lines.filter.list = ["Polyline"]

        surface = arcpy.Parameter(
            displayName="Input Surface File",
            name="surface",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [lines, surface, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        lines = parameters[0].valueAsText
        if lines is not None:
            desc = arcpy.Describe(lines)
            lines = desc.catalogPath
        surface = parameters[1].valueAsText
        if surface is not None:
            desc = arcpy.Describe(surface)
            surface = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.profile(lines=lines, surface=surface, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ProfileCurvature(object):
    def __init__(self):
        self.label = "Profile Curvature"
        self.description = "Calculates a profile curvature raster from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.profile_curvature(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class QinFlowAccumulation(object):
    def __init__(self):
        self.label = "Qin Flow Accumulation"
        self.description = "Calculates Qin et al. (2007) flow accumulation."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM Raster",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        out_type = arcpy.Parameter(
            displayName="Output Type",
            name="out_type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        out_type.filter.type = "ValueList"
        out_type.filter.list = ['cells', 'specific contributing area', 'catchment area']
        out_type.value = 'specific contributing area'

        exponent = arcpy.Parameter(
            displayName="Upper-bound Exponent Parameter",
            name="exponent",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        exponent.value = '10.0'

        max_slope = arcpy.Parameter(
            displayName="Upper-bound Slope Parameter (in degrees)",
            name="max_slope",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        max_slope.value = '45.0'

        threshold = arcpy.Parameter(
            displayName="Convergence Threshold (grid cells; blank for none)",
            name="threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        clip = arcpy.Parameter(
            displayName="Clip the upper tail by 1%?",
            name="clip",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        clip.value = 'False'

        params = [dem, output, out_type, exponent, max_slope, threshold, log, clip]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        out_type = parameters[2].valueAsText
        exponent = parameters[3].valueAsText
        max_slope = parameters[4].valueAsText
        threshold = parameters[5].valueAsText
        log = parameters[6].valueAsText
        clip = parameters[7].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.qin_flow_accumulation(dem=dem, output=output, out_type=out_type, exponent=exponent, max_slope=max_slope, threshold=threshold, log=log, clip=clip)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Quantiles(object):
    def __init__(self):
        self.label = "Quantiles"
        self.description = "Transforms raster values into quantiles."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        num_quantiles = arcpy.Parameter(
            displayName="Number of Quantiles",
            name="num_quantiles",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        num_quantiles.value = '5'

        params = [i, output, num_quantiles]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        num_quantiles = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.quantiles(i=i, output=output, num_quantiles=num_quantiles)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class QuinnFlowAccumulation(object):
    def __init__(self):
        self.label = "Quinn Flow Accumulation"
        self.description = "Calculates Quinn et al. (1995) flow accumulation."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM Raster",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        out_type = arcpy.Parameter(
            displayName="Output Type",
            name="out_type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        out_type.filter.type = "ValueList"
        out_type.filter.list = ['cells', 'specific contributing area', 'catchment area']
        out_type.value = 'specific contributing area'

        exponent = arcpy.Parameter(
            displayName="Exponent Parameter",
            name="exponent",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        exponent.value = '1.0'

        threshold = arcpy.Parameter(
            displayName="Convergence Threshold (grid cells; blank for none)",
            name="threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        clip = arcpy.Parameter(
            displayName="Clip the upper tail by 1%?",
            name="clip",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        clip.value = 'False'

        params = [dem, output, out_type, exponent, threshold, log, clip]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        out_type = parameters[2].valueAsText
        exponent = parameters[3].valueAsText
        threshold = parameters[4].valueAsText
        log = parameters[5].valueAsText
        clip = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.quinn_flow_accumulation(dem=dem, output=output, out_type=out_type, exponent=exponent, threshold=threshold, log=log, clip=clip)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RadialBasisFunctionInterpolation(object):
    def __init__(self):
        self.label = "Radial Basis Function Interpolation"
        self.description = "Interpolates vector points into a raster surface using a radial basis function scheme."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        field = arcpy.Parameter(
            displayName="Field Name",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [i.name]

        use_z = arcpy.Parameter(
            displayName="Use z-coordinate instead of field?",
            name="use_z",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        use_z.value = 'False'

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        radius = arcpy.Parameter(
            displayName="Search Radius (map units)",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        min_points = arcpy.Parameter(
            displayName="Min. Number of Points",
            name="min_points",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")

        func_type = arcpy.Parameter(
            displayName="Radial Basis Function Type",
            name="func_type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        func_type.filter.type = "ValueList"
        func_type.filter.list = ['ThinPlateSpline', 'PolyHarmonic', 'Gaussian', 'MultiQuadric', 'InverseMultiQuadric']
        func_type.value = 'ThinPlateSpline'

        poly_order = arcpy.Parameter(
            displayName="Polynomial Order",
            name="poly_order",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        poly_order.filter.type = "ValueList"
        poly_order.filter.list = ['none', 'constant', 'affine']
        poly_order.value = 'none'

        weight = arcpy.Parameter(
            displayName="Weight",
            name="weight",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        weight.value = '0.1'

        cell_size = arcpy.Parameter(
            displayName="Cell Size (optional)",
            name="cell_size",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        base = arcpy.Parameter(
            displayName="Base Raster File (optional)",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        params = [i, field, use_z, output, radius, min_points, func_type, poly_order, weight, cell_size, base]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        use_z = parameters[2].valueAsText
        output = parameters[3].valueAsText
        radius = parameters[4].valueAsText
        min_points = parameters[5].valueAsText
        func_type = parameters[6].valueAsText
        poly_order = parameters[7].valueAsText
        weight = parameters[8].valueAsText
        cell_size = parameters[9].valueAsText
        base = parameters[10].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.radial_basis_function_interpolation(i=i, field=field, use_z=use_z, output=output, radius=radius, min_points=min_points, func_type=func_type, poly_order=poly_order, weight=weight, cell_size=cell_size, base=base)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RadiusOfGyration(object):
    def __init__(self):
        self.label = "Radius Of Gyration"
        self.description = "Calculates the distance of cells from their polygon's centroid."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        text_output = arcpy.Parameter(
            displayName="Output text?",
            name="text_output",
            datatype="GPBoolean",
            parameterType="Required",
            direction="Input")

        params = [i, output, text_output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        text_output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.radius_of_gyration(i=i, output=output, text_output=text_output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RaiseWalls(object):
    def __init__(self):
        self.label = "Raise Walls"
        self.description = "Raises walls in a DEM along a line or around a polygon, e.g. a watershed."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        input = arcpy.Parameter(
            displayName="Input Vector Line or Polygon File",
            name="input",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        breach = arcpy.Parameter(
            displayName="Input Breach Lines (optional)",
            name="breach",
            datatype="GPFeatureLayer",
            parameterType="Optional",
            direction="Input")
        breach.filter.list = ["Polyline"]

        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        height = arcpy.Parameter(
            displayName="Wall Height",
            name="height",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        height.value = '100.0'

        params = [input, breach, dem, output, height]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        breach = parameters[1].valueAsText
        if breach is not None:
            desc = arcpy.Describe(breach)
            breach = desc.catalogPath
        dem = parameters[2].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[3].valueAsText
        height = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.raise_walls(i=i, breach=breach, dem=dem, output=output, height=height)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RandomField(object):
    def __init__(self):
        self.label = "Random Field"
        self.description = "Creates an image containing random values."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        base = arcpy.Parameter(
            displayName="Input Base File",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [base, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        base = parameters[0].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.random_field(base=base, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RandomForestClassification(object):
    def __init__(self):
        self.label = "Random Forest Classification"
        self.description = "Performs a supervised random forest classification using training site polygons/points and predictor rasters."
        self.category = "Machine Learning"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Predictor Rasters",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        training = arcpy.Parameter(
            displayName="Input Training Polygons/Points",
            name="training",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        field = arcpy.Parameter(
            displayName="Class Field Name",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [training.name]

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        split_criterion = arcpy.Parameter(
            displayName="Split Criterion",
            name="split_criterion",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        split_criterion.filter.type = "ValueList"
        split_criterion.filter.list = ['Gini', 'Entropy', 'ClassificationError']
        split_criterion.value = 'Gini'

        n_trees = arcpy.Parameter(
            displayName="Number of Trees in Forest",
            name="n_trees",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        n_trees.value = '500'

        min_samples_leaf = arcpy.Parameter(
            displayName="Min Number of Samples to be a Leaf",
            name="min_samples_leaf",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_samples_leaf.value = '1'

        min_samples_split = arcpy.Parameter(
            displayName="Min Number of Samples Needed to Split Node",
            name="min_samples_split",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_samples_split.value = '2'

        test_proportion = arcpy.Parameter(
            displayName="Test Proportion",
            name="test_proportion",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        test_proportion.value = '0.2'

        params = [inputs, training, field, output, split_criterion, n_trees, min_samples_leaf, min_samples_split, test_proportion]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        training = parameters[1].valueAsText
        if training is not None:
            desc = arcpy.Describe(training)
            training = desc.catalogPath
        field = parameters[2].valueAsText
        output = parameters[3].valueAsText
        split_criterion = parameters[4].valueAsText
        n_trees = parameters[5].valueAsText
        min_samples_leaf = parameters[6].valueAsText
        min_samples_split = parameters[7].valueAsText
        test_proportion = parameters[8].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.random_forest_classification(inputs=inputs, training=training, field=field, output=output, split_criterion=split_criterion, n_trees=n_trees, min_samples_leaf=min_samples_leaf, min_samples_split=min_samples_split, test_proportion=test_proportion)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RandomForestRegression(object):
    def __init__(self):
        self.label = "Random Forest Regression"
        self.description = "Performs a random forest regression analysis using training site data and predictor rasters."
        self.category = "Machine Learning"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Predictor Rasters",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        training = arcpy.Parameter(
            displayName="Input Training Points",
            name="training",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        training.filter.list = ["Point"]

        field = arcpy.Parameter(
            displayName="Response Variable Field Name",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [training.name]

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        n_trees = arcpy.Parameter(
            displayName="Number of Trees in Forest",
            name="n_trees",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        n_trees.value = '100'

        min_samples_leaf = arcpy.Parameter(
            displayName="Min Number of Samples to be a Leaf",
            name="min_samples_leaf",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_samples_leaf.value = '1'

        min_samples_split = arcpy.Parameter(
            displayName="Min Number of Samples Needed to Split Node",
            name="min_samples_split",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_samples_split.value = '2'

        test_proportion = arcpy.Parameter(
            displayName="Test Proportion",
            name="test_proportion",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        test_proportion.value = '0.2'

        params = [inputs, training, field, output, n_trees, min_samples_leaf, min_samples_split, test_proportion]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        training = parameters[1].valueAsText
        if training is not None:
            desc = arcpy.Describe(training)
            training = desc.catalogPath
        field = parameters[2].valueAsText
        output = parameters[3].valueAsText
        n_trees = parameters[4].valueAsText
        min_samples_leaf = parameters[5].valueAsText
        min_samples_split = parameters[6].valueAsText
        test_proportion = parameters[7].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.random_forest_regression(inputs=inputs, training=training, field=field, output=output, n_trees=n_trees, min_samples_leaf=min_samples_leaf, min_samples_split=min_samples_split, test_proportion=test_proportion)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RandomSample(object):
    def __init__(self):
        self.label = "Random Sample"
        self.description = "Creates an image containing randomly located sample grid cells with unique IDs."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        base = arcpy.Parameter(
            displayName="Input Base File",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        num_samples = arcpy.Parameter(
            displayName="Num. Samples",
            name="num_samples",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        num_samples.value = '1000'

        params = [base, output, num_samples]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        base = parameters[0].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        output = parameters[1].valueAsText
        num_samples = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.random_sample(base=base, output=output, num_samples=num_samples)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RangeFilter(object):
    def __init__(self):
        self.label = "Range Filter"
        self.description = "Assigns each cell in the output grid the range of values in a moving window centred on each grid cell in the input raster."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        params = [i, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.range_filter(i=i, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RasterArea(object):
    def __init__(self):
        self.label = "Raster Area"
        self.description = "Calculates the area of polygons or classes within a raster image."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        out_text = arcpy.Parameter(
            displayName="Output text?",
            name="out_text",
            datatype="GPBoolean",
            parameterType="Required",
            direction="Input")

        units = arcpy.Parameter(
            displayName="Units",
            name="units",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        units.filter.type = "ValueList"
        units.filter.list = ['grid cells', 'map units']
        units.value = 'grid cells'

        zero_back = arcpy.Parameter(
            displayName="Treat zero values as background?",
            name="zero_back",
            datatype="GPBoolean",
            parameterType="Required",
            direction="Input")

        params = [i, output, out_text, units, zero_back]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        out_text = parameters[2].valueAsText
        units = parameters[3].valueAsText
        zero_back = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.raster_area(i=i, output=output, out_text=out_text, units=units, zero_back=zero_back)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RasterCalculator(object):
    def __init__(self):
        self.label = "Raster Calculator"
        self.description = "Performs a complex mathematical operations on one or more input raster images on a cell-to-cell basis."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        statement = arcpy.Parameter(
            displayName="Statement:",
            name="statement",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [statement, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        statement = parameters[0].valueAsText
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.raster_calculator(statement=statement, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RasterCellAssignment(object):
    def __init__(self):
        self.label = "Raster Cell Assignment"
        self.description = "Assign row or column number to cells."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        assign = arcpy.Parameter(
            displayName="Which spatial variable should be assigned?",
            name="assign",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        assign.filter.type = "ValueList"
        assign.filter.list = ['column', 'row', 'x', 'y']
        assign.value = 'column'

        params = [i, output, assign]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        assign = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.raster_cell_assignment(i=i, output=output, assign=assign)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RasterHistogram(object):
    def __init__(self):
        self.label = "Raster Histogram"
        self.description = "Creates a histogram from raster values."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.raster_histogram(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RasterPerimeter(object):
    def __init__(self):
        self.label = "Raster Perimeter"
        self.description = "Calculates the perimeters of polygons or classes within a raster image."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        out_text = arcpy.Parameter(
            displayName="Output text?",
            name="out_text",
            datatype="GPBoolean",
            parameterType="Required",
            direction="Input")

        units = arcpy.Parameter(
            displayName="Units",
            name="units",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        units.filter.type = "ValueList"
        units.filter.list = ['grid cells', 'map units']
        units.value = 'grid cells'

        zero_back = arcpy.Parameter(
            displayName="Treat zero values as background?",
            name="zero_back",
            datatype="GPBoolean",
            parameterType="Required",
            direction="Input")

        params = [i, output, out_text, units, zero_back]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        out_text = parameters[2].valueAsText
        units = parameters[3].valueAsText
        zero_back = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.raster_perimeter(i=i, output=output, out_text=out_text, units=units, zero_back=zero_back)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RasterStreamsToVector(object):
    def __init__(self):
        self.label = "Raster Streams To Vector"
        self.description = "Converts a raster stream file into a vector file."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [streams, d8_pntr, output, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        streams = parameters[0].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        d8_pntr = parameters[1].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.raster_streams_to_vector(streams=streams, d8_pntr=d8_pntr, output=output, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RasterSummaryStats(object):
    def __init__(self):
        self.label = "Raster Summary Stats"
        self.description = "Measures a rasters min, max, average, standard deviation, num. non-nodata cells, and total."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.raster_summary_stats(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RasterToVectorLines(object):
    def __init__(self):
        self.label = "Raster To Vector Lines"
        self.description = "Converts a raster lines features into a vector of the POLYLINE shapetype"
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster Lines File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.raster_to_vector_lines(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RasterToVectorPoints(object):
    def __init__(self):
        self.label = "Raster To Vector Points"
        self.description = "Converts a raster dataset to a vector of the POINT shapetype."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Points File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.raster_to_vector_points(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RasterToVectorPolygons(object):
    def __init__(self):
        self.label = "Raster To Vector Polygons"
        self.description = "Converts a raster dataset to a vector of the POLYGON shapetype."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Polygons File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.raster_to_vector_polygons(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RasterizeStreams(object):
    def __init__(self):
        self.label = "Rasterize Streams"
        self.description = "Rasterizes vector streams based on Lindsay (2016) method."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        streams = arcpy.Parameter(
            displayName="Input Vector Streams File",
            name="streams",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        streams.filter.list = ["Polyline"]

        base = arcpy.Parameter(
            displayName="Input Base Raster File",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        nodata = arcpy.Parameter(
            displayName="Use NoData value for background?",
            name="nodata",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        nodata.value = 'True'

        feature_id = arcpy.Parameter(
            displayName="Use feature number as output value?",
            name="feature_id",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        feature_id.value = 'False'

        params = [streams, base, output, nodata, feature_id]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        streams = parameters[0].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        base = parameters[1].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        output = parameters[2].valueAsText
        nodata = parameters[3].valueAsText
        feature_id = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.rasterize_streams(streams=streams, base=base, output=output, nodata=nodata, feature_id=feature_id)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Reciprocal(object):
    def __init__(self):
        self.label = "Reciprocal"
        self.description = "Returns the reciprocal (i.e. 1 / z) of values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.reciprocal(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Reclass(object):
    def __init__(self):
        self.label = "Reclass"
        self.description = "Reclassifies the values in a raster image."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        reclass_vals = arcpy.Parameter(
            displayName="Reclass Values (new value; from value; to less than)",
            name="reclass_vals",
            datatype="GPString",
            parameterType="Required",
            direction="Input")

        assign_mode = arcpy.Parameter(
            displayName="Operate in assign mode? (i.e. Reclass data are pair values rather than triplets)",
            name="assign_mode",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [i, output, reclass_vals, assign_mode]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        reclass_vals = parameters[2].valueAsText
        assign_mode = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.reclass(i=i, output=output, reclass_vals=reclass_vals, assign_mode=assign_mode)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ReclassEqualInterval(object):
    def __init__(self):
        self.label = "Reclass Equal Interval"
        self.description = "Reclassifies the values in a raster image based on equal-ranges."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        interval = arcpy.Parameter(
            displayName="Class Interval Size",
            name="interval",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        interval.value = '10.0'

        start_val = arcpy.Parameter(
            displayName="Starting Value",
            name="start_val",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        end_val = arcpy.Parameter(
            displayName="Ending Value",
            name="end_val",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [i, output, interval, start_val, end_val]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        interval = parameters[2].valueAsText
        start_val = parameters[3].valueAsText
        end_val = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.reclass_equal_interval(i=i, output=output, interval=interval, start_val=start_val, end_val=end_val)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ReclassFromFile(object):
    def __init__(self):
        self.label = "Reclass From File"
        self.description = "Reclassifies the values in a raster image using reclass ranges in a text file."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        reclass_file = arcpy.Parameter(
            displayName="Input Reclass Text File",
            name="reclass_file",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, reclass_file, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        reclass_file = parameters[1].valueAsText
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.reclass_from_file(i=i, reclass_file=reclass_file, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ReconcileMultipleHeaders(object):
    def __init__(self):
        self.label = "Reconcile Multiple Headers"
        self.description = "This tool adjusts the crop yield values for data sets collected with multiple headers or combines."
        self.category = "Precision Agriculture"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Points",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        region_field = arcpy.Parameter(
            displayName="Region Field Name",
            name="region_field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        region_field.parameterDependencies = [i.name]

        yield_field = arcpy.Parameter(
            displayName="Yield Field Name",
            name="yield_field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        yield_field.parameterDependencies = [i.name]

        output = arcpy.Parameter(
            displayName="Output Points",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        radius = arcpy.Parameter(
            displayName="Search Radius (m)",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        min_yield = arcpy.Parameter(
            displayName="Minimum Yield",
            name="min_yield",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        max_yield = arcpy.Parameter(
            displayName="Maximum Yield",
            name="max_yield",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        mean_tonnage = arcpy.Parameter(
            displayName="Overall Average Tonnage (Optional)",
            name="mean_tonnage",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [i, region_field, yield_field, output, radius, min_yield, max_yield, mean_tonnage]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        region_field = parameters[1].valueAsText
        yield_field = parameters[2].valueAsText
        output = parameters[3].valueAsText
        radius = parameters[4].valueAsText
        min_yield = parameters[5].valueAsText
        max_yield = parameters[6].valueAsText
        mean_tonnage = parameters[7].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.reconcile_multiple_headers(i=i, region_field=region_field, yield_field=yield_field, output=output, radius=radius, min_yield=min_yield, max_yield=max_yield, mean_tonnage=mean_tonnage)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RecoverFlightlineInfo(object):
    def __init__(self):
        self.label = "Recover Flightline Info"
        self.description = "Associates LiDAR points by their flightlines."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR Points",
            name="i",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output LiDAR Points",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")

        max_time_diff = arcpy.Parameter(
            displayName="Maximum In-Flightline Time Difference (seconds)",
            name="max_time_diff",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        max_time_diff.value = '5.0'

        pt_src_id = arcpy.Parameter(
            displayName="Add flightline info to the Point Source ID?",
            name="pt_src_id",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        pt_src_id.value = 'False'

        user_data = arcpy.Parameter(
            displayName="Add flightline info to the User Data?",
            name="user_data",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        user_data.value = 'False'

        rgb = arcpy.Parameter(
            displayName="Add flightline info to the RGB colour data?",
            name="rgb",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        rgb.value = 'False'

        params = [i, output, max_time_diff, pt_src_id, user_data, rgb]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        max_time_diff = parameters[2].valueAsText
        pt_src_id = parameters[3].valueAsText
        user_data = parameters[4].valueAsText
        rgb = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.recover_flightline_info(i=i, output=output, max_time_diff=max_time_diff, pt_src_id=pt_src_id, user_data=user_data, rgb=rgb)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RecreatePassLines(object):
    def __init__(self):
        self.label = "Recreate Pass Lines"
        self.description = "This tool can be used to approximate the harvester pass lines from yield points."
        self.category = "Precision Agriculture"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Points",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        yield_field_name = arcpy.Parameter(
            displayName="Yield Field Name",
            name="yield_field_name",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        yield_field_name.parameterDependencies = [i.name]

        output_lines = arcpy.Parameter(
            displayName="Output Pass Line",
            name="output_lines",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        output_points = arcpy.Parameter(
            displayName="Output Points",
            name="output_points",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        max_change_in_heading = arcpy.Parameter(
            displayName="Max Change In Heading (degrees)",
            name="max_change_in_heading",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        max_change_in_heading.value = '25.0'

        ignore_zeros = arcpy.Parameter(
            displayName="Ignore zero-valued yield points?",
            name="ignore_zeros",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        ignore_zeros.value = 'False'

        params = [i, yield_field_name, output_lines, output_points, max_change_in_heading, ignore_zeros]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        yield_field_name = parameters[1].valueAsText
        output_lines = parameters[2].valueAsText
        output_points = parameters[3].valueAsText
        max_change_in_heading = parameters[4].valueAsText
        ignore_zeros = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.recreate_pass_lines(i=i, yield_field_name=yield_field_name, output_lines=output_lines, output_points=output_points, max_change_in_heading=max_change_in_heading, ignore_zeros=ignore_zeros)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ReinitializeAttributeTable(object):
    def __init__(self):
        self.label = "Reinitialize Attribute Table"
        self.description = "Reinitializes a vector's attribute table deleting all fields but the feature ID (FID)."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.reinitialize_attribute_table(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RelatedCircumscribingCircle(object):
    def __init__(self):
        self.label = "Related Circumscribing Circle"
        self.description = "Calculates the related circumscribing circle of vector polygons."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.related_circumscribing_circle(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RelativeAspect(object):
    def __init__(self):
        self.label = "Relative Aspect"
        self.description = "Calculates relative aspect (relative to a user-specified direction) from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        azimuth = arcpy.Parameter(
            displayName="Azimuth",
            name="azimuth",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        azimuth.value = '0.0'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, azimuth, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        azimuth = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.relative_aspect(dem=dem, output=output, azimuth=azimuth, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RelativeTopographicPosition(object):
    def __init__(self):
        self.label = "Relative Topographic Position"
        self.description = "Calculates the relative topographic position index from a DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        params = [dem, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.relative_topographic_position(dem=dem, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RemoveFieldEdgePoints(object):
    def __init__(self):
        self.label = "Remove Field Edge Points"
        self.description = "This tool can be used to remove, or flag, most of the points along the edges from a crop yield data set."
        self.category = "Precision Agriculture"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Points",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        output = arcpy.Parameter(
            displayName="Output Points",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        dist = arcpy.Parameter(
            displayName="Average Distance Between Passes (m)",
            name="dist",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        max_change_in_heading = arcpy.Parameter(
            displayName="Max Change In Heading (degrees)",
            name="max_change_in_heading",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        max_change_in_heading.value = '25.0'

        flag_edges = arcpy.Parameter(
            displayName="Don't remove edge points, just flag them?",
            name="flag_edges",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        flag_edges.value = 'False'

        params = [i, output, dist, max_change_in_heading, flag_edges]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        dist = parameters[2].valueAsText
        max_change_in_heading = parameters[3].valueAsText
        flag_edges = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.remove_field_edge_points(i=i, output=output, dist=dist, max_change_in_heading=max_change_in_heading, flag_edges=flag_edges)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RemoveOffTerrainObjects(object):
    def __init__(self):
        self.label = "Remove Off Terrain Objects"
        self.description = "Removes off-terrain objects from a raster digital elevation model (DEM)."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filter = arcpy.Parameter(
            displayName="Filter Dimension",
            name="filter",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        filter.value = '11'

        slope = arcpy.Parameter(
            displayName="Slope Threshold",
            name="slope",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        slope.value = '15.0'

        params = [dem, output, filter, slope]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        filter = parameters[2].valueAsText
        slope = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.remove_off_terrain_objects(dem=dem, output=output, filter=filter, slope=slope)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RemovePolygonHoles(object):
    def __init__(self):
        self.label = "Remove Polygon Holes"
        self.description = "Removes holes within the features of a vector polygon file."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.remove_polygon_holes(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RemoveRasterPolygonHoles(object):
    def __init__(self):
        self.label = "Remove Raster Polygon Holes"
        self.description = "Removes polygon holes, or 'donut-holes', from raster polygons."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster Image",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        threshold = arcpy.Parameter(
            displayName="Threshold Size (Grid Cells):",
            name="threshold",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        threshold.value = '3'

        use_diagonals = arcpy.Parameter(
            displayName="Use diagonal neighbours during clumping?",
            name="use_diagonals",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        use_diagonals.value = 'True'

        params = [i, output, threshold, use_diagonals]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        threshold = parameters[2].valueAsText
        use_diagonals = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.remove_raster_polygon_holes(i=i, output=output, threshold=threshold, use_diagonals=use_diagonals)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RemoveShortStreams(object):
    def __init__(self):
        self.label = "Remove Short Streams"
        self.description = "Removes short first-order streams from a stream network."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        min_length = arcpy.Parameter(
            displayName="Minimum Tributary Length (map units)",
            name="min_length",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [d8_pntr, streams, output, min_length, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        min_length = parameters[3].valueAsText
        esri_pntr = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.remove_short_streams(d8_pntr=d8_pntr, streams=streams, output=output, min_length=min_length, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RemoveSpurs(object):
    def __init__(self):
        self.label = "Remove Spurs"
        self.description = "Removes the spurs (pruning operation) from a Boolean line image; intended to be used on the output of the LineThinning tool."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        iterations = arcpy.Parameter(
            displayName="Maximum Iterations",
            name="iterations",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        iterations.value = '10'

        params = [i, output, iterations]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        iterations = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.remove_spurs(i=i, output=output, iterations=iterations)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RepairStreamVectorTopology(object):
    def __init__(self):
        self.label = "Repair Stream Vector Topology"
        self.description = "This tool resolves topological errors and inconsistencies associated with digitized vector streams."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Lines",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polyline"]

        output = arcpy.Parameter(
            displayName="Output Lines",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        dist = arcpy.Parameter(
            displayName="Snap Distance",
            name="dist",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        params = [i, output, dist]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        dist = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.repair_stream_vector_topology(i=i, output=output, dist=dist)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Resample(object):
    def __init__(self):
        self.label = "Resample"
        self.description = "Resamples one or more input images into a destination image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        cell_size = arcpy.Parameter(
            displayName="Cell Size (optional)",
            name="cell_size",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        base = arcpy.Parameter(
            displayName="Base Raster File (optional)",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        method = arcpy.Parameter(
            displayName="Resampling Method",
            name="method",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        method.filter.type = "ValueList"
        method.filter.list = ['nn', 'bilinear', 'cc']
        method.value = 'cc'

        params = [inputs, output, cell_size, base, method]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        cell_size = parameters[2].valueAsText
        base = parameters[3].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        method = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.resample(inputs=inputs, output=output, cell_size=cell_size, base=base, method=method)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RescaleValueRange(object):
    def __init__(self):
        self.label = "Rescale Value Range"
        self.description = "Performs a min-max contrast stretch on an input greytone image."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        out_min_val = arcpy.Parameter(
            displayName="Output Raster Minimum Value",
            name="out_min_val",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        out_max_val = arcpy.Parameter(
            displayName="Output Raster Maximum Value",
            name="out_max_val",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        clip_min = arcpy.Parameter(
            displayName="Lower-Tail Clip Value (optional)",
            name="clip_min",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        clip_max = arcpy.Parameter(
            displayName="Upper-Tail Clip Value (optional)",
            name="clip_max",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [i, output, out_min_val, out_max_val, clip_min, clip_max]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        out_min_val = parameters[2].valueAsText
        out_max_val = parameters[3].valueAsText
        clip_min = parameters[4].valueAsText
        clip_max = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.rescale_value_range(i=i, output=output, out_min_val=out_min_val, out_max_val=out_max_val, clip_min=clip_min, clip_max=clip_max)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RgbToIhs(object):
    def __init__(self):
        self.label = "Rgb To Ihs"
        self.description = "Converts red, green, and blue (RGB) images into intensity, hue, and saturation (IHS) images."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        red = arcpy.Parameter(
            displayName="Input Red Band File (optional; only if colour-composite not specified)",
            name="red",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        green = arcpy.Parameter(
            displayName="Input Green Band File (optional; only if colour-composite not specified)",
            name="green",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        blue = arcpy.Parameter(
            displayName="Input Blue Band File (optional; only if colour-composite not specified)",
            name="blue",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        composite = arcpy.Parameter(
            displayName="Input Colour-Composite Image File (optional; only if individual bands not specified)",
            name="composite",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        intensity = arcpy.Parameter(
            displayName="Output Intensity File",
            name="intensity",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        intensity.filter.list = ["tif"]

        hue = arcpy.Parameter(
            displayName="Output Hue File",
            name="hue",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        hue.filter.list = ["tif"]

        saturation = arcpy.Parameter(
            displayName="Output Saturation File",
            name="saturation",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        saturation.filter.list = ["tif"]

        params = [red, green, blue, composite, intensity, hue, saturation]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        red = parameters[0].valueAsText
        if red is not None:
            desc = arcpy.Describe(red)
            red = desc.catalogPath
        green = parameters[1].valueAsText
        if green is not None:
            desc = arcpy.Describe(green)
            green = desc.catalogPath
        blue = parameters[2].valueAsText
        if blue is not None:
            desc = arcpy.Describe(blue)
            blue = desc.catalogPath
        composite = parameters[3].valueAsText
        if composite is not None:
            desc = arcpy.Describe(composite)
            composite = desc.catalogPath
        intensity = parameters[4].valueAsText
        hue = parameters[5].valueAsText
        saturation = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.rgb_to_ihs(red=red, green=green, blue=blue, composite=composite, intensity=intensity, hue=hue, saturation=saturation)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Rho8FlowAccumulation(object):
    def __init__(self):
        self.label = "Rho8 Flow Accumulation"
        self.description = "Calculates Fairfield and Leymarie (1991) flow accumulation."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input DEM or Rho8 Pointer File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        out_type = arcpy.Parameter(
            displayName="Output Type",
            name="out_type",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        out_type.filter.type = "ValueList"
        out_type.filter.list = ['cells', 'specific contributing area', 'catchment area']
        out_type.value = 'specific contributing area'

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        clip = arcpy.Parameter(
            displayName="Clip the upper tail by 1%?",
            name="clip",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        clip.value = 'False'

        pntr = arcpy.Parameter(
            displayName="Is the input raster a Rho8 flow pointer?",
            name="pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        pntr.value = 'False'

        esri_pntr = arcpy.Parameter(
            displayName="If a pointer is input, does it use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [i, output, out_type, log, clip, pntr, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        out_type = parameters[2].valueAsText
        log = parameters[3].valueAsText
        clip = parameters[4].valueAsText
        pntr = parameters[5].valueAsText
        esri_pntr = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.rho8_flow_accumulation(i=i, output=output, out_type=out_type, log=log, clip=clip, pntr=pntr, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Rho8Pointer(object):
    def __init__(self):
        self.label = "Rho8 Pointer"
        self.description = "Calculates a stochastic Rho8 flow pointer raster from an input DEM."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Should the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [dem, output, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        esri_pntr = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.rho8_pointer(dem=dem, output=output, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RingCurvature(object):
    def __init__(self):
        self.label = "Ring Curvature"
        self.description = "This tool calculates ring curvature from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input Raster DEM",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster Image",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z-factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        zfactor.value = '1.0'

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.ring_curvature(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RiverCenterlines(object):
    def __init__(self):
        self.label = "River Centerlines"
        self.description = "Maps river centerlines from an input water raster."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster Image",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Vector Lines File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        min_length = arcpy.Parameter(
            displayName="Min. Line Length (In Grid Cells)",
            name="min_length",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_length.value = '3'

        radius = arcpy.Parameter(
            displayName="Search Radius (In Grid Cells)",
            name="radius",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        radius.value = '4'

        params = [i, output, min_length, radius]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        min_length = parameters[2].valueAsText
        radius = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.river_centerlines(i=i, output=output, min_length=min_length, radius=radius)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RobertsCrossFilter(object):
    def __init__(self):
        self.label = "Roberts Cross Filter"
        self.description = "Performs a Robert's cross edge-detection filter on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        clip = arcpy.Parameter(
            displayName="Distribution Tail Clip Amount (Percent)",
            name="clip",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        clip.value = '0.0'

        params = [i, output, clip]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        clip = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.roberts_cross_filter(i=i, output=output, clip=clip)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RootMeanSquareError(object):
    def __init__(self):
        self.label = "Root Mean Square Error"
        self.description = "Calculates the RMSE and other accuracy statistics."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        base = arcpy.Parameter(
            displayName="Input Base File",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        params = [i, base]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        base = parameters[1].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.root_mean_square_error(i=i, base=base)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Rotor(object):
    def __init__(self):
        self.label = "Rotor"
        self.description = "This tool calculates rotor from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input Raster DEM",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster Image",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z-factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        zfactor.value = '1.0'

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.rotor(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Round(object):
    def __init__(self):
        self.label = "Round"
        self.description = "Rounds the values in an input raster to the nearest integer value."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.round(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class RuggednessIndex(object):
    def __init__(self):
        self.label = "Ruggedness Index"
        self.description = "Calculates the Riley et al.'s (1999) terrain ruggedness index from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.ruggedness_index(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ScharrFilter(object):
    def __init__(self):
        self.label = "Scharr Filter"
        self.description = "Performs a Scharr edge-detection filter on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        clip = arcpy.Parameter(
            displayName="Distribution Tail Clip Amount (Percent)",
            name="clip",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        clip.value = '0.0'

        params = [i, output, clip]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        clip = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.scharr_filter(i=i, output=output, clip=clip)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SedimentTransportIndex(object):
    def __init__(self):
        self.label = "Sediment Transport Index"
        self.description = "Calculates the sediment transport index."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        sca = arcpy.Parameter(
            displayName="Input Specific Contributing Area (SCA) File",
            name="sca",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        slope = arcpy.Parameter(
            displayName="Input Slope File",
            name="slope",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        sca_exponent = arcpy.Parameter(
            displayName="Specific Contributing Area (SCA) Exponent",
            name="sca_exponent",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        sca_exponent.value = '0.4'

        slope_exponent = arcpy.Parameter(
            displayName="Slope Exponent",
            name="slope_exponent",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        slope_exponent.value = '1.3'

        params = [sca, slope, output, sca_exponent, slope_exponent]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        sca = parameters[0].valueAsText
        if sca is not None:
            desc = arcpy.Describe(sca)
            sca = desc.catalogPath
        slope = parameters[1].valueAsText
        if slope is not None:
            desc = arcpy.Describe(slope)
            slope = desc.catalogPath
        output = parameters[2].valueAsText
        sca_exponent = parameters[3].valueAsText
        slope_exponent = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.sediment_transport_index(sca=sca, slope=slope, output=output, sca_exponent=sca_exponent, slope_exponent=slope_exponent)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SelectTilesByPolygon(object):
    def __init__(self):
        self.label = "Select Tiles By Polygon"
        self.description = "Copies LiDAR tiles overlapping with a polygon into an output directory."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        indir = arcpy.Parameter(
            displayName="Input Directory",
            name="indir",
            datatype="DEFolder",
            parameterType="Required",
            direction="Input")

        outdir = arcpy.Parameter(
            displayName="Output Directory",
            name="outdir",
            datatype="DEFolder",
            parameterType="Required",
            direction="Input")

        polygons = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="polygons",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        polygons.filter.list = ["Polygon"]

        params = [indir, outdir, polygons]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        indir = parameters[0].valueAsText
        outdir = parameters[1].valueAsText
        polygons = parameters[2].valueAsText
        if polygons is not None:
            desc = arcpy.Describe(polygons)
            polygons = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.select_tiles_by_polygon(indir=indir, outdir=outdir, polygons=polygons)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SetNodataValue(object):
    def __init__(self):
        self.label = "Set Nodata Value"
        self.description = "Assign the NoData value for an input image."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        back_value = arcpy.Parameter(
            displayName="Background Value",
            name="back_value",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        back_value.value = '0.0'

        params = [i, output, back_value]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        back_value = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.set_nodata_value(i=i, output=output, back_value=back_value)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ShadowAnimation(object):
    def __init__(self):
        self.label = "Shadow Animation"
        self.description = "This tool creates an animated GIF of shadows based on an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Digital Surface Model (DSM) Raster",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        palette = arcpy.Parameter(
            displayName="DSM Palette",
            name="palette",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        palette.filter.type = "ValueList"
        palette.filter.list = ['atlas', 'high_relief', 'arid', 'soft', 'muted', 'light_quant', 'purple', 'viridi', 'gn_yl', 'pi_y_g', 'bl_yl_rd', 'deep', 'none']
        palette.value = 'atlas'

        output = arcpy.Parameter(
            displayName="Output File (*.html)",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        max_dist = arcpy.Parameter(
            displayName="Maximum Search Distance (xy units)",
            name="max_dist",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        date = arcpy.Parameter(
            displayName="Date (DD/MM/YYYY)",
            name="date",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        date.value = '21/06/2021'

        interval = arcpy.Parameter(
            displayName="Time Interval (in minutes)",
            name="interval",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        interval.value = '15'

        location = arcpy.Parameter(
            displayName="Lat/Long/UTC-offset (e.g. 43.5448/-80.2482/-4)",
            name="location",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        location.value = '43.5448/-80.2482/-4'

        height = arcpy.Parameter(
            displayName="Image Height (in pixels)",
            name="height",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        height.value = '600'

        delay = arcpy.Parameter(
            displayName="Delay (in milliseconds)",
            name="delay",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        delay.value = '250'

        label = arcpy.Parameter(
            displayName="Label text (blank for none)",
            name="label",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        params = [i, palette, output, max_dist, date, interval, location, height, delay, label]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        palette = parameters[1].valueAsText
        output = parameters[2].valueAsText
        max_dist = parameters[3].valueAsText
        date = parameters[4].valueAsText
        interval = parameters[5].valueAsText
        location = parameters[6].valueAsText
        height = parameters[7].valueAsText
        delay = parameters[8].valueAsText
        label = parameters[9].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.shadow_animation(i=i, palette=palette, output=output, max_dist=max_dist, date=date, interval=interval, location=location, height=height, delay=delay, label=label)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ShadowImage(object):
    def __init__(self):
        self.label = "Shadow Image"
        self.description = "This tool creates a raster of shadow areas based on an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Digital Surface Model (DSM) Raster",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        palette = arcpy.Parameter(
            displayName="DSM Palette",
            name="palette",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        palette.filter.type = "ValueList"
        palette.filter.list = ['atlas', 'high_relief', 'arid', 'soft', 'muted', 'light_quant', 'purple', 'viridis', 'gn_yl', 'pi_y_g', 'bl_yl_rd', 'deep', 'none']
        palette.value = 'soft'

        max_dist = arcpy.Parameter(
            displayName="Maximum Search Distance (xy units)",
            name="max_dist",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        date = arcpy.Parameter(
            displayName="Date (DD/MM/YYYY)",
            name="date",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        date.value = '21/06/2021'

        time = arcpy.Parameter(
            displayName="Time (HH:MM, e.g. 03:15AM or 14:30)",
            name="time",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        time.value = '13:00'

        location = arcpy.Parameter(
            displayName="Lat/Long/UTC-offset (e.g. 43.5448/-80.2482/-4)",
            name="location",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        location.value = '43.5448/-80.2482/-4'

        params = [i, output, palette, max_dist, date, time, location]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        palette = parameters[2].valueAsText
        max_dist = parameters[3].valueAsText
        date = parameters[4].valueAsText
        time = parameters[5].valueAsText
        location = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.shadow_image(i=i, output=output, palette=palette, max_dist=max_dist, date=date, time=time, location=location)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ShapeComplexityIndex(object):
    def __init__(self):
        self.label = "Shape Complexity Index"
        self.description = "Calculates overall polygon shape complexity or irregularity."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        params = [i]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.shape_complexity_index(i=i)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ShapeComplexityIndexRaster(object):
    def __init__(self):
        self.label = "Shape Complexity Index Raster"
        self.description = "Calculates the complexity of raster polygons or classes."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.shape_complexity_index_raster(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ShapeIndex(object):
    def __init__(self):
        self.label = "Shape Index"
        self.description = "This tool calculates the shape index from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input Raster DEM",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster Image",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        zfactor = arcpy.Parameter(
            displayName="Z-factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        zfactor.value = '1.0'

        params = [dem, output, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        zfactor = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.shape_index(dem=dem, output=output, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ShreveStreamMagnitude(object):
    def __init__(self):
        self.label = "Shreve Stream Magnitude"
        self.description = "Assigns the Shreve stream magnitude to each link in a stream network."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [d8_pntr, streams, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        zero_background = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.shreve_stream_magnitude(d8_pntr=d8_pntr, streams=streams, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SigmoidalContrastStretch(object):
    def __init__(self):
        self.label = "Sigmoidal Contrast Stretch"
        self.description = "Performs a sigmoidal contrast stretch on input images."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        cutoff = arcpy.Parameter(
            displayName="Cutoff Value (0.0 - 0.95)",
            name="cutoff",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        cutoff.value = '0.0'

        gain = arcpy.Parameter(
            displayName="Gain Value",
            name="gain",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        gain.value = '1.0'

        num_tones = arcpy.Parameter(
            displayName="Number of Tones",
            name="num_tones",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        num_tones.value = '256'

        params = [i, output, cutoff, gain, num_tones]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        cutoff = parameters[2].valueAsText
        gain = parameters[3].valueAsText
        num_tones = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.sigmoidal_contrast_stretch(i=i, output=output, cutoff=cutoff, gain=gain, num_tones=num_tones)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Sin(object):
    def __init__(self):
        self.label = "Sin"
        self.description = "Returns the sine (sin) of each values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.sin(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SinglePartToMultiPart(object):
    def __init__(self):
        self.label = "Single Part To Multi Part"
        self.description = "Converts a vector file containing multi-part features into a vector containing only single-part features."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Line or Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        field = arcpy.Parameter(
            displayName="Grouping ID Field Name",
            name="field",
            datatype="Field",
            parameterType="Optional",
            direction="Input")
        field.parameterDependencies = [i.name]

        output = arcpy.Parameter(
            displayName="Output Line or Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, field, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.single_part_to_multi_part(i=i, field=field, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Sinh(object):
    def __init__(self):
        self.label = "Sinh"
        self.description = "Returns the hyperbolic sine (sinh) of each values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.sinh(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Sink(object):
    def __init__(self):
        self.label = "Sink"
        self.description = "Identifies the depressions in a DEM, giving each feature a unique identifier."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        input = arcpy.Parameter(
            displayName="Input DEM File",
            name="input",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [input, output, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        zero_background = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.sink(i=i, output=output, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Slope(object):
    def __init__(self):
        self.label = "Slope"
        self.description = "Calculates a slope raster from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        units = arcpy.Parameter(
            displayName="Units",
            name="units",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        units.filter.type = "ValueList"
        units.filter.list = ['degrees', 'radians', 'percent']
        units.value = 'degrees'

        params = [dem, output, zfactor, units]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        zfactor = parameters[2].valueAsText
        units = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.slope(dem=dem, output=output, zfactor=zfactor, units=units)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SlopeVsAspectPlot(object):
    def __init__(self):
        self.label = "Slope Vs Aspect Plot"
        self.description = "This tool creates a slope-aspect relation plot from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Raster Image",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File (*.html)",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        bin_size = arcpy.Parameter(
            displayName="Aspect Bin Size (degrees)",
            name="bin_size",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        bin_size.value = '2.0'

        min_slope = arcpy.Parameter(
            displayName="Minimum Slope (degrees)",
            name="min_slope",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        min_slope.value = '0.1'

        zfactor = arcpy.Parameter(
            displayName="Z-factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        zfactor.value = '1.0'

        params = [i, output, bin_size, min_slope, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        bin_size = parameters[2].valueAsText
        min_slope = parameters[3].valueAsText
        zfactor = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.slope_vs_aspect_plot(i=i, output=output, bin_size=bin_size, min_slope=min_slope, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SlopeVsElevationPlot(object):
    def __init__(self):
        self.label = "Slope Vs Elevation Plot"
        self.description = "Creates a slope vs. elevation plot for one or more DEMs."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input DEM Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        watershed = arcpy.Parameter(
            displayName="Input Watershed Files (optional)",
            name="watershed",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")
        watershed.multiValue = True

        output = arcpy.Parameter(
            displayName="Output HTML File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        params = [inputs, watershed, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        watershed = parameters[1].valueAsText
        if watershed is not None:
            items = watershed.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            watershed = ";".join(items_path)
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.slope_vs_elevation_plot(inputs=inputs, watershed=watershed, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SmoothVectors(object):
    def __init__(self):
        self.label = "Smooth Vectors"
        self.description = "Smooths a vector coverage of either a POLYLINE or POLYGON base ShapeType."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        filter = arcpy.Parameter(
            displayName="Filter Size",
            name="filter",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filter.value = '3'

        params = [i, output, filter]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filter = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.smooth_vectors(i=i, output=output, filter=filter)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SmoothVegetationResidual(object):
    def __init__(self):
        self.label = "Smooth Vegetation Residual"
        self.description = "This tool can smooth the residual roughness due to vegetation cover in LiDAR DEMs."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Digital Elevation Model (DEM) Raster",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        max_scale = arcpy.Parameter(
            displayName="Maximum Search Neighbourhood Radius (grid cells)",
            name="max_scale",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        max_scale.value = '30'

        dev_threshold = arcpy.Parameter(
            displayName="DEVmax Threshold",
            name="dev_threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        dev_threshold.value = '1.0'

        scale_threshold = arcpy.Parameter(
            displayName="DEVmax Scale Threshold",
            name="scale_threshold",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        scale_threshold.value = '5'

        params = [i, output, max_scale, dev_threshold, scale_threshold]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        max_scale = parameters[2].valueAsText
        dev_threshold = parameters[3].valueAsText
        scale_threshold = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.smooth_vegetation_residual(i=i, output=output, max_scale=max_scale, dev_threshold=dev_threshold, scale_threshold=scale_threshold)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SnapPourPoints(object):
    def __init__(self):
        self.label = "Snap Pour Points"
        self.description = "Moves outlet points used to specify points of interest in a watershedding operation to the cell with the highest flow accumulation in its neighbourhood."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        pour_pts = arcpy.Parameter(
            displayName="Input Pour Points (Outlet) File",
            name="pour_pts",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        pour_pts.filter.list = ["Point"]

        flow_accum = arcpy.Parameter(
            displayName="Input D8 Flow Accumulation File",
            name="flow_accum",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        snap_dist = arcpy.Parameter(
            displayName="Maximum Snap Distance (map units)",
            name="snap_dist",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        params = [pour_pts, flow_accum, output, snap_dist]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        pour_pts = parameters[0].valueAsText
        if pour_pts is not None:
            desc = arcpy.Describe(pour_pts)
            pour_pts = desc.catalogPath
        flow_accum = parameters[1].valueAsText
        if flow_accum is not None:
            desc = arcpy.Describe(flow_accum)
            flow_accum = desc.catalogPath
        output = parameters[2].valueAsText
        snap_dist = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.snap_pour_points(pour_pts=pour_pts, flow_accum=flow_accum, output=output, snap_dist=snap_dist)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SobelFilter(object):
    def __init__(self):
        self.label = "Sobel Filter"
        self.description = "Performs a Sobel edge-detection filter on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        variant = arcpy.Parameter(
            displayName="Variant",
            name="variant",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        variant.filter.type = "ValueList"
        variant.filter.list = ['3x3', '5x5']
        variant.value = '3x3'

        clip = arcpy.Parameter(
            displayName="Clip Tails (%)",
            name="clip",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        clip.value = '0.0'

        params = [i, output, variant, clip]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        variant = parameters[2].valueAsText
        clip = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.sobel_filter(i=i, output=output, variant=variant, clip=clip)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SortLidar(object):
    def __init__(self):
        self.label = "Sort Lidar"
        self.description = "Sorts LiDAR points based on their properties."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR Points",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        output = arcpy.Parameter(
            displayName="Output LiDAR Points",
            name="output",
            datatype="DEFile",
            parameterType="Optional",
            direction="Output")

        criteria = arcpy.Parameter(
            displayName="Sort Criteria:",
            name="criteria",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        params = [i, output, criteria]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        output = parameters[1].valueAsText
        criteria = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.sort_lidar(i=i, output=output, criteria=criteria)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SphericalStdDevOfNormals(object):
    def __init__(self):
        self.label = "Spherical Std Dev Of Normals"
        self.description = "Calculates the spherical standard deviation of surface normals for a DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filter = arcpy.Parameter(
            displayName="Filter Dimension",
            name="filter",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filter.value = '11'

        params = [dem, output, filter]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        filter = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.spherical_std_dev_of_normals(dem=dem, output=output, filter=filter)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SplitColourComposite(object):
    def __init__(self):
        self.label = "Split Colour Composite"
        self.description = "Splits an RGB colour composite image into separate multispectral images."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Colour Composite Image File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        red = arcpy.Parameter(
            displayName="Output Red Band File",
            name="red",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        red.filter.list = ["tif"]

        green = arcpy.Parameter(
            displayName="Output Green Band File",
            name="green",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        green.filter.list = ["tif"]

        blue = arcpy.Parameter(
            displayName="Output Blue Band File",
            name="blue",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        blue.filter.list = ["tif"]

        params = [i, red, green, blue]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        red = parameters[1].valueAsText
        green = parameters[2].valueAsText
        blue = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.split_colour_composite(i=i, red=red, green=green, blue=blue)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SplitLidar(object):
    def __init__(self):
        self.label = "Split Lidar"
        self.description = "Splits LiDAR points up into a series of new files based on their properties."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input LiDAR Points",
            name="i",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        i.filter.list = ["las", "zip"]

        criterion = arcpy.Parameter(
            displayName="Split Criterion",
            name="criterion",
            datatype="GPString",
            parameterType="Required",
            direction="Input")
        criterion.filter.type = "ValueList"
        criterion.filter.list = ['num_pts', 'x', 'y', 'z', 'intensity', 'class', 'user_data', 'point_source_id', 'scan_angle', 'time']
        criterion.value = 'num_pts'

        interval = arcpy.Parameter(
            displayName="Interval",
            name="interval",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        min_pts = arcpy.Parameter(
            displayName="Minimum Number of Points",
            name="min_pts",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_pts.value = '5'

        params = [i, criterion, interval, min_pts]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        criterion = parameters[1].valueAsText
        interval = parameters[2].valueAsText
        min_pts = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.split_lidar(i=i, criterion=criterion, interval=interval, min_pts=min_pts)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SplitVectorLines(object):
    def __init__(self):
        self.label = "Split Vector Lines"
        self.description = "Used to split a vector line coverage into even-lengthed segments."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Lines",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polyline"]

        output = arcpy.Parameter(
            displayName="Output Lines",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        length = arcpy.Parameter(
            displayName="Max Segment Length",
            name="length",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [i, output, length]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        length = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.split_vector_lines(i=i, output=output, length=length)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SplitWithLines(object):
    def __init__(self):
        self.label = "Split With Lines"
        self.description = "Splits the lines or polygons in one layer using the lines in another layer."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Lines or Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        split = arcpy.Parameter(
            displayName="Input Vector Lines File",
            name="split",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        split.filter.list = ["Polyline"]

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, split, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        split = parameters[1].valueAsText
        if split is not None:
            desc = arcpy.Describe(split)
            split = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.split_with_lines(i=i, split=split, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Square(object):
    def __init__(self):
        self.label = "Square"
        self.description = "Squares the values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.square(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SquareRoot(object):
    def __init__(self):
        self.label = "Square Root"
        self.description = "Returns the square root of the values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.square_root(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class StandardDeviationContrastStretch(object):
    def __init__(self):
        self.label = "Standard Deviation Contrast Stretch"
        self.description = "Performs a standard-deviation contrast stretch on input images."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        stdev = arcpy.Parameter(
            displayName="Standard Deviation Threshold",
            name="stdev",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        stdev.value = '2.0'

        num_tones = arcpy.Parameter(
            displayName="Number of Tones",
            name="num_tones",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        num_tones.value = '256'

        params = [i, output, stdev, num_tones]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        stdev = parameters[2].valueAsText
        num_tones = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.standard_deviation_contrast_stretch(i=i, output=output, stdev=stdev, num_tones=num_tones)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class StandardDeviationFilter(object):
    def __init__(self):
        self.label = "Standard Deviation Filter"
        self.description = "Assigns each cell in the output grid the standard deviation of values in a moving window centred on each grid cell in the input raster."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        params = [i, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.standard_deviation_filter(i=i, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class StandardDeviationOfSlope(object):
    def __init__(self):
        self.label = "Standard Deviation Of Slope"
        self.description = "Calculates the standard deviation of slope from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        params = [i, output, zfactor, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        zfactor = parameters[2].valueAsText
        filterx = parameters[3].valueAsText
        filtery = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.standard_deviation_of_slope(i=i, output=output, zfactor=zfactor, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class StochasticDepressionAnalysis(object):
    def __init__(self):
        self.label = "Stochastic Depression Analysis"
        self.description = "Performs a stochastic analysis of depressions within a DEM."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        rmse = arcpy.Parameter(
            displayName="DEM root-mean-square-error (z units)",
            name="rmse",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        range = arcpy.Parameter(
            displayName="Range of Autocorrelation (map units)",
            name="range",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        iterations = arcpy.Parameter(
            displayName="Iterations",
            name="iterations",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        iterations.value = '100'

        params = [dem, output, rmse, range, iterations]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        rmse = parameters[2].valueAsText
        range = parameters[3].valueAsText
        iterations = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.stochastic_depression_analysis(dem=dem, output=output, rmse=rmse, range=range, iterations=iterations)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class StrahlerOrderBasins(object):
    def __init__(self):
        self.label = "Strahler Order Basins"
        self.description = "Identifies Strahler-order basins from an input stream network."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [d8_pntr, streams, output, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.strahler_order_basins(d8_pntr=d8_pntr, streams=streams, output=output, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class StrahlerStreamOrder(object):
    def __init__(self):
        self.label = "Strahler Stream Order"
        self.description = "Assigns the Strahler stream order to each link in a stream network."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [d8_pntr, streams, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        zero_background = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.strahler_stream_order(d8_pntr=d8_pntr, streams=streams, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class StreamLinkClass(object):
    def __init__(self):
        self.label = "Stream Link Class"
        self.description = "Identifies the exterior/interior links and nodes in a stream network."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [d8_pntr, streams, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        zero_background = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.stream_link_class(d8_pntr=d8_pntr, streams=streams, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class StreamLinkIdentifier(object):
    def __init__(self):
        self.label = "Stream Link Identifier"
        self.description = "Assigns a unique identifier to each link in a stream network."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [d8_pntr, streams, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        zero_background = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.stream_link_identifier(d8_pntr=d8_pntr, streams=streams, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class StreamLinkLength(object):
    def __init__(self):
        self.label = "Stream Link Length"
        self.description = "Estimates the length of each link (or tributary) in a stream network."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        linkid = arcpy.Parameter(
            displayName="Input Stream Link (Tributary) ID File",
            name="linkid",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [d8_pntr, linkid, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        linkid = parameters[1].valueAsText
        if linkid is not None:
            desc = arcpy.Describe(linkid)
            linkid = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        zero_background = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.stream_link_length(d8_pntr=d8_pntr, linkid=linkid, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class StreamLinkSlope(object):
    def __init__(self):
        self.label = "Stream Link Slope"
        self.description = "Estimates the average slope of each link (or tributary) in a stream network."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        linkid = arcpy.Parameter(
            displayName="Input Stream Link (Tributary) ID File",
            name="linkid",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [d8_pntr, linkid, dem, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        linkid = parameters[1].valueAsText
        if linkid is not None:
            desc = arcpy.Describe(linkid)
            linkid = desc.catalogPath
        dem = parameters[2].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[3].valueAsText
        esri_pntr = parameters[4].valueAsText
        zero_background = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.stream_link_slope(d8_pntr=d8_pntr, linkid=linkid, dem=dem, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class StreamPowerIndex(object):
    def __init__(self):
        self.label = "Stream Power Index"
        self.description = "Calculates the relative stream power index."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        sca = arcpy.Parameter(
            displayName="Input Specific Contributing Area (SCA) File",
            name="sca",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        slope = arcpy.Parameter(
            displayName="Input Slope File",
            name="slope",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        exponent = arcpy.Parameter(
            displayName="Specific Contributing Area (SCA) Exponent",
            name="exponent",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        exponent.value = '1.0'

        params = [sca, slope, output, exponent]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        sca = parameters[0].valueAsText
        if sca is not None:
            desc = arcpy.Describe(sca)
            sca = desc.catalogPath
        slope = parameters[1].valueAsText
        if slope is not None:
            desc = arcpy.Describe(slope)
            slope = desc.catalogPath
        output = parameters[2].valueAsText
        exponent = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.stream_power_index(sca=sca, slope=slope, output=output, exponent=exponent)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class StreamSlopeContinuous(object):
    def __init__(self):
        self.label = "Stream Slope Continuous"
        self.description = "Estimates the slope of each grid cell in a stream network."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [d8_pntr, streams, dem, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        dem = parameters[2].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[3].valueAsText
        esri_pntr = parameters[4].valueAsText
        zero_background = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.stream_slope_continuous(d8_pntr=d8_pntr, streams=streams, dem=dem, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Subbasins(object):
    def __init__(self):
        self.label = "Subbasins"
        self.description = "Identifies the catchments, or sub-basin, draining to each link in a stream network."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [d8_pntr, streams, output, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.subbasins(d8_pntr=d8_pntr, streams=streams, output=output, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Subtract(object):
    def __init__(self):
        self.label = "Subtract"
        self.description = "Performs a differencing operation on two rasters or a raster and a constant value."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input1",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File Or Constant Value",
            name="input2",
            datatype=["GPRasterLayer", "GPDouble"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            try:
                input1 = str(float(input1))
            except:
                desc = arcpy.Describe(input1)
                input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            try:
                input2 = str(float(input2))
            except:
                desc = arcpy.Describe(input2)
                input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.subtract(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SumOverlay(object):
    def __init__(self):
        self.label = "Sum Overlay"
        self.description = "Calculates the sum for each grid cell from a group of raster images."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [inputs, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.sum_overlay(inputs=inputs, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SurfaceAreaRatio(object):
    def __init__(self):
        self.label = "Surface Area Ratio"
        self.description = "Calculates a the surface area ratio of each grid cell in an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.surface_area_ratio(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SvmClassification(object):
    def __init__(self):
        self.label = "Svm Classification"
        self.description = "Performs an SVM binary classification using training site polygons/points and multiple input images."
        self.category = "Machine Learning"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Predictor Rasters",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        scaling = arcpy.Parameter(
            displayName="Scaling Method",
            name="scaling",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        scaling.filter.type = "ValueList"
        scaling.filter.list = ['None', 'Normalize', 'Standardize']
        scaling.value = 'Normalize'

        training = arcpy.Parameter(
            displayName="Input Training Polygons/Points",
            name="training",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        field = arcpy.Parameter(
            displayName="Class Field Name",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [training.name]

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        c = arcpy.Parameter(
            displayName="c-Value",
            name="c",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        c.value = '200.0'

        gamma = arcpy.Parameter(
            displayName="Kernel Gamma",
            name="gamma",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        gamma.value = '50.0'

        tolerance = arcpy.Parameter(
            displayName="Tolerance",
            name="tolerance",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        tolerance.value = '0.1'

        test_proportion = arcpy.Parameter(
            displayName="Test Proportion",
            name="test_proportion",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        test_proportion.value = '0.2'

        params = [inputs, scaling, training, field, output, c, gamma, tolerance, test_proportion]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        scaling = parameters[1].valueAsText
        training = parameters[2].valueAsText
        if training is not None:
            desc = arcpy.Describe(training)
            training = desc.catalogPath
        field = parameters[3].valueAsText
        output = parameters[4].valueAsText
        c = parameters[5].valueAsText
        gamma = parameters[6].valueAsText
        tolerance = parameters[7].valueAsText
        test_proportion = parameters[8].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.svm_classification(inputs=inputs, scaling=scaling, training=training, field=field, output=output, c=c, gamma=gamma, tolerance=tolerance, test_proportion=test_proportion)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SvmRegression(object):
    def __init__(self):
        self.label = "Svm Regression"
        self.description = "Performs a supervised SVM regression analysis using training site points and predictor rasters."
        self.category = "Machine Learning"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Predictor Rasters",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        scaling = arcpy.Parameter(
            displayName="Scaling Method",
            name="scaling",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        scaling.filter.type = "ValueList"
        scaling.filter.list = ['None', 'Normalize', 'Standardize']
        scaling.value = 'Normalize'

        training = arcpy.Parameter(
            displayName="Input Training Polygons/Points",
            name="training",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        training.filter.list = ["Point"]

        field = arcpy.Parameter(
            displayName="Class Field Name",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [training.name]

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        c = arcpy.Parameter(
            displayName="c-Value",
            name="c",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        c.value = '50.0'

        eps = arcpy.Parameter(
            displayName="Epsilon Value",
            name="eps",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        eps.value = '10.0'

        gamma = arcpy.Parameter(
            displayName="Kernel Gamma",
            name="gamma",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        gamma.value = '0.5'

        test_proportion = arcpy.Parameter(
            displayName="Test Proportion",
            name="test_proportion",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        test_proportion.value = '0.2'

        params = [inputs, scaling, training, field, output, c, eps, gamma, test_proportion]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        scaling = parameters[1].valueAsText
        training = parameters[2].valueAsText
        if training is not None:
            desc = arcpy.Describe(training)
            training = desc.catalogPath
        field = parameters[3].valueAsText
        output = parameters[4].valueAsText
        c = parameters[5].valueAsText
        eps = parameters[6].valueAsText
        gamma = parameters[7].valueAsText
        test_proportion = parameters[8].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.svm_regression(inputs=inputs, scaling=scaling, training=training, field=field, output=output, c=c, eps=eps, gamma=gamma, test_proportion=test_proportion)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class SymmetricalDifference(object):
    def __init__(self):
        self.label = "Symmetrical Difference"
        self.description = "Outputs the features that occur in one of the two vector inputs but not both, i.e. no overlapping features."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        overlay = arcpy.Parameter(
            displayName="Input Overlay Vector File",
            name="overlay",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        snap = arcpy.Parameter(
            displayName="Snap Tolerance",
            name="snap",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        snap.value = '0.0'

        params = [i, overlay, output, snap]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        overlay = parameters[1].valueAsText
        if overlay is not None:
            desc = arcpy.Describe(overlay)
            overlay = desc.catalogPath
        output = parameters[2].valueAsText
        snap = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.symmetrical_difference(i=i, overlay=overlay, output=output, snap=snap)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TinGridding(object):
    def __init__(self):
        self.label = "Tin Gridding"
        self.description = "Creates a raster grid based on a triangular irregular network (TIN) fitted to vector points."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        field = arcpy.Parameter(
            displayName="Field Name",
            name="field",
            datatype="Field",
            parameterType="Optional",
            direction="Input")
        field.parameterDependencies = [i.name]

        use_z = arcpy.Parameter(
            displayName="Use Shapefile 'z' values?",
            name="use_z",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        use_z.value = 'False'

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        resolution = arcpy.Parameter(
            displayName="Grid Resolution",
            name="resolution",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        base = arcpy.Parameter(
            displayName="Base Raster File (optional)",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        max_triangle_edge_length = arcpy.Parameter(
            displayName="Maximum Triangle Edge Length (optional)",
            name="max_triangle_edge_length",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [i, field, use_z, output, resolution, base, max_triangle_edge_length]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        use_z = parameters[2].valueAsText
        output = parameters[3].valueAsText
        resolution = parameters[4].valueAsText
        base = parameters[5].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        max_triangle_edge_length = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.tin_gridding(i=i, field=field, use_z=use_z, output=output, resolution=resolution, base=base, max_triangle_edge_length=max_triangle_edge_length)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Tan(object):
    def __init__(self):
        self.label = "Tan"
        self.description = "Returns the tangent (tan) of each values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.tan(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TangentialCurvature(object):
    def __init__(self):
        self.label = "Tangential Curvature"
        self.description = "Calculates a tangential curvature raster from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.tangential_curvature(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Tanh(object):
    def __init__(self):
        self.label = "Tanh"
        self.description = "Returns the hyperbolic tangent (tanh) of each values in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.tanh(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ThickenRasterLine(object):
    def __init__(self):
        self.label = "Thicken Raster Line"
        self.description = "Thickens single-cell wide lines within a raster image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.thicken_raster_line(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TimeInDaylight(object):
    def __init__(self):
        self.label = "Time In Daylight"
        self.description = "Calculates the proportion of time a location is not within an area of shadow."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        az_fraction = arcpy.Parameter(
            displayName="Azimuth Fraction",
            name="az_fraction",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        az_fraction.value = '10.0'

        max_dist = arcpy.Parameter(
            displayName="Maximum Search Distance",
            name="max_dist",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        max_dist.value = '100.0'

        lat = arcpy.Parameter(
            displayName="Centre Point Latitude",
            name="lat",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        long = arcpy.Parameter(
            displayName="Centre Point Longitude",
            name="long",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        utc_offset = arcpy.Parameter(
            displayName="UTC Offset (e.g. -04:00, +06:00)",
            name="utc_offset",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        utc_offset.value = '00:00'

        start_day = arcpy.Parameter(
            displayName="Start Day Of The Year (1-365)",
            name="start_day",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        start_day.value = '1'

        end_day = arcpy.Parameter(
            displayName="End Day Of The Year (1-365)",
            name="end_day",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        end_day.value = '365'

        start_time = arcpy.Parameter(
            displayName="Starting Hour (24-hour time: HH:MM:SS e.g. 05:00:00)",
            name="start_time",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        start_time.value = '00:00:00'

        end_time = arcpy.Parameter(
            displayName="Ending Hour (24-hour time: HH:MM:SS e.g. 21:00:00)",
            name="end_time",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        end_time.value = '23:59:59'

        params = [dem, output, az_fraction, max_dist, lat, long, utc_offset, start_day, end_day, start_time, end_time]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        az_fraction = parameters[2].valueAsText
        max_dist = parameters[3].valueAsText
        lat = parameters[4].valueAsText
        long = parameters[5].valueAsText
        utc_offset = parameters[6].valueAsText
        start_day = parameters[7].valueAsText
        end_day = parameters[8].valueAsText
        start_time = parameters[9].valueAsText
        end_time = parameters[10].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.time_in_daylight(dem=dem, output=output, az_fraction=az_fraction, max_dist=max_dist, lat=lat, long=long, utc_offset=utc_offset, start_day=start_day, end_day=end_day, start_time=start_time, end_time=end_time)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ToDegrees(object):
    def __init__(self):
        self.label = "To Degrees"
        self.description = "Converts a raster from radians to degrees."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.to_degrees(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ToRadians(object):
    def __init__(self):
        self.label = "To Radians"
        self.description = "Converts a raster from degrees to radians."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.to_radians(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TophatTransform(object):
    def __init__(self):
        self.label = "Tophat Transform"
        self.description = "Performs either a white or black top-hat transform on an input image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        variant = arcpy.Parameter(
            displayName="Variant",
            name="variant",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        variant.filter.type = "ValueList"
        variant.filter.list = ['white', 'black']
        variant.value = 'white'

        params = [i, output, filterx, filtery, variant]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        variant = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.tophat_transform(i=i, output=output, filterx=filterx, filtery=filtery, variant=variant)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TopoRender(object):
    def __init__(self):
        self.label = "Topo Render"
        self.description = "This tool creates a pseudo-3D rendering from an input DEM, for the purpose of effective topographic visualization."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input Digital Elevation Model (DEM) Raster",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        palette = arcpy.Parameter(
            displayName="Palette",
            name="palette",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        palette.filter.type = "ValueList"
        palette.filter.list = ['atlas', 'high_relief', 'arid', 'soft', 'earthtones', 'muted', 'light_quant', 'purple', 'viridis', 'gn_yl', 'pi_y_g', 'bl_yl_rd', 'deep', 'imhof', 'white']
        palette.value = 'soft'

        rev_palette = arcpy.Parameter(
            displayName="Reverse the palette?",
            name="rev_palette",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        rev_palette.value = 'False'

        az = arcpy.Parameter(
            displayName="Light Source Direction (degrees)",
            name="az",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        az.value = '315.0'

        alt = arcpy.Parameter(
            displayName="Light Source Altitude (degrees)",
            name="alt",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        alt.value = '30.0'

        background_hgt_offset = arcpy.Parameter(
            displayName="Offset Height of Background (z-units)",
            name="background_hgt_offset",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        background_hgt_offset.value = '10.0'

        polygon = arcpy.Parameter(
            displayName="Clipping Polygon",
            name="polygon",
            datatype="GPFeatureLayer",
            parameterType="Optional",
            direction="Input")
        polygon.filter.list = ["Polygon"]

        background_clr = arcpy.Parameter(
            displayName="Background RGB colour",
            name="background_clr",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        background_clr.value = '[255, 255, 255]'

        attenuation = arcpy.Parameter(
            displayName="Attenuation Parameter",
            name="attenuation",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        attenuation.value = '0.6'

        ambient_light = arcpy.Parameter(
            displayName="Ambient Light",
            name="ambient_light",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        ambient_light.value = '0.2'

        z_factor = arcpy.Parameter(
            displayName="Elevation Multiplier",
            name="z_factor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        z_factor.value = '1.0'

        params = [dem, output, palette, rev_palette, az, alt, background_hgt_offset, polygon, background_clr, attenuation, ambient_light, z_factor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        palette = parameters[2].valueAsText
        rev_palette = parameters[3].valueAsText
        az = parameters[4].valueAsText
        alt = parameters[5].valueAsText
        background_hgt_offset = parameters[6].valueAsText
        polygon = parameters[7].valueAsText
        if polygon is not None:
            desc = arcpy.Describe(polygon)
            polygon = desc.catalogPath
        background_clr = parameters[8].valueAsText
        attenuation = parameters[9].valueAsText
        ambient_light = parameters[10].valueAsText
        z_factor = parameters[11].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.topo_render(dem=dem, output=output, palette=palette, rev_palette=rev_palette, az=az, alt=alt, background_hgt_offset=background_hgt_offset, polygon=polygon, background_clr=background_clr, attenuation=attenuation, ambient_light=ambient_light, z_factor=z_factor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TopographicPositionAnimation(object):
    def __init__(self):
        self.label = "Topographic Position Animation"
        self.description = "This tool creates an animated GIF of multi-scale local topographic position (elevation deviation)."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Digital Elevation Model (DEM) Raster",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        palette = arcpy.Parameter(
            displayName="Palette",
            name="palette",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        palette.filter.type = "ValueList"
        palette.filter.list = ['bl_yl_rd', 'bl_w_rd', 'purple', 'gn_yl', 'pi_y_g', 'viridis']
        palette.value = 'bl_yl_rd'

        output = arcpy.Parameter(
            displayName="Output File (*.html)",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        min_scale = arcpy.Parameter(
            displayName="Minimum Search Neighbourhood Radius (grid cells)",
            name="min_scale",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        min_scale.value = '1'

        num_steps = arcpy.Parameter(
            displayName="Number of Steps",
            name="num_steps",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        num_steps.value = '100'

        step_nonlinearity = arcpy.Parameter(
            displayName="Step Nonlinearity",
            name="step_nonlinearity",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        step_nonlinearity.value = '1.5'

        height = arcpy.Parameter(
            displayName="Image Height (in pixels)",
            name="height",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        height.value = '600'

        delay = arcpy.Parameter(
            displayName="Delay (in milliseconds)",
            name="delay",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        delay.value = '250'

        label = arcpy.Parameter(
            displayName="Label text (blank for none)",
            name="label",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        dev_max = arcpy.Parameter(
            displayName="Use DEVmax for topo position?",
            name="dev_max",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        dev_max.value = 'False'

        params = [i, palette, output, min_scale, num_steps, step_nonlinearity, height, delay, label, dev_max]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        palette = parameters[1].valueAsText
        output = parameters[2].valueAsText
        min_scale = parameters[3].valueAsText
        num_steps = parameters[4].valueAsText
        step_nonlinearity = parameters[5].valueAsText
        height = parameters[6].valueAsText
        delay = parameters[7].valueAsText
        label = parameters[8].valueAsText
        dev_max = parameters[9].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.topographic_position_animation(i=i, palette=palette, output=output, min_scale=min_scale, num_steps=num_steps, step_nonlinearity=step_nonlinearity, height=height, delay=delay, label=label, dev_max=dev_max)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TopologicalStreamOrder(object):
    def __init__(self):
        self.label = "Topological Stream Order"
        self.description = "Assigns each link in a stream network its topological order."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [d8_pntr, streams, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        zero_background = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.topological_stream_order(d8_pntr=d8_pntr, streams=streams, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TotalCurvature(object):
    def __init__(self):
        self.label = "Total Curvature"
        self.description = "Calculates a total curvature raster from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z Conversion Factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.total_curvature(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TotalFilter(object):
    def __init__(self):
        self.label = "Total Filter"
        self.description = "Performs a total filter on an input image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        filterx = arcpy.Parameter(
            displayName="Filter X-Dimension",
            name="filterx",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filterx.value = '11'

        filtery = arcpy.Parameter(
            displayName="Filter Y-Dimension",
            name="filtery",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        filtery.value = '11'

        params = [i, output, filterx, filtery]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        filterx = parameters[2].valueAsText
        filtery = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.total_filter(i=i, output=output, filterx=filterx, filtery=filtery)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TraceDownslopeFlowpaths(object):
    def __init__(self):
        self.label = "Trace Downslope Flowpaths"
        self.description = "Traces downslope flowpaths from one or more target sites (i.e. seed points)."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        seed_pts = arcpy.Parameter(
            displayName="Input Vector Seed Points File",
            name="seed_pts",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        seed_pts.filter.list = ["Point"]

        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [seed_pts, d8_pntr, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        seed_pts = parameters[0].valueAsText
        if seed_pts is not None:
            desc = arcpy.Describe(seed_pts)
            seed_pts = desc.catalogPath
        d8_pntr = parameters[1].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        zero_background = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.trace_downslope_flowpaths(seed_pts=seed_pts, d8_pntr=d8_pntr, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TravellingSalesmanProblem(object):
    def __init__(self):
        self.label = "Travelling Salesman Problem"
        self.description = "Finds approximate solutions to travelling salesman problems, the goal of which is to identify the shortest route connecting a set of locations."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Points",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        output = arcpy.Parameter(
            displayName="Output Lines",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        duration = arcpy.Parameter(
            displayName="Max Duration",
            name="duration",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        duration.value = '60'

        params = [i, output, duration]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        duration = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.travelling_salesman_problem(i=i, output=output, duration=duration)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TrendSurface(object):
    def __init__(self):
        self.label = "Trend Surface"
        self.description = "Estimates the trend surface of an input raster file."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        order = arcpy.Parameter(
            displayName="Polynomial Order",
            name="order",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        order.value = '1'

        params = [i, output, order]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        order = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.trend_surface(i=i, output=output, order=order)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TrendSurfaceVectorPoints(object):
    def __init__(self):
        self.label = "Trend Surface Vector Points"
        self.description = "Estimates a trend surface from vector points."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        field = arcpy.Parameter(
            displayName="Field Name",
            name="field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        field.parameterDependencies = [i.name]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        order = arcpy.Parameter(
            displayName="Polynomial Order",
            name="order",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        order.value = '1'

        cell_size = arcpy.Parameter(
            displayName="Cell Size",
            name="cell_size",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        params = [i, field, output, order, cell_size]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        output = parameters[2].valueAsText
        order = parameters[3].valueAsText
        cell_size = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.trend_surface_vector_points(i=i, field=field, output=output, order=order, cell_size=cell_size)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TributaryIdentifier(object):
    def __init__(self):
        self.label = "Tributary Identifier"
        self.description = "Assigns a unique identifier to each tributary in a stream network."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        streams = arcpy.Parameter(
            displayName="Input Streams File",
            name="streams",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        zero_background = arcpy.Parameter(
            displayName="Should a background value of zero be used?",
            name="zero_background",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")

        params = [d8_pntr, streams, output, esri_pntr, zero_background]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        streams = parameters[1].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        zero_background = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.tributary_identifier(d8_pntr=d8_pntr, streams=streams, output=output, esri_pntr=esri_pntr, zero_background=zero_background)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Truncate(object):
    def __init__(self):
        self.label = "Truncate"
        self.description = "Truncates the values in a raster to the desired number of decimal places."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        num_decimals = arcpy.Parameter(
            displayName="Number of Decimals After Truncation",
            name="num_decimals",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")

        params = [i, output, num_decimals]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        num_decimals = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.truncate(i=i, output=output, num_decimals=num_decimals)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TurningBandsSimulation(object):
    def __init__(self):
        self.label = "Turning Bands Simulation"
        self.description = "Creates an image containing random values based on a turning-bands simulation."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        base = arcpy.Parameter(
            displayName="Input Base File",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        range = arcpy.Parameter(
            displayName="Range of Autocorrelation (map units)",
            name="range",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        iterations = arcpy.Parameter(
            displayName="Iterations",
            name="iterations",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")
        iterations.value = '1000'

        params = [base, output, range, iterations]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        base = parameters[0].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        output = parameters[1].valueAsText
        range = parameters[2].valueAsText
        iterations = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.turning_bands_simulation(base=base, output=output, range=range, iterations=iterations)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class TwoSampleKsTest(object):
    def __init__(self):
        self.label = "Two Sample Ks Test"
        self.description = "Performs a 2-sample K-S test for significant differences on two input rasters."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="First Input File",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Second Input File",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        num_samples = arcpy.Parameter(
            displayName="Num. Samples (blank for while image)",
            name="num_samples",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")

        params = [input1, input2, output, num_samples]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        num_samples = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.two_sample_ks_test(input1=input1, input2=input2, output=output, num_samples=num_samples)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Union(object):
    def __init__(self):
        self.label = "Union"
        self.description = "Splits vector layers at their overlaps, creating a layer containing all the portions from both input and overlay layers."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        overlay = arcpy.Parameter(
            displayName="Input Overlay Vector File",
            name="overlay",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Vector File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        snap = arcpy.Parameter(
            displayName="Snap Tolerance",
            name="snap",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        snap.value = '0.0'

        params = [i, overlay, output, snap]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        overlay = parameters[1].valueAsText
        if overlay is not None:
            desc = arcpy.Describe(overlay)
            overlay = desc.catalogPath
        output = parameters[2].valueAsText
        snap = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.union(i=i, overlay=overlay, output=output, snap=snap)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class UnnestBasins(object):
    def __init__(self):
        self.label = "Unnest Basins"
        self.description = "Extract whole watersheds for a set of outlet points."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        pour_pts = arcpy.Parameter(
            displayName="Input Pour Points (Outlet) File",
            name="pour_pts",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        pour_pts.filter.list = ["Point"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [d8_pntr, pour_pts, output, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        pour_pts = parameters[1].valueAsText
        if pour_pts is not None:
            desc = arcpy.Describe(pour_pts)
            pour_pts = desc.catalogPath
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.unnest_basins(d8_pntr=d8_pntr, pour_pts=pour_pts, output=output, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class UnsharpMasking(object):
    def __init__(self):
        self.label = "Unsharp Masking"
        self.description = "An image sharpening technique that enhances edges."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        sigma = arcpy.Parameter(
            displayName="Standard Deviation (pixels)",
            name="sigma",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        sigma.value = '0.75'

        amount = arcpy.Parameter(
            displayName="Amount (%)",
            name="amount",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        amount.value = '100.0'

        threshold = arcpy.Parameter(
            displayName="Threshold",
            name="threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        threshold.value = '0.0'

        params = [i, output, sigma, amount, threshold]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        sigma = parameters[2].valueAsText
        amount = parameters[3].valueAsText
        threshold = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.unsharp_masking(i=i, output=output, sigma=sigma, amount=amount, threshold=threshold)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Unsphericity(object):
    def __init__(self):
        self.label = "Unsphericity"
        self.description = "This tool calculates the unsphericity curvature from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input Raster DEM",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster Image",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z-factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        zfactor.value = '1.0'

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.unsphericity(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class UpdateNodataCells(object):
    def __init__(self):
        self.label = "Update Nodata Cells"
        self.description = "Replaces the NoData values in an input raster with the corresponding values contained in a second update layer."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File 1",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File 2 (Update Layer)",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.update_nodata_cells(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class UpslopeDepressionStorage(object):
    def __init__(self):
        self.label = "Upslope Depression Storage"
        self.description = "Estimates the average upslope depression storage depth."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [dem, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.upslope_depression_storage(dem=dem, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class UserDefinedWeightsFilter(object):
    def __init__(self):
        self.label = "User Defined Weights Filter"
        self.description = "Performs a user-defined weights filter on an image."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        weights = arcpy.Parameter(
            displayName="Input Weights File",
            name="weights",
            datatype="DEFile",
            parameterType="Required",
            direction="Input")
        weights.filter.list = ["csv"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        center = arcpy.Parameter(
            displayName="Kernel Center",
            name="center",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        center.filter.type = "ValueList"
        center.filter.list = ['center', 'upper-left', 'upper-right', 'lower-left', 'lower-right']
        center.value = 'center'

        normalize = arcpy.Parameter(
            displayName="Normalize kernel weights?",
            name="normalize",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        normalize.value = 'False'

        params = [i, weights, output, center, normalize]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        weights = parameters[1].valueAsText
        output = parameters[2].valueAsText
        center = parameters[3].valueAsText
        normalize = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.user_defined_weights_filter(i=i, weights=weights, output=output, center=center, normalize=normalize)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class VectorHexBinning(object):
    def __init__(self):
        self.label = "Vector Hex Binning"
        self.description = "Hex-bins a set of vector points."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Base File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        width = arcpy.Parameter(
            displayName="Hexagon Width",
            name="width",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")

        orientation = arcpy.Parameter(
            displayName="Grid Orientation",
            name="orientation",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        orientation.filter.type = "ValueList"
        orientation.filter.list = ['horizontal', 'vertical']
        orientation.value = 'horizontal'

        params = [i, output, width, orientation]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        width = parameters[2].valueAsText
        orientation = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.vector_hex_binning(i=i, output=output, width=width, orientation=orientation)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class VectorLinesToRaster(object):
    def __init__(self):
        self.label = "Vector Lines To Raster"
        self.description = "Converts a vector containing polylines into a raster."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Lines File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polyline"]

        field = arcpy.Parameter(
            displayName="Field Name",
            name="field",
            datatype="Field",
            parameterType="Optional",
            direction="Input")
        field.parameterDependencies = [i.name]
        field.value = 'FID'

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        nodata = arcpy.Parameter(
            displayName="Background value is NoData?",
            name="nodata",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        nodata.value = 'True'

        cell_size = arcpy.Parameter(
            displayName="Cell Size (optional)",
            name="cell_size",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        base = arcpy.Parameter(
            displayName="Base Raster File (optional)",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        params = [i, field, output, nodata, cell_size, base]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        output = parameters[2].valueAsText
        nodata = parameters[3].valueAsText
        cell_size = parameters[4].valueAsText
        base = parameters[5].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.vector_lines_to_raster(i=i, field=field, output=output, nodata=nodata, cell_size=cell_size, base=base)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class VectorPointsToRaster(object):
    def __init__(self):
        self.label = "Vector Points To Raster"
        self.description = "Converts a vector containing points into a raster."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        field = arcpy.Parameter(
            displayName="Field Name",
            name="field",
            datatype="Field",
            parameterType="Optional",
            direction="Input")
        field.parameterDependencies = [i.name]
        field.value = 'FID'

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        assign = arcpy.Parameter(
            displayName="Assignment Operation",
            name="assign",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        assign.filter.type = "ValueList"
        assign.filter.list = ['first', 'last', 'min', 'max', 'sum', 'number']
        assign.value = 'last'

        nodata = arcpy.Parameter(
            displayName="Background value is NoData?",
            name="nodata",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        nodata.value = 'True'

        cell_size = arcpy.Parameter(
            displayName="Cell Size (optional)",
            name="cell_size",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        base = arcpy.Parameter(
            displayName="Base Raster File (optional)",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        params = [i, field, output, assign, nodata, cell_size, base]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        output = parameters[2].valueAsText
        assign = parameters[3].valueAsText
        nodata = parameters[4].valueAsText
        cell_size = parameters[5].valueAsText
        base = parameters[6].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.vector_points_to_raster(i=i, field=field, output=output, assign=assign, nodata=nodata, cell_size=cell_size, base=base)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class VectorPolygonsToRaster(object):
    def __init__(self):
        self.label = "Vector Polygons To Raster"
        self.description = "Converts a vector containing polygons into a raster."
        self.category = "Data Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Polygon File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Polygon"]

        field = arcpy.Parameter(
            displayName="Field Name",
            name="field",
            datatype="Field",
            parameterType="Optional",
            direction="Input")
        field.parameterDependencies = [i.name]
        field.value = 'FID'

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        nodata = arcpy.Parameter(
            displayName="Background value is NoData?",
            name="nodata",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        nodata.value = 'True'

        cell_size = arcpy.Parameter(
            displayName="Cell Size (optional)",
            name="cell_size",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        base = arcpy.Parameter(
            displayName="Base Raster File (optional)",
            name="base",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        params = [i, field, output, nodata, cell_size, base]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        field = parameters[1].valueAsText
        output = parameters[2].valueAsText
        nodata = parameters[3].valueAsText
        cell_size = parameters[4].valueAsText
        base = parameters[5].valueAsText
        if base is not None:
            desc = arcpy.Describe(base)
            base = desc.catalogPath
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.vector_polygons_to_raster(i=i, field=field, output=output, nodata=nodata, cell_size=cell_size, base=base)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class VectorStreamNetworkAnalysis(object):
    def __init__(self):
        self.label = "Vector Stream Network Analysis"
        self.description = "This tool performs common stream network analysis operations on an input vector stream file."
        self.category = "Stream Network Analysis"

    def getParameterInfo(self):
        streams = arcpy.Parameter(
            displayName="Input Streams Vector",
            name="streams",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        streams.filter.list = ["Polyline"]

        dem = arcpy.Parameter(
            displayName="Input DEM Raster",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Lines",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        cutting_height = arcpy.Parameter(
            displayName="Maximum Ridge-cutting Height (z units)",
            name="cutting_height",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        cutting_height.value = '10.0'

        snap = arcpy.Parameter(
            displayName="Snap Distance",
            name="snap",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        snap.value = '0.1'

        params = [streams, dem, output, cutting_height, snap]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        streams = parameters[0].valueAsText
        if streams is not None:
            desc = arcpy.Describe(streams)
            streams = desc.catalogPath
        dem = parameters[1].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[2].valueAsText
        cutting_height = parameters[3].valueAsText
        snap = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.vector_stream_network_analysis(streams=streams, dem=dem, output=output, cutting_height=cutting_height, snap=snap)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class VerticalExcessCurvature(object):
    def __init__(self):
        self.label = "Vertical Excess Curvature"
        self.description = "This tool calculates vertical excess curvature from an input DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input Raster DEM",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster Image",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        log = arcpy.Parameter(
            displayName="Log-transform the output?",
            name="log",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        log.value = 'False'

        zfactor = arcpy.Parameter(
            displayName="Z-factor",
            name="zfactor",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        zfactor.value = '1.0'

        params = [dem, output, log, zfactor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        log = parameters[2].valueAsText
        zfactor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.vertical_excess_curvature(dem=dem, output=output, log=log, zfactor=zfactor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Viewshed(object):
    def __init__(self):
        self.label = "Viewshed"
        self.description = "Identifies the viewshed for a point or set of points."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        stations = arcpy.Parameter(
            displayName="Viewing Station Vector File",
            name="stations",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        stations.filter.list = ["Point"]

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        height = arcpy.Parameter(
            displayName="Station Height (in z units)",
            name="height",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        height.value = '2.0'

        params = [dem, stations, output, height]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        stations = parameters[1].valueAsText
        if stations is not None:
            desc = arcpy.Describe(stations)
            stations = desc.catalogPath
        output = parameters[2].valueAsText
        height = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.viewshed(dem=dem, stations=stations, output=output, height=height)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class VisibilityIndex(object):
    def __init__(self):
        self.label = "Visibility Index"
        self.description = "Estimates the relative visibility of sites in a DEM."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        dem = arcpy.Parameter(
            displayName="Input DEM File",
            name="dem",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        height = arcpy.Parameter(
            displayName="Station Height (in z units)",
            name="height",
            datatype="GPDouble",
            parameterType="Required",
            direction="Input")
        height.value = '2.0'

        res_factor = arcpy.Parameter(
            displayName="Resolution Factor",
            name="res_factor",
            datatype="GPLong",
            parameterType="Required",
            direction="Input")
        res_factor.value = '2'

        params = [dem, output, height, res_factor]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        dem = parameters[0].valueAsText
        if dem is not None:
            desc = arcpy.Describe(dem)
            dem = desc.catalogPath
        output = parameters[1].valueAsText
        height = parameters[2].valueAsText
        res_factor = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.visibility_index(dem=dem, output=output, height=height, res_factor=res_factor)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class VoronoiDiagram(object):
    def __init__(self):
        self.label = "Voronoi Diagram"
        self.description = "Creates a vector Voronoi diagram for a set of vector points."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Vector Points File",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        output = arcpy.Parameter(
            displayName="Output Polygon File",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.voronoi_diagram(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Watershed(object):
    def __init__(self):
        self.label = "Watershed"
        self.description = "Identifies the watershed, or drainage basin, draining to a set of target cells."
        self.category = "Hydrological Analysis"

    def getParameterInfo(self):
        d8_pntr = arcpy.Parameter(
            displayName="Input D8 Pointer File",
            name="d8_pntr",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        pour_pts = arcpy.Parameter(
            displayName="Input Pour Points (Outlet) File",
            name="pour_pts",
            datatype=["DERasterDataset", "DEShapefile"],
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        esri_pntr = arcpy.Parameter(
            displayName="Does the pointer file use the ESRI pointer scheme?",
            name="esri_pntr",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        esri_pntr.value = 'False'

        params = [d8_pntr, pour_pts, output, esri_pntr]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        d8_pntr = parameters[0].valueAsText
        if d8_pntr is not None:
            desc = arcpy.Describe(d8_pntr)
            d8_pntr = desc.catalogPath
        pour_pts = parameters[1].valueAsText
        output = parameters[2].valueAsText
        esri_pntr = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.watershed(d8_pntr=d8_pntr, pour_pts=pour_pts, output=output, esri_pntr=esri_pntr)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class WeightedOverlay(object):
    def __init__(self):
        self.label = "Weighted Overlay"
        self.description = "Performs a weighted sum on multiple input rasters after converting each image to a common scale. The tool performs a multi-criteria evaluation (MCE)."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        factors = arcpy.Parameter(
            displayName="Input Factor Files",
            name="factors",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        factors.multiValue = True

        weights = arcpy.Parameter(
            displayName="Weight Values (e.g. 1.7;3.5;1.2)",
            name="weights",
            datatype="GPString",
            parameterType="Required",
            direction="Input")

        cost = arcpy.Parameter(
            displayName="Cost Factor? (e.g. false;true;true)",
            name="cost",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")

        constraints = arcpy.Parameter(
            displayName="Input Constraints Files",
            name="constraints",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")
        constraints.multiValue = True

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        scale_max = arcpy.Parameter(
            displayName="Suitability Scale Maximum",
            name="scale_max",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        scale_max.value = '1.0'

        params = [factors, weights, cost, constraints, output, scale_max]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        factors = parameters[0].valueAsText
        if factors is not None:
            items = factors.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            factors = ";".join(items_path)
        weights = parameters[1].valueAsText
        cost = parameters[2].valueAsText
        constraints = parameters[3].valueAsText
        if constraints is not None:
            items = constraints.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            constraints = ";".join(items_path)
        output = parameters[4].valueAsText
        scale_max = parameters[5].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.weighted_overlay(factors=factors, weights=weights, cost=cost, constraints=constraints, output=output, scale_max=scale_max)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class WeightedSum(object):
    def __init__(self):
        self.label = "Weighted Sum"
        self.description = "Performs a weighted-sum overlay on multiple input raster images."
        self.category = "GIS Analysis"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input Files",
            name="inputs",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")
        inputs.multiValue = True

        weights = arcpy.Parameter(
            displayName="Weight Values (e.g. 1.7;3.5;1.2)",
            name="weights",
            datatype="GPString",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [inputs, weights, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        weights = parameters[1].valueAsText
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.weighted_sum(inputs=inputs, weights=weights, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class WetnessIndex(object):
    def __init__(self):
        self.label = "Wetness Index"
        self.description = "Calculates the topographic wetness index, Ln(A / tan(slope))."
        self.category = "Geomorphometric Analysis"

    def getParameterInfo(self):
        sca = arcpy.Parameter(
            displayName="Input Specific Contributing Area (SCA) File",
            name="sca",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        slope = arcpy.Parameter(
            displayName="Input Slope File",
            name="slope",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [sca, slope, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        sca = parameters[0].valueAsText
        if sca is not None:
            desc = arcpy.Describe(sca)
            sca = desc.catalogPath
        slope = parameters[1].valueAsText
        if slope is not None:
            desc = arcpy.Describe(slope)
            slope = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.wetness_index(sca=sca, slope=slope, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class WilcoxonSignedRankTest(object):
    def __init__(self):
        self.label = "Wilcoxon Signed Rank Test"
        self.description = "Performs a 2-sample K-S test for significant differences on two input rasters."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="First Input File",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Second Input File",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["html"]

        num_samples = arcpy.Parameter(
            displayName="Num. Samples (blank for while image)",
            name="num_samples",
            datatype="GPLong",
            parameterType="Optional",
            direction="Input")

        params = [input1, input2, output, num_samples]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        num_samples = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.wilcoxon_signed_rank_test(input1=input1, input2=input2, output=output, num_samples=num_samples)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class WriteFunctionMemoryInsertion(object):
    def __init__(self):
        self.label = "Write Function Memory Insertion"
        self.description = "Performs a write function memory insertion for single-band multi-date change detection."
        self.category = "Image Processing Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="First Date Input File",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Second Date Input File",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input3 = arcpy.Parameter(
            displayName="Third Date Input File (Optional)",
            name="input3",
            datatype="GPRasterLayer",
            parameterType="Optional",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, input3, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        input3 = parameters[2].valueAsText
        if input3 is not None:
            desc = arcpy.Describe(input3)
            input3 = desc.catalogPath
        output = parameters[3].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.write_function_memory_insertion(input1=input1, input2=input2, input3=input3, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class Xor(object):
    def __init__(self):
        self.label = "Xor"
        self.description = "Performs a logical XOR operator on two Boolean raster images."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        input1 = arcpy.Parameter(
            displayName="Input File",
            name="input1",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        input2 = arcpy.Parameter(
            displayName="Input File",
            name="input2",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [input1, input2, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        input1 = parameters[0].valueAsText
        if input1 is not None:
            desc = arcpy.Describe(input1)
            input1 = desc.catalogPath
        input2 = parameters[1].valueAsText
        if input2 is not None:
            desc = arcpy.Describe(input2)
            input2 = desc.catalogPath
        output = parameters[2].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.xor(input1=input1, input2=input2, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class YieldFilter(object):
    def __init__(self):
        self.label = "Yield Filter"
        self.description = "Filters crop yield values of point data derived from combine harvester yield monitors."
        self.category = "Precision Agriculture"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Points",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        yield_field = arcpy.Parameter(
            displayName="Yield Field Name",
            name="yield_field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        yield_field.parameterDependencies = [i.name]

        pass_field = arcpy.Parameter(
            displayName="Pass Field Name",
            name="pass_field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        pass_field.parameterDependencies = [i.name]

        output = arcpy.Parameter(
            displayName="Output Points",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        width = arcpy.Parameter(
            displayName="Swath Width",
            name="width",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        width.value = '6.096'

        z_score_threshold = arcpy.Parameter(
            displayName="Z-score Threshold Value",
            name="z_score_threshold",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        z_score_threshold.value = '2.5'

        min_yield = arcpy.Parameter(
            displayName="Minimum Yield",
            name="min_yield",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        min_yield.value = '0.0'

        max_yield = arcpy.Parameter(
            displayName="Maximum Yield",
            name="max_yield",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        max_yield.value = '99999.9'

        params = [i, yield_field, pass_field, output, width, z_score_threshold, min_yield, max_yield]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        yield_field = parameters[1].valueAsText
        pass_field = parameters[2].valueAsText
        output = parameters[3].valueAsText
        width = parameters[4].valueAsText
        z_score_threshold = parameters[5].valueAsText
        min_yield = parameters[6].valueAsText
        max_yield = parameters[7].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.yield_filter(i=i, yield_field=yield_field, pass_field=pass_field, output=output, width=width, z_score_threshold=z_score_threshold, min_yield=min_yield, max_yield=max_yield)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class YieldMap(object):
    def __init__(self):
        self.label = "Yield Map"
        self.description = "This tool can be used to create a segmented-vector polygon yield map from a set of harvester points."
        self.category = "Precision Agriculture"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Points",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        pass_field_name = arcpy.Parameter(
            displayName="Pass Field Name",
            name="pass_field_name",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        pass_field_name.parameterDependencies = [i.name]

        output = arcpy.Parameter(
            displayName="Output Vector Polygons",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        width = arcpy.Parameter(
            displayName="Swath Width",
            name="width",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        width.value = '6.096'

        max_change_in_heading = arcpy.Parameter(
            displayName="Max Change In Heading (degrees)",
            name="max_change_in_heading",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        max_change_in_heading.value = '25.0'

        params = [i, pass_field_name, output, width, max_change_in_heading]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        pass_field_name = parameters[1].valueAsText
        output = parameters[2].valueAsText
        width = parameters[3].valueAsText
        max_change_in_heading = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.yield_map(i=i, pass_field_name=pass_field_name, output=output, width=width, max_change_in_heading=max_change_in_heading)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class YieldNormalization(object):
    def __init__(self):
        self.label = "Yield Normalization"
        self.description = "This tool can be used to normalize the yield points for a field."
        self.category = "Precision Agriculture"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Points",
            name="i",
            datatype="GPFeatureLayer",
            parameterType="Required",
            direction="Input")
        i.filter.list = ["Point"]

        yield_field = arcpy.Parameter(
            displayName="Yield Field Name",
            name="yield_field",
            datatype="Field",
            parameterType="Required",
            direction="Input")
        yield_field.parameterDependencies = [i.name]

        output = arcpy.Parameter(
            displayName="Output Points",
            name="output",
            datatype="DEShapefile",
            parameterType="Required",
            direction="Output")

        standardize = arcpy.Parameter(
            displayName="Standardize rather than normalize?",
            name="standardize",
            datatype="GPBoolean",
            parameterType="Optional",
            direction="Input")
        standardize.value = 'False'

        radius = arcpy.Parameter(
            displayName="Search Radius (m)",
            name="radius",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")

        min_yield = arcpy.Parameter(
            displayName="Minimum Yield",
            name="min_yield",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        min_yield.value = '0.0'

        max_yield = arcpy.Parameter(
            displayName="Maximum Yield",
            name="max_yield",
            datatype="GPDouble",
            parameterType="Optional",
            direction="Input")
        max_yield.value = '99999.9'

        params = [i, yield_field, output, standardize, radius, min_yield, max_yield]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        yield_field = parameters[1].valueAsText
        output = parameters[2].valueAsText
        standardize = parameters[3].valueAsText
        radius = parameters[4].valueAsText
        min_yield = parameters[5].valueAsText
        max_yield = parameters[6].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.yield_normalization(i=i, yield_field=yield_field, output=output, standardize=standardize, radius=radius, min_yield=min_yield, max_yield=max_yield)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ZScores(object):
    def __init__(self):
        self.label = "Z Scores"
        self.description = "Standardizes the values in an input raster by converting to z-scores."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        params = [i, output]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        output = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.z_scores(i=i, output=output)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ZlidarToLas(object):
    def __init__(self):
        self.label = "Zlidar To Las"
        self.description = "Converts one or more zlidar files into the LAS data format."
        self.category = "LiDAR Tools"

    def getParameterInfo(self):
        inputs = arcpy.Parameter(
            displayName="Input ZLidar Files",
            name="inputs",
            datatype="DEFile",
            parameterType="Optional",
            direction="Input")
        inputs.multiValue = True
        inputs.filter.list = ["las", "zip"]

        outdir = arcpy.Parameter(
            displayName="Output Directory",
            name="outdir",
            datatype="DEFolder",
            parameterType="Optional",
            direction="Input")

        params = [inputs, outdir]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        inputs = parameters[0].valueAsText
        if inputs is not None:
            items = inputs.split(";")
            items_path = []
            for item in items:
                items_path.append(arcpy.Describe(item).catalogPath)
            inputs = ";".join(items_path)
        outdir = parameters[1].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.zlidar_to_las(inputs=inputs, outdir=outdir)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


class ZonalStatistics(object):
    def __init__(self):
        self.label = "Zonal Statistics"
        self.description = "Extracts descriptive statistics for a group of patches in a raster."
        self.category = "Math and Stats Tools"

    def getParameterInfo(self):
        i = arcpy.Parameter(
            displayName="Input Data File",
            name="i",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        features = arcpy.Parameter(
            displayName="Input Feature Definition File",
            name="features",
            datatype="GPRasterLayer",
            parameterType="Required",
            direction="Input")

        output = arcpy.Parameter(
            displayName="Output Raster File",
            name="output",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        output.filter.list = ["tif"]

        stat = arcpy.Parameter(
            displayName="Statistic Type",
            name="stat",
            datatype="GPString",
            parameterType="Optional",
            direction="Input")
        stat.filter.type = "ValueList"
        stat.filter.list = ['mean', 'median', 'minimum', 'maximum', 'range', 'standard deviation', 'total']
        stat.value = 'mean'

        out_table = arcpy.Parameter(
            displayName="Output HTML Table File",
            name="out_table",
            datatype="DEFile",
            parameterType="Required",
            direction="Output")
        out_table.filter.list = ["html"]

        params = [i, features, output, stat, out_table]

        return params

    def updateParameters(self, parameters):
        return

    def updateMessages(self, parameters):
        for param in parameters:
            param_str = param.valueAsText
            if param_str is not None:
                try:
                    desc = arcpy.Describe(param_str)
                    if (".gdb\\" in desc.catalogPath) or (".mdb\\" in desc.catalogPath):
                        param.setErrorMessage("Datasets stored in a Geodatabase are not supported.")
                except:
                    param.clearMessage()
        return

    def execute(self, parameters, messages):
        i = parameters[0].valueAsText
        if i is not None:
            desc = arcpy.Describe(i)
            i = desc.catalogPath
        features = parameters[1].valueAsText
        if features is not None:
            desc = arcpy.Describe(features)
            features = desc.catalogPath
        output = parameters[2].valueAsText
        stat = parameters[3].valueAsText
        out_table = parameters[4].valueAsText
        old_stdout = sys.stdout
        result = StringIO()
        sys.stdout = result
        wbt.zonal_statistics(i=i, features=features, output=output, stat=stat, out_table=out_table)
        sys.stdout = old_stdout
        result_string = result.getvalue()
        messages.addMessage(result_string)
        return


